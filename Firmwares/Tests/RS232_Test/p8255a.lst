ca65 V2.18 - Ubuntu 2.19-1
Main file   : p8255a.s
Current file: p8255a.s

000000r 1               .setcpu "65C02"
000000r 1               .segment "CODE"
000000r 1               
000000r 1               .include "../../libs/pageZero.s"
000000r 2               ;Page Zero
000000r 2               T1		    = $5E
000000r 2               CMD_BUF		= $60
000000r 2               Q 		    = $75
000000r 2               L        	= $77
000000r 2               MSGL     	= $78
000000r 2               MSGH     	= $79
000000r 2               COUNTER  	= $7A
000000r 2               CRC      	= $7B
000000r 2               CRCCHECK 	= $7C
000000r 2               STL      	= $7D
000000r 2               STH      	= $7E
000000r 2               DIVISOR_LOW = $7F
000000r 2               DIVISOR_HIGH = $80
000000r 2               
000000r 1               
000000r 1               RESET:
000000r 1  78           	sei						; No interrupt
000001r 1  D8           	cld						; Set decimal
000002r 1  A2 FF        	ldx #$ff				; Set stack pointer
000004r 1  9A           	txs						;
000005r 1  20 rr rr     	jsr	delay				;
000008r 1  20 rr rr     	jsr initUart			; Configure uart to 9600 baudrate
00000Br 1               	;jsr init_8255
00000Br 1  20 rr rr     	jsr	delay				;
00000Er 1  A2 rr        	ldx #<Title1
000010r 1  A0 rr        	ldy #>Title1
000012r 1  20 rr rr     	jsr PrintString
000015r 1  A2 rr        	ldx #<Title2
000017r 1  A0 rr        	ldy #>Title2
000019r 1  20 rr rr     	jsr PrintString
00001Cr 1               NewLoop:
00001Cr 1  A9 0A            lda #$0A
00001Er 1  20 rr rr     	jsr write_byte
000021r 1  A9 0D            lda #$0D
000023r 1  20 rr rr     	jsr write_byte
000026r 1  A9 3E            lda #'>'
000028r 1  20 rr rr     	jsr write_byte
00002Br 1  20 rr rr     	jsr	delay				;
00002Er 1  20 rr rr     	jsr	read_byte
000031r 1  20 rr rr     	jsr	delay				;
000034r 1  20 rr rr     	jsr write_byte
000037r 1  C9 48        	cmp	#'H'
000039r 1  F0 0E        	beq	ShowCommands
00003Br 1  C9 3F        	cmp	#'?'
00003Dr 1  F0 0A        	beq	ShowCommands
00003Fr 1  C9 50        	cmp	#'P'
000041r 1  F0 10        	beq	Poke
000043r 1  20 rr rr     	jsr	delay				;
000046r 1  4C rr rr     	jmp NewLoop		;;Infinit loop
000049r 1               ShowCommands:
000049r 1  A2 rr        	ldx #<showCmd
00004Br 1  A0 rr        	ldy #>showCmd
00004Dr 1  20 rr rr     	jsr PrintString
000050r 1  4C rr rr     	jmp NewLoop
000053r 1               Poke:
000053r 1  20 rr rr     	jsr	read_line
000056r 1  A2 60        	ldx #<CMD_BUF
000058r 1  A0 00        	ldy	#0
00005Ar 1  B1 60        	lda (CMD_BUF),y
00005Cr 1  20 rr rr     	jsr write_byte
00005Fr 1  B1 60        	lda (CMD_BUF),y
000061r 1  20 rr rr     	jsr write_byte
000064r 1  C8           	iny
000065r 1  B1 60        	lda (CMD_BUF),y
000067r 1  20 rr rr     	jsr write_byte
00006Ar 1  C8           	iny
00006Br 1  B1 60        	lda (CMD_BUF),y
00006Dr 1  20 rr rr     	jsr write_byte
000070r 1  C8           	iny
000071r 1  B1 60        	lda (CMD_BUF),y
000073r 1  20 rr rr     	jsr write_byte
000076r 1  C8           	iny
000077r 1  B1 60        	lda (CMD_BUF),y
000079r 1  20 rr rr     	jsr write_byte
00007Cr 1  C8           	iny
00007Dr 1  B1 60        	lda (CMD_BUF),y
00007Fr 1  20 rr rr     	jsr write_byte
000082r 1  C8           	iny
000083r 1  B1 60        	lda (CMD_BUF),y
000085r 1  20 rr rr     	jsr write_byte
000088r 1  C8           	iny
000089r 1  B1 60        	lda (CMD_BUF),y
00008Br 1  20 rr rr     	jsr write_byte
00008Er 1  C8           	iny
00008Fr 1  B1 60        	lda (CMD_BUF),y
000091r 1  20 rr rr     	jsr write_byte
000094r 1  C8           	iny
000095r 1  B1 60        	lda (CMD_BUF),y
000097r 1  20 rr rr     	jsr write_byte
00009Ar 1  C8           	iny
00009Br 1  B1 60        	lda (CMD_BUF),y
00009Dr 1  20 rr rr     	jsr write_byte
0000A0r 1  C8           	iny
0000A1r 1  B1 60        	lda (CMD_BUF),y
0000A3r 1  20 rr rr     	jsr write_byte
0000A6r 1  C8           	iny
0000A7r 1  B1 60        	lda (CMD_BUF),y
0000A9r 1  20 rr rr     	jsr write_byte
0000ACr 1  4C rr rr     	jmp NewLoop
0000AFr 1               
0000AFr 1               Title1:
0000AFr 1  0A 0D 36 35  	.byte $0A,$0D,"6502 - SystemTest Copyright (C) 2024",CR,LF
0000B3r 1  30 32 20 2D  
0000B7r 1  20 53 79 73  
0000D7r 1  43 50 55 20  	.byte "CPU HBC-56 - Spartan 56",CR,LF,CR,LF,0,0,0,0
0000DBr 1  48 42 43 2D  
0000DFr 1  35 36 20 2D  
0000F6r 1               Title2:
0000F6r 1  43 50 55 20  	.byte "CPU parameters: ",CR,LF
0000FAr 1  70 61 72 61  
0000FEr 1  6D 65 74 65  
000108r 1  43 6C 6F 63  	.byte "Clock......:	1.8Mhz",CR,LF
00010Cr 1  6B 2E 2E 2E  
000110r 1  2E 2E 2E 3A  
00011Dr 1  4D 65 6D 6F  	.byte "Memoria RAM:	32k",CR,LF
000121r 1  72 69 61 20  
000125r 1  52 41 4D 3A  
00012Fr 1  4D 65 6D 6F  	.byte "Memoria ROM:	12k",CR,LF
000133r 1  72 69 61 20  
000137r 1  52 4F 4D 3A  
000141r 1  53 65 72 69  	.byte "Serial.....:	16C550",CR,LF
000145r 1  61 6C 2E 2E  
000149r 1  2E 2E 2E 3A  
000156r 1  53 65 72 69  	.byte "Serial clk.:	1.8Mhz",CR,LF
00015Ar 1  61 6C 20 63  
00015Er 1  6C 6B 2E 3A  
00016Br 1  56 69 61 2E  	.byte "Via........:	P8255A",CR,LF
00016Fr 1  2E 2E 2E 2E  
000173r 1  2E 2E 2E 3A  
000180r 1  44 65 63 6F  	.byte "Decod......: GAL20V8B",CR,LF
000184r 1  64 2E 2E 2E  
000188r 1  2E 2E 2E 3A  
000197r 1  42 75 73 2E  	.byte "Bus........: SC112",CR,LF,0,0,0
00019Br 1  2E 2E 2E 2E  
00019Fr 1  2E 2E 2E 3A  
0001AEr 1               
0001AEr 1               showCmd:
0001AEr 1  48 2F 3F 20  	.byte	"H/? - show commands",CR,LF
0001B2r 1  2D 20 73 68  
0001B6r 1  6F 77 20 63  
0001C3r 1  4D 2C 3C 61  	.byte	"M,<addr> 		- Set memory addr",CR,LF
0001C7r 1  64 64 72 3E  
0001CBr 1  20 09 09 2D  
0001E1r 1  53 2C 3C 61  	.byte	"S,<addr> 		- Show memory addr",CR,LF
0001E5r 1  64 64 72 3E  
0001E9r 1  20 09 09 2D  
000200r 1  50 2C 3C 61  	.byte	"P,<addr>,data 	- Poke data int addr memory",CR,LF
000204r 1  64 64 72 3E  
000208r 1  2C 64 61 74  
00022Cr 1  52 2C 3C 61  	.byte	"R,<addr> 		- Run program at memory addr",CR,LF
000230r 1  64 64 72 3E  
000234r 1  20 09 09 2D  
000255r 1  41 6C 6C 20  	.byte	"All address must be in hexadecimal $0000 to $FFFF",CR,LF
000259r 1  61 64 64 72  
00025Dr 1  65 73 73 20  
000288r 1  43 6F 6D 6D  	.byte	"Commands Version 0.1.0",CR,LF,0,0,0
00028Cr 1  61 6E 64 73  
000290r 1  20 56 65 72  
0002A3r 1               
0002A3r 1               .include "serial16550.s"
0002A3r 2               ;***********************************************************************
0002A3r 2               ; SERIAL 16c550 DRIVER
0002A3r 2               ;
0002A3r 2               
0002A3r 2               ;Uart registers
0002A3r 2               ;UART_PORT   = $C000            ;;Uart address
0002A3r 2               RBR         = $C000    ;;receiver buffer register (read only)
0002A3r 2               THR         = $C000    ;;transmitter holding register (write only)
0002A3r 2               DLL         = $C000    ;;divisor latch LSB (if DLAB=1)
0002A3r 2               DLH         = $C001    ;;divisor latch HSB (if DLAB=1)
0002A3r 2               IER         = $C001    ;;interrupt enable register
0002A3r 2               IIR         = $C002    ;;interrupt identification register
0002A3r 2               FCR         = $C002    ;;FIFO control register
0002A3r 2               LCR         = $C003    ;;line control register
0002A3r 2               MCR         = $C004    ;;modem control register
0002A3r 2               ULSR        = $C005    ;;line status register
0002A3r 2               MSR         = $C006    ;;modem status register
0002A3r 2               SCR	        = $C007	   ;;scratch register
0002A3r 2               
0002A3r 2               ; Constants
0002A3r 2               CR  = $0D ; Carriage Return
0002A3r 2               LF  = $0A ; Line feed
0002A3r 2               SP  = $20 ; Space
0002A3r 2               ESC = $1B ; Escape
0002A3r 2               
0002A3r 2               DIV_9600_LO = 12
0002A3r 2               DIV_9600_HI = 0
0002A3r 2               POLLED_MODE = %00000000
0002A3r 2               LCR_8N1 = %00000011
0002A3r 2               DLAB    = %10000000
0002A3r 2               FIFO_ENABLE = %00000111 ;%00000111
0002A3r 2               THR_EMPTY = %01100000       ;;
0002A3r 2               
0002A3r 2               DATA_READY = %00000001
0002A3r 2               OVERRUN_ERR = %00000010
0002A3r 2               PARITY_ERR = %00000100
0002A3r 2               FRAMING_ERR = %00001000
0002A3r 2               BREAK_INT = %00010000
0002A3r 2               
0002A3r 2               
0002A3r 2               initUart:
0002A3r 2  48               pha
0002A4r 2  A9 80            lda #DLAB
0002A6r 2  8D 03 C0         sta LCR                 ;set the divisor latch access bit (DLAB)
0002A9r 2  A9 0C            lda #DIV_9600_LO
0002ABr 2  8D 00 C0         sta DLL                 ;store divisor low byte (4800 baud @ 1 MHz clock)
0002AEr 2  A9 00            lda #DIV_9600_HI
0002B0r 2  8D 01 C0         sta DLH                 ;store divisor hi byte
0002B3r 2                                           ;set 8 data bits, 1 stop bit, no parity, disable DLAB
0002B3r 2  A9 07            lda #FIFO_ENABLE
0002B5r 2  8D 02 C0         sta FCR                 ;enable the UART FIFO
0002B8r 2  A9 00            lda #POLLED_MODE
0002BAr 2  8D 01 C0         sta IER                 ;disable all interrupts
0002BDr 2  A9 03        	lda #LCR_8N1
0002BFr 2  8D 03 C0         sta LCR
0002C2r 2  68               pla
0002C3r 2  60               rts
0002C4r 2               
0002C4r 2               ; A: Data read
0002C4r 2               ; Returns:  F = C if character read
0002C4r 2               ;           F = NC if no character read
0002C4r 2               ;
0002C4r 2               read_byte:
0002C4r 2  AD 05 C0     	lda ULSR 												    ;// check the line status register:
0002C7r 2  29 1E        	and #(OVERRUN_ERR | PARITY_ERR | FRAMING_ERR | BREAK_INT)   ; check for errors
0002C9r 2  F0 04        	beq no_err 												    ;// if no error bits, are set, no error
0002CBr 2  AD 00 C0     	lda RBR 												    ;// otherwise, there was an error. Clear the error byte
0002CEr 2               	;sec 													    ;// set the carry flag to indicate error
0002CEr 2  60           	rts
0002CFr 2               no_err:
0002CFr 2  AD 05 C0     	lda ULSR 												    ;// reload the line status register
0002D2r 2  29 01        	and #DATA_READY
0002D4r 2  F0 EE        	beq read_byte   											;// if data ready is not set, loop
0002D6r 2  AD 00 C0     	lda RBR 		    										;// otherwise, we have data! Load it.
0002D9r 2               	;clc 				    									;// clear the carry flag to indicate no error
0002D9r 2  60           	rts
0002DAr 2               
0002DAr 2               ; A: Data to write
0002DAr 2               ;
0002DAr 2               write_byte:
0002DAr 2  48               pha                     ;
0002DBr 2               wait_for_thr_empty:         ;
0002DBr 2  AD 05 C0         lda ULSR                ; Get the line status register
0002DEr 2  29 60            and #THR_EMPTY          ; Check for TX empty
0002E0r 2  F0 F9            beq wait_for_thr_empty 	; loop while the THR is not empty
0002E2r 2  68           	pla                     ;
0002E3r 2  8D 00 C0     	sta THR 				; send the byte
0002E6r 2               
0002E6r 2  A2 50        	ldx  #$50   ; (2 cycles)
0002E8r 2               delay22:
0002E8r 2  EA           	nop			; (2 cycles) 1us
0002E9r 2  CA           	dex         ; (2 cycles) 1us
0002EAr 2  D0 FC        	bne  delay22 ; (3 cycles in loop, 2 cycles at end) 1,5us in loop, 1us at end
0002ECr 2  60               rts                     ;
0002EDr 2               
0002EDr 2               PrintString:
0002EDr 2  86 5E        	stx T1
0002EFr 2  84 5F        	sty T1+1
0002F1r 2  A0 00        	ldy #0
0002F3r 2               @loop:
0002F3r 2  B1 5E        	lda (T1),Y
0002F5r 2  F0 07        	beq done
0002F7r 2  20 rr rr     	jsr write_byte
0002FAr 2  C8           	iny
0002FBr 2  4C rr rr     	jmp @loop       ; if doesn't branch, string is too long
0002FEr 2               done:
0002FEr 2  60           	rts
0002FFr 2               
0002FFr 2               read_line:
0002FFr 2  A2 rr        	ldx #<LINE
000301r 2  A0 rr        	ldy #>LINE
000303r 2  20 rr rr     	jsr PrintString
000306r 2  A0 00        	ldy	#0
000308r 2  A9 0D        	lda	#13
00030Ar 2  85 7A        	sta	COUNTER
00030Cr 2               @read_line:
00030Cr 2  20 rr rr     	jsr	read_byte
00030Fr 2  20 rr rr     	jsr	write_byte
000312r 2  91 60        	sta	(CMD_BUF),y
000314r 2  C8           	iny
000315r 2  C6 7A        	dec	COUNTER
000317r 2  F0 14        	beq	fim
000319r 2  C9 0D        	cmp	#$0D
00031Br 2  D0 EF        	bne	@read_line
00031Dr 2  A9 0A        	lda	#$0A
00031Fr 2  91 60        	sta	(CMD_BUF),y
000321r 2  20 rr rr     	jsr	write_byte
000324r 2  C8           	iny
000325r 2  A9 00        	lda	#$00
000327r 2  91 60        	sta	(CMD_BUF),y
000329r 2  20 rr rr     	jsr	write_byte
00032Cr 2  60           	rts
00032Dr 2               fim:
00032Dr 2  A9 0D        	lda	#$0D
00032Fr 2  91 60        	sta	(CMD_BUF),y
000331r 2  20 rr rr     	jsr	write_byte
000334r 2  C8           	iny
000335r 2  A9 0A        	lda	#$0A
000337r 2  91 60        	sta	(CMD_BUF),y
000339r 2  20 rr rr     	jsr	write_byte
00033Cr 2  C8           	iny
00033Dr 2  A9 00        	lda	#$00
00033Fr 2  91 60        	sta	(CMD_BUF),y
000341r 2  60           	rts
000342r 2               LINE:
000342r 2  44 69 67 69      .byte "Digite uma linha de comando",CR,LF
000346r 2  74 65 20 75  
00034Ar 2  6D 61 20 6C  
00035Fr 2  23 20 00 00      .byte "# ",0,0,0
000363r 2  00           
000364r 2               
000364r 1               .include "../../libs/delay.s"
000364r 2               ;-----------------------------------------------------------------------------------------
000364r 2               ; Delay
000364r 2               ;cpu clock..: 1.843.200 hz
000364r 2               ;period.....: 0,542 ns
000364r 2               ;delay total: 1,0 ms
000364r 2               delay:
000364r 2               	;PHX
000364r 2  A2 CD        	ldx  #$CD   ; (2 cycles)
000366r 2               delay1:
000366r 2  EA           	nop			; (2 cycles) 1us
000367r 2  CA           	dex         ; (2 cycles) 1us
000368r 2  D0 FC        	bne  delay1 ; (3 cycles in loop, 2 cycles at end) 1,5us in loop, 1us at end
00036Ar 2               	;PLX
00036Ar 2  60           	rts
00036Br 2               
00036Br 2               
00036Br 2               delay2:
00036Br 2  48           	pha
00036Cr 2  8A           	txa
00036Dr 2  48           	pha
00036Er 2  A2 05        	ldx  #$5   ; (2 cycles)
000370r 2               delay21:
000370r 2  EA           	nop			; (2 cycles) 1us
000371r 2  CA           	dex         ; (2 cycles) 1us
000372r 2  D0 FC        	bne  delay21 ; (3 cycles in loop, 2 cycles at end) 1,5us in loop, 1us at end
000374r 2  68           	pla
000375r 2  AA           	tax
000376r 2  68           	pla
000377r 2  60           	rts
000378r 2               
000378r 1               ;.include "drv8255a.s"
000378r 1               
000378r 1               ;Cpu reset address
000378r 1               .segment    "RESETVEC"
000000r 1               
000000r 1  00 00        	.word   $0000
000002r 1  rr rr        	.word   RESET
000004r 1  00 00        	.word   $0000
000004r 1               
