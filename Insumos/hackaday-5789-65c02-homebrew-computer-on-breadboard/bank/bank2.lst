AS65 Assembler for R6502 [1.42].                                     Page    1
-------------------------------- bank\bank2.s --------------------------------

5358 lines read, no errors in pass 1.
                             	include "kernel\kernel.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  KERNEL.S
                             ;*	The 'kernel' routine includes code and data wh
                             ;* 	be in every ROM bank.  In the auto-generated 
                             ;*  files, the kernel is added before the bank sp
                             ;*	code.  See bank0.s as an example.
                             ;*
                             ;************************************************
                             
                             ;* Include all definition and code files in the r
                             	include "inc\includes.i"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  INCLUDES.S
                             ;*  Main include file for key definitions and mac
                             ;*  Many of the settings here are exremely machin
                             ;*  Defines : IO block addresses, VIA port usage,
                             ;*  settings, useful macros, sound chip registers
                             ;*  VDP registers, ACIA registers.
                             ;*
                             ;************************************************
                             
                             ;* The IO block is at 0x04000 and decodes up to
                             ;* eight IO addresses, at 0x0080 intervals
                             ;* All eight are not used at the present time:
                             ;* - 0 : VIA 1 (Keyboard)
                             ;* - 1 : VIA 2 (Sound and SD card interface)
                             ;* - 2 : VDP (Video)
                             ;* - 3 : ACIA (Serial)
0400 =                       IO_0		= 0x0400
0480 =                       IO_1		= 0x0480
0500 =                       IO_2		= 0x0500
0580 =                       IO_3		= 0x0580
0600 =                       IO_4		= 0x0600
0680 =                       IO_5		= 0x0680
0700 =                       IO_6		= 0x0700
0780 =                       IO_7		= 0x0780
                             
                             ;* VDP is accessed through IO_2
0500 =                       VDP_MODE0		= IO_2
0501 =                       VDP_MODE1		= IO_2+1
0501 =                       VDP_STATUS		= IO_2+1
0501 =                       VDP_ADDR		= IO_2+1
0500 =                       VDP_VRAM		= IO_2
0001 =                       VDP_SHORTDELAY	= 1
0002 =                       VDP_LONGDELAY 	= 2
0010 =                       VDP_FLASH		= 0x10				;* Must be a power of 2 *
AS65 Assembler for R6502 [1.42].                                     Page    2
-------------------------------- bank\bank2.s --------------------------------

                             
                             ;* This structure defines the key information
                             ;* kept about the VDP current mode
0000 =                       	struct vdp_addr_struct
0000 =                       	dw vdp_addr_nme				;* Address of name table
0002 =                       	dw vdp_addr_col				;* Address of colour table
0004 =                       	dw vdp_addr_pat				;* Address of pattern table
0006 =                       	dw vdp_addr_spa				;* Address of sprite pattern 
0008 =                       	dw vdp_addr_spp				;* Address of sprite position
000a =                       	db vdp_bord_col				;* Value of border colour
                             	end struct
                             
                             ;* Standard definitions of 6522 registers
                             ;* As found in the datasheets
0000 =                       PRB			= 0x00
0001 =                       PRA			= 0x01
0002 =                       DDRB		= 0x02
0003 =                       DDRA		= 0x03
0004 =                       T1CL		= 0x04
0005 =                       T1CH		= 0x05
0006 =                       T1LL		= 0x06
0007 =                       T1LH		= 0x07
0008 =                       T2CL		= 0x08
0009 =                       T2CH		= 0x09
000a =                       SR			= 0x0a
000b =                       ACR			= 0x0b
000c =                       PCR			= 0x0c
000d =                       IFR			= 0x0d
000e =                       IER			= 0x0e
000f =                       PRAH		= 0x0f
                             
0001 =                       IFR_CA2		= 0x01
0002 =                       IFR_CA1		= 0x02
                             
                             ;* AY-3-8910 definitions
                             ;* The sound chip is accessed through VIA 2
0481 =                       SND_ADBUS	= IO_1+PRA
0480 =                       SND_MODE	= IO_1+PRB
                             
0040 =                       SND_SELREAD			= 0x40
0002 =                       SND_SELWRITE		= 0x02
0042 =                       SND_SELSETADDR		= (SND_SELREAD|SND_SELWRITE)
00bd =                       SND_DESELECT_MASK	= (0xff-SND_SELREAD-SND_SELWRIT
                             
0000 =                       SND_REG_CHAPL	= 0x00
0001 =                       SND_REG_CHAPH	= 0x01
0002 =                       SND_REG_CHBPL	= 0x02
0003 =                       SND_REG_CHBPH	= 0x03
0004 =                       SND_REG_CHCPL	= 0x04
0005 =                       SND_REG_CHCPH	= 0x05
0006 =                       SND_REG_CHNP	= 0x06
0007 =                       SND_REG_CTL		= 0x07
0008 =                       SND_REG_CHAVOL	= 0x08
0009 =                       SND_REG_CHBVOL	= 0x09
000a =                       SND_REG_CHBVOL	= 0x0a
000b =                       SND_REG_ENVPL	= 0x0b
000c =                       SND_REG_ENVPH	= 0x0c
000d =                       SND_REG_ENVCYC	= 0x0d
                             
000e =                       SND_REG_IOA	= 0x0e
000f =                       SND_REG_IOB	= 0x0f
                             
AS65 Assembler for R6502 [1.42].                                     Page    3
-------------------------------- bank\bank2.s --------------------------------

                             ;* 6551 ACIA definitions
                             ;* As found in the datasheets
0580 =                       SER_DATA	= (IO_3+0)
0581 =                       SER_STATUS	= (IO_3+1)
0581 =                       SER_RESET	= (IO_3+1)
0582 =                       SER_CMD		= (IO_3+2)
0583 =                       SER_CTL		= (IO_3+3)
                             
0080 =                       SER_IRQ		= 0x80
0040 =                       SER_DSRB	= 0x40
0020 =                       SER_DCDB	= 0x20
0010 =                       SER_TDRE	= 0x10
0008 =                       SER_RDRF	= 0x08
0004 =                       SER_OVRN	= 0x04
0002 =                       SER_FE		= 0x02
0001 =                       SER_PE		= 0x01
0080 =                       SER_SBN		= 0x80
0040 =                       SER_WL1		= 0x40
0020 =                       SER_WL0		= 0x20
0060 =                       SER_WL		= (SER_WL1|SER_WL0)
0010 =                       SER_RCS		= 0x10
0008 =                       SER_SBR3	= 0x08
0004 =                       SER_SBR2	= 0x04
0002 =                       SER_SBR1	= 0x02
0001 =                       SER_SBR0	= 0x01
000f =                       SER_SBR		= (SER_SBR3|SER_SBR2|SER_SBR1|SER_SBR0)
000f =                       SER_19200B	= (SER_SBR3|SER_SBR2|SER_SBR1|SER_SBR0
000e =                       SER_9600B	= (SER_SBR3|SER_SBR2|SER_SBR1)
0080 =                       SER_PMC1	= 0x80
0040 =                       SER_PMC0	= 0x40
00c0 =                       SER_PMC		= (SER_PMC1|SER_PMC0)
0020 =                       SER_PME		= 0x20
0010 =                       SER_REM		= 0x10
0008 =                       SER_TIC1	= 0x08
0004 =                       SER_TIC0	= 0x04
000c =                       SER_TIC		= (SER_TIC1|SER_TIC0)
0002 =                       SER_IRD		= 0x02
0001 =                       SER_DTR		= 0x01
                             
                             ;* BBC keyboard definitions
                             ;* The keyboard is accessed through VIA 1
                             ;* Port A - all output
0001 =                       KB_ROWA		= 0x01
0002 =                       KB_ROWB		= 0x02
0004 =                       KB_ROWC		= 0x04
0008 =                       KB_COLA		= 0x08
0010 =                       KB_COLB		= 0x10
0020 =                       KB_COLC		= 0x20
0040 =                       KB_COLD		= 0x40
0080 =                       KB_EN		= 0x80
                             ;* Port B
0001 =                       KB_W		= 0x01			; Input - BBC keyboard hardware se
0002 =                       KB_LED0		= 0x02			; Output - led 0
0004 =                       KB_LED1		= 0x04			; Output - led 1
0008 =                       KB_LED2		= 0x08			; Output - led 2
0001 =                       KB_CAPSLK	= 0x01			; Id of Caps Lock - maps to Le
0002 =                       KB_SHIFTLK	= 0x02			; Id of Shift lock - maps to 
                             
0005 =                       KB_REP_TIM	= 5				; Number of VB periods for the 
001e =                       KB_REP_DEL	= 30			; Number of VB periods before r
0003 =                       KB_DEBOUNCE	= 3				; Number of VB periods before 
                             
AS65 Assembler for R6502 [1.42].                                     Page    4
-------------------------------- bank\bank2.s --------------------------------

0003 =                       UTF_ETX		= 0x03			; Break character
0007 =                       UTF_BEL		= 0x07
0008 =                       CRSR_LEFT	= 0x08
0009 =                       CRSR_RIGHT	= 0x09
000a =                       CRSR_DOWN	= 0x0a
000b =                       CRSR_UP		= 0x0b
0006 =                       UTF_ACK		= 0x06			; Used for the copy key in this
000c =                       UTF_FF		= 0x0c
000d =                       UTF_CR		= 0x0d
001a =                       UTF_BRK		= 0x1a			; Debug - drop in to monitor
007f =                       UTF_DEL		= 0x7f
0020 =                       UTF_SPECIAL = 0x20
                             
                             ;* SD Card interface definitions
                             ;* The card is accessed through port B of VIA 2
0001 =                       SD_CLK		= 0x01			; Clock output to SD card
0004 =                       SD_CD		= 0x04			; Card detect input
0008 =                       SD_CS		= 0x08			; Card select output
0010 =                       SD_DI		= 0x10			; Data output from VIA to SD Card
0080 =                       SD_DO		= 0x80			; Data input to VIA from SD card
                             
0010 =                       SD_MOSI		= SD_DI
0080 =                       SD_MISO		= SD_DO
0480 =                       SD_REG		= IO_1+PRB
                             
0000 =                       CMD_ERR_NOERROR			= 0x00
0001 =                       CMD_ERR_NOTFOUND		= 0x01
0002 =                       CMD_ERR_PARM			= 0x02
0003 =                       CMD_ERR_VAL				= 0x03
                             
                             ;* Memory management definitions
                             ;* Y1,Y0 = ROM bank selection CIA1 PORTB
0080 =                       MM_Y1					= 0x80
0040 =                       MM_Y0					= 0x40
                             ;* X1,X0 = RAM bank selection CIA1 PORTB
0020 =                       MM_X1					= 0x20
0010 =                       MM_X0					= 0x10
                             ;* DIS = ROM disable *CIA2* PORTB
0020 =                       MM_DIS					= 0x20
                             
                             ;* Number formats for conversion routines
0000 =                       NUM_ANY		= 0x00
0001 =                       NUM_DEC		= 0x01
0002 =                       NUM_HEX		= 0x02
0003 =                       NUM_BIN		= 0x03
                             
                             	
                             ;* SD Card Master Boot Record (MBR) definitions
                             ;* The MBR contains the essential information
                             ;* needed to access the data on the card
                             ;* MBR is usually sector 0, but not always
                             ;* however the card I am using does work ok.
0000 =                       MBR_Code				=	0x0000
0003 =                       MBR_OEMName				=	0x0003
000b =                       MBR_BytesPerSect		=	0x000b
000d =                       MBR_SectPerClust		=	0x000d
000e =                       MBR_ResvSect			=	0x000e
0010 =                       MBR_FATCopies			=	0x0010
0011 =                       MBR_RootEntries			=	0x0011
0013 =                       MBR_SmlSect				=	0x0013
0015 =                       MBR_MediaDesc			=	0x0015
0016 =                       MBR_SectPerFAT			=	0x0016
AS65 Assembler for R6502 [1.42].                                     Page    5
-------------------------------- bank\bank2.s --------------------------------

0018 =                       MBR_SectPerTrk			=	0x0018
001a =                       MBR_NumHeads			=	0x001a
001c =                       MBR_NumHidSect			=	0x001c
0020 =                       MBR_NumSect				=	0x0020
0024 =                       MBR_DrvNum				=	0x0024
0026 =                       MBR_ExtSig				=	0x0026
0027 =                       MBR_SerNo				=	0x0027
002b =                       MBR_VolName				=	0x002b
0036 =                       MBR_FATName				=	0x0036
003e =                       MBR_ExeCode				=	0x003e
01c6 =                       MBR_BootPart1			=	(0x01be+0x08)
01fe =                       MBR_ExeMark				=	0x01fe
                             
                             ;* FAT16 definitions - these are offsets
                             ;* in to a FAT table entry which is
                             ;* 32 bytes in length.
0000 =                       FAT_Name				= 	0x00
0008 =                       FAT_Ext					=	0x08
000b =                       FAT_Attr				=	0x0b
000c =                       FAT_Resv				=	0x0c
000d =                       FAT_Createms			=	0x0d
000e =                       FAT_CreateTime			=	0x0e
0010 =                       FAT_CreateDate			=	0x10
0012 =                       FAT_AccessDate			=	0x12
0014 =                       FAT_EAIndex				=	0x14
0016 =                       FAT_ModTime				=	0x16
0018 =                       FAT_ModDate				=	0x18
001a =                       FAT_FirstClust			=	0x1a
001c =                       FAT_FileSize			=	0x1c
                             
                             ;* The FileHandle stucture is key to
                             ;* accessing the file system
0000 =                       	struct FileHandle
0000 =                       	ds FH_Name, 13			; 8 name, 3 extension, 1 separa
000d =                       	ds FH_Size, 4
0011 =                       	ds FH_Attr, 1
0012 =                       	ds FH_CurrClust, 2
0014 =                       	ds FH_SectCounter, 1
0015 =                       	ds FH_CurrSec, 4
0019 =                        	ds FH_Pointer, 4
001d =                       	ds FH_DirSect, 4
0021 =                       	ds FH_DirOffset, 2
0023 =                       	ds FH_FirstClust, 2
0025 =                       	ds FH_LastClust, 2
0027 =                       	ds FH_FileMode, 1
                             	end struct
                             
0001 =                       FS_BLK_FLG_LOAD		 	= 	0x01		; On next byte, load 
0002 =                       FS_BLK_FLG_FLUSH		=	0x02		; Block has changed, ne
                             	
0001 =                       FS_ERR_EOF				=	0x01
                             
                             
                             ;* USEFUL MACROS HERE
                             
                             ;* Software break to throw errors
                             ;* use like this : SWBRK XX
                             ;* Where XX is the error code
                             SWBRK macro sig
                             	brk
                             	db sig
                             	endm
AS65 Assembler for R6502 [1.42].                                     Page    6
-------------------------------- bank\bank2.s --------------------------------

                             
                             _pushAXY macro
                             	pha
                             	phx
                             	phy
                             	endm
                             
                             _pullAXY macro
                             	ply
                             	plx
                             	pla
                             	endm
                             
                             _println macro msg
                             	_pushAXY
                             	ldx #lo(msg)
                             	lda #hi(msg)
                             	jsr io_print_line
                             	_pullAXY
                             	endm
                             
                             _printmsgA macro msg
                             	phx
                             	phy
                             	pha
                             	ldx #lo(msg)
                             	lda #hi(msg)
                             	jsr io_print_line
                             	pla
                             	pha
                             	jsr str_a_to_x
                             	jsr _put_byte
                             	txa
                             	jsr _put_byte
                             	lda #UTF_CR
                             	jsr _put_byte
                             	pla
                             	ply
                             	plx
                             	endm
                             
                             _printA macro
                             	phx
                             	phy
                             	pha
                             	jsr str_a_to_x
                             	jsr _put_byte
                             	txa
                             	jsr _put_byte
                             	pla
                             	ply
                             	plx
                             	endm
                             
                             _printCRLF macro
                             	pha
                             	lda #UTF_CR
                             	jsr _put_byte
                             	pla
                             	endm
                             
                             _printC macro ch
AS65 Assembler for R6502 [1.42].                                     Page    7
-------------------------------- bank\bank2.s --------------------------------

                             	pha
                             	lda #ch
                             	jsr _put_byte
                             	pla
                             	endm
                             
                             _printCA macro
                             	pha
                             	jsr _put_byte
                             	pla
                             	endm
                             
                             _sendcmd macro cmd
                             	_pushAXY
                             	ldx #lo(cmd)
                             	lda #hi(cmd)
                             	jsr sd_sendcmd
                             	_pullAXY
                             	endm
                             
                             _incZPWord macro wordp
                             	inc wordp
                             	db	0xd0, 0x02
                             	inc wordp+1
                             	endm
                             
                             _decZPWord macro wordp
                             	pha
                             	sec
                             	lda wordp
                             	sbc #1
                             	sta wordp
                             	lda wordp+1
                             	sbc #0
                             	sta wordp+1
                             	pla
                             	endm
                             
                             _cpyZPWord macro worda,wordb
                             	lda worda
                             	sta wordb
                             	lda worda+1
                             	sta wordb+1
                             	endm
                             	
                             _addZPWord macro worda, wordb
                             	clc
                             	lda worda
                             	adc wordb
                             	sta worda
                             	lda worda+1
                             	adc wordb+1
                             	sta worda+1
                             	endm
                             
                             _subZPWord macro worda, wordb
                             	sec
                             	lda worda
                             	sbc wordb
                             	sta worda
                             	lda worda+1
                             	sbc wordb+1
AS65 Assembler for R6502 [1.42].                                     Page    8
-------------------------------- bank\bank2.s --------------------------------

                             	sta worda+1
                             	endm
                             	
                             _adcZPWord macro worda,const
                             	clc
                             	lda worda
                             	adc #const
                             	sta worda
                             	lda worda+1
                             	adc #0
                             	sta worda+1
                             	endm
                             
                             
                             	include "inc\graph.i"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  GRAPH.I
                             ;*  This is the definition file for graphics, spe
                             ;*  The graphics screen handling module.  It is j
                             ;*  structure definition - but this structure is 
                             ;*  record the important attributes of a text scr
                             ;*  Needed because there is both a 40 and 32 colu
                             ;*  supported by the VDP, and the screens are not
                             ;*  same location.
                             ;*
                             ;************************************************
                             
0000 =                       	struct gr_screen
0000 =                       	dw gr_screen_start			; Start of screen memory in
0002 =                       	dw gr_screen_size			; Number of bytes screen occ
0004 =                       	db gr_screen_w				; Number of columns
0005 =                       	db gr_screen_h				; Number of rows
0006 =                       	db gr_cur_off				; Y offset of cursor image from
0007 =                       	db gr_cur_x					; Current X position of cursor
0008 =                       	db gr_cur_y					; Current Y position of cursor
0009 =                       	dw gr_cur_ptr				; VDP address of cursor
000b =                       	db gr_pixmode				; Pixel plot mode (0=Erase, 1=P
000c =                       	db gr_pixmask				; Pixel plot mask
000d =                       	db gr_pixcol				; Pixel colour
000e =                       	dw gr_geom_tmp				; One word of temp storage for
                             	end struct
                             	include "io\io.i"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  IO.I
                             ;*  Definitions file for the IO module.  The key 
                             ;*  used by the IO system is defined here.
                             ;*
                             ;************************************************
AS65 Assembler for R6502 [1.42].                                     Page    9
-------------------------------- bank\bank2.s --------------------------------

                             
                             ;* General IO structure allows the system to swap
                             ;* different IO devices by using indirect calls t
                             ;* the appropriate routines.
0000 =                       	struct io_struct
0000 =                       	ds	io_get_byte,	2			;* Address of get byte
0002 =                       	ds	io_put_byte,	2			;* Address of put byte
0004 =                       	ds	io_open_r,		2			;* Address of open file for r
0006 =                       	ds	io_open_w,		2			;* Address of open file for w
0008 =                       	ds	io_close_f,		2			;* Address of close file
000a =                       	ds	io_del_f,		2			;* Address of delete file
000c =                       	ds	io_ext1,		2			;* Address of extended function
000e =                       	ds	io_ext2,		2			;* Address of extended function
                             	end struct
                             	include "dflat\dflat.i"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  DFLAT.I
                             ;*  This is the main definitions file for dflat. 
                             ;*  definitions are in here to access the data st
                             ;*  used by dflat.
                             ;*
                             ;************************************************
                             
                             ;* Start dflat program memory
0cbb =                       DF_PROGSTART=	mem_start
                             ;* This is the top of usable dflat memory plus 1
c000 =                       DF_MEMTOP	=	0xc000
                             
                             ;* Offset in to tokenised line of length and line
0000 =                       DFTK_LINLEN	=	0x00
0001 =                       DFTK_LINNUM	=	0x01
                             
                             ;* Flags for token, escape value for data types a
0080 =                       DFTK_TOKEN	=	0x80
0020 =                       DFTK_ESCVAL	=	0x20
0000 =                       DFTK_EOL	=	0x00
                             
                             ;* Numeric constants are encoded based on size an
                             ;* user representation.
                             ;* For example the decimal value 16 will be encod
                             ;* DFTK_INTDEC followed by the bytes 0 and 16 to 
                             ;* The same value in binary will be encoded as DF
                             ;* followed by the same 0 and 16 bytes.  This is 
                             ;* tokenised value to be displayed in original re
                             ;* So in the two examples, they will be shown as 
                             ;* '0x0010' respectively.
0000 =                       DFTK_CHR	=	0x00
0001 =                       DFTK_RESV1	=	0x01
0002 =                       DFTK_RESV2	=	0x02
0003 =                       DFTK_RESV3	=	0x03
0004 =                       DFTK_RESV4	=	0x04
0005 =                       DFTK_BYTDEC	=	0x05
0006 =                       DFTK_BYTHEX = 	0x06
0007 =                       DFTK_BYTBIN =	0x07
0008 =                       DFTK_RESV8	=	0x08
AS65 Assembler for R6502 [1.42].                                     Page   10
-------------------------------- bank\bank2.s --------------------------------

0009 =                       DFTK_INTDEC	=	0x09
000a =                       DFTK_INTHEX =	0x0a
000b =                       DFTK_INTBIN	=	0x0b
000c =                       DFTK_RESVC	=	0x0c
000d =                       DFTK_RESVD	=	0x0d
000e =                       DFTK_RESVE	=	0x0e
000f =                       DFTK_RESVF	=	0x0f
                             
                             ;* String constant, variable and procedure tokens
0010 =                       DFTK_STRLIT	=	0x10
0011 =                       DFTK_VAR	=	0x11
0012 =                       DFTK_PROC	=	0x12
001f =                       DFTK_STEND	=	0x1f
                             
                             ;* Qualifier for non-local parameters passed to a
0026 =                       DFTK_VARPARM=	'&'
                             
                             ;* Variable Value Table (VVT) definitions
                             ;* The VVT records the values of variables define
                             ;* the Variable Name Table (VNT).  When a variabl
                             ;* used, it is added to the VNT, and the position
                             ;* VNT is used as an index in to the VVT.
                             ;* Every VVT entry is 8 bytes - so the VNT index 
                             ;* shifted left 3 bits to get the VVT offset.
                             ;* The VNT grows from top of memory down, the VVT
                             ;* grows from start of VNT down.
                             
                             ;* Index in to each entry of the VVT
0000 =                       DFVVT_TYPE	=	0x00
0001 =                       DFVVT_LO	=	0x01
0002 =                       DFVVT_HI	=	0x02
0003 =                       DFVVT_DIM1	=	0x03
0004 =                       DFVVT_DIM2	=	0x04
0008 =                       DFVVT_SZ	=	0x08	;VVT is aligned to 8 byte blocks
                             
                             ;* The meaning of the DFVVT_TYPE entry
0001 =                       DFVVT_INT	=	0x01
0002 =                       DFVVT_BYT	=	0x02
0004 =                       DFVVT_STR	=	0x04
0008 =                       DFVVT_FLT	=	0x08
0040 =                       DFVVT_PROC	=	0x40
0080 =                       DFVVT_ARRY	=	0x80
                             
                             ;* Flags indicating the meaning of a token
                             ;* A token has the top bit set (0x80), then the
                             ;* remaining bits indicate what it represents.
0001 =                       DFTK_KW		=	0x01
0002 =                       DFTK_FN		=	0x02
0004 =                       DFTK_STROP	=	0x04
0008 =                       DFTK_OP		=	0x08
0010 =                       DFTK_INT	=	0x10
0020 =                       DFTK_BYT	=	0x20
0040 =                       DFTK_STR	=	0x40
0080 =                       DFTK_FLT	=	0x80
0007 =                       DFTK_OPMSK	=	0x07
00f8 =                       DFTK_RTMSK	= 	0xf8
                             
                             ;* Defines what type of value is on the parameter
                             ;* All numerics are stored as INT, all STR
                             ;* are pointers to the actual string, thus
                             ;* all entries in the parmeter stack are 3 bytes
0001 =                       DFST_INT	=	0x01
AS65 Assembler for R6502 [1.42].                                     Page   11
-------------------------------- bank\bank2.s --------------------------------

0080 =                       DFST_STR	=	0x80
                             
                             ;* Token values of specific commands, used during
                             ;* command processing.
                             ;* ANY CHANGE TO THE ORDER OF KEYWORDS NEEDS TO R
0086 =                       DFRT_DEF	=	0x86
0087 =                       DFRT_ENDDEF	=	0x87
0088 =                       DFRT_RETURN	=	0x88
0089 =                       DFRT_ABORT	=	0x89
008c =                       DFRT_REPEAT	=	0x8c
008e =                       DFRT_FOR	=	0x8e
008f =                       DFRT_NEXT	=	0x8f
0090 =                       DFRT_WHILE	=	0x90
0091 =                       DFRT_WEND	=	0x91
0092 =                       DFRT_IF		=	0x92
0093 =                       DFRT_ELSE	=	0x93
0094 =                       DFRT_ENDIF	=	0x94
0095 =                       DFRT_ELSEIF	=	0x95
0096 =                       DFRT_DATA	=	0x96
0097 =                       DFRT_ASM	=	0x97
                             
                             _PushTrueJmp macro
                             	ldx #0xff
                             	txa
                             	jmp df_st_pushInt
                             	endm
                             
                             _PushFalseJmp macro
                             	ldx #0x00
                             	txa
                             	jmp df_st_pushInt
                             	endm
                             
                             	include "kernel\zeropage.i"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  ZEROPAGE.I
                             ;*  This module name is misleading it is not only
                             ;*  allocations, but also page 2, 3, 4, 5, 6, 7 a
                             ;*  Basically, this module defines:
                             ;*  - All zero page variables for system and dfla
                             ;*  - Page 1 is stack so no need to worry about t
                             ;*  - Page 2 is the serial IO buffer for the 6551
                             ;*  - Page 3 and 4 is a 512 buffer for SD card se
                             ;*  - Page 5 onwards is mainly for dflat working 
                             ;*    but also non-zero page storage for general 
                             ;*    system and scratch usage.
                             ;*  memstart is a handy label that indicates the 
                             ;*  location that we can store dflat programs fro
                             ;*  Zero page is a valuable asset as the 6502 can
                             ;*  this page one cycle quicker than the rest of 
                             ;*  and infact some addressing modes can only use
                             ;*  Due to the value of zero page, a lot of syste
                             ;*  dflat variables are put here.  But we don't h
                             ;*  luxury for single use variables - so you will
                             ;*  see a lot of temporary sounding names which a
AS65 Assembler for R6502 [1.42].                                     Page   12
-------------------------------- bank\bank2.s --------------------------------

                             ;*  have multiple used across the code base.
                             ;*
                             ;************************************************
                             
                             	; Zero page declarations
                             	bss
0000 =                       	org 0x0000
                             
0000 =                       tmp_bank1	ds	1		; Temp storage ONLY FOR USE BY BA
0001 =                       tmp_bank2	ds	1		; Temp storage ONLY FOR USE BY BA
                             
                             ; Interrupt routine addresses
0002 =                       int_irq		 ds	2		; Master IRQ handler
0004 =                       int_brk		 ds	2		; Master BRK handler
0006 =                       int_uservdp	 ds	2		; Where to jump for VDP interr
0008 =                       int_usercia0 ds	2		; Where to jump for CIA0 inter
000a =                       int_usercia1 ds	2		; Where to jump for CIA1 inter
                             
                             ; VDP parameters
000c =                       vdp_cnt		ds	1		; VDP interrupt counter
000d =                       vdp_cnt_hi 	ds	1		; VDP counter high
000e =                       vdp_cnt_hi2	ds	1		; VDP counter high 2
000f =                       vdp_curoff	ds	1		; Cursor off (0 = On)
0010 =                       vdp_curstat	ds	1		; Cursor status
0011 =                       vdp_curval	ds	1		; Cursor value on screen
0012 =                       vdp_blank	ds	1		; Screen blank value normally 32
0013 =                       vdp_delay	ds	1		; Delay counter for VRAM access
                             
                             ; vdp settings
0014 =                       vdp_base	ds	vdp_addr_struct
                             
                             ; Screen geometry
001f =                       gr_scrngeom	ds	gr_screen
                             
                             ;Keyboard parameters
002f =                       kb_raw  	ds	1		; Raw keyboard code
0030 =                       kb_last		ds	1		; Raw code of last key
0031 =                       kb_code 	ds	1		; Converted keyboard code
0032 =                       kb_stat		ds	1		; Keyboard status for caps and shi
0033 =                       kb_deb		ds	1		; VB periods since last KB spike
0034 =                       kb_rep		ds	1		; Keyboard repeat timer
0035 =                       kb_rep_tim 	ds	1		; Default repeat speed
0036 =                       kb_rep_del 	ds	1		; Default repeat delay timing
0037 =                       kb_debounce ds	1		; Default repeat debounce
0038 =                       kb_pressed	ds	1		; Set by the interrupt handler i
                             
0039 =                       tmp_alo 	ds	1		; VDP addresses lo
003a =                       tmp_ahi 	ds	1		; VDP addresses hi
003b =                       tmp_blo 	ds	1		; Temp address lo
003c =                       tmp_bhi		ds	1		; Temp address hi
003d =                       tmp_clo		ds	1		; Temp address lo
003e =                       tmp_chi		ds	1		; Temp address hi
003f =                       tmp_a		ds	1		; Temp storage a
                             
                             ; Raw input/output parameters
0040 =                       buf_lo		ds	1		; Line buffer address low
0041 =                       buf_hi		ds	1		; Line buffer address high
0042 =                       buf_sz		ds	1		; Buffer size
0043 =                       buf_ef		ds	1		; End file / line marker
                             
                             ; SD card driver parameters
0044 =                       sd_slo		ds	1		; Sector pointer low
AS65 Assembler for R6502 [1.42].                                     Page   13
-------------------------------- bank\bank2.s --------------------------------

0045 =                       sd_shi		ds	1		; Sector pointer high
0046 =                       sd_sect		ds	4		; SD Card sector address
004a =                       sd_addr		ds	4		; SD Card byte address
                             
                             ; File system parameters
004e =                       fs_bootsect	ds	4		; Start of partition (usually 0
0052 =                       fs_fatsect	ds	4		; Start of FAT tables
0056 =                       fs_rootsect	ds	4		; Start of Root Directory
005a =                       fs_datasect	ds	4		; Start of Data Area
005e =                       fs_dirsect	ds	4		; Current directory
0062 =                       fh_temp		ds	4		; File handling temporary storage
0066 =                       fh_handle	ds	FileHandle ; File handle parameters
                             
                             
                             ; ** Integer function storage **
008e =                       ztmp_16					; Start of 16 byte scratch area (all 
008e =                       num_a		ds	4		; 4 byte primary accumulator
0092 =                       num_b		ds	4		; 4 byte secondary accumulator
0096 =                       num_x		ds	4		; 4 byte x register
009a =                       num_tmp		ds	4		; 4 byte temp space
009e =                       num_buf		ds	8		; 8 byte string buffer
                             
                             ;
                             ; **** INTERPRETER ZERO PAGE ****
                             ;
00a6 =                       errno		ds	1		; General error condition status
00a7 =                       df_immed	ds	1		; Immediate mode (0 = not immediat
00a8 =                       df_sp		ds	1		; Stack pointer after error to resto
00a9 =                       df_pc		ds	2		; PC after error to return to
00ab =                       df_brkpc	ds	2		; PC pushed on the stack for BRK
00ad =                       df_brkval	ds	1		; Byte after BRK instruction
00ae =                       df_prgstrt	ds	2		; Start of program code
00b0 =                       df_prgend	ds	2		; End of program code
00b2 =                       df_vntstrt	ds	2		; Variable name table start
00b4 =                       df_vntend	ds	2		; Variable name table end
00b6 =                       df_vvtstrt	ds	2		; Variable value table start
00b8 =                       df_vvtend	ds	2		; Variable value table end
00ba =                       df_varcnt	ds	1		; Variable counter
00bb =                       df_starstrt	ds	2		; String and array table start
00bd =                       df_starend	ds	2		; String and array table end
00bf =                       df_rtstop	ds	1		; Runtime stack pointer
00c0 =                       df_parmtop	ds	1		; Top of parameter stack (grows 
00c1 =                       df_strbuff	ds	1		; String expression buffer
00c2 =                       df_stridx	ds	1		; Top of string buffer (grows dow
00c3 =                       df_sevalptr	ds	2		; Pointer to next free char in 
                             
00c5 =                       df_linoff	ds	1		; Offset in to line buffer
00c6 =                       df_tokoff	ds	1		; Offset in to tokenised buffer
00c7 =                       df_eolidx	ds	1		; End of line index (i.e length)
00c8 =                       df_nxtstidx	ds	1		; Offset to the next statement 
00c9 =                       df_curstidx	ds	1		; Offset to the start of curren
00ca =                       df_symtab	ds	2		; Pointer to next free symtab ent
00cc =                       df_symoff	ds	1		; Offset in to token table
00cd =                       df_symini	ds	2		; Start of symtab
00cf =                       df_currlin	ds	2		; Execution current line pointer
00d1 =                       df_exeoff	ds	1		; Execution line buffer offset
00d2 =                       df_nextlin	ds	2		; Next line to execute
00d4 =                       df_tmpptra	ds	2		; Temp pointer a
00d6 =                       df_tmpptrb	ds	2		; Temp pointer b
00d8 =                       df_tmpptrc	ds	2		; Temp pointer c
00da =                       df_tmpptrd	ds	2		; Temp pointer d
00dc =                       df_tmpptre	ds	2		; Temp pointer e
AS65 Assembler for R6502 [1.42].                                     Page   14
-------------------------------- bank\bank2.s --------------------------------

00de =                       df_procmode	ds	1		; Only used during tokenisation
00df =                       df_procargs	ds	1		; Only used during tokenisation
00e0 =                       df_procloc	ds	1		; Counts the number of local par
00e1 =                       df_procptr	ds	2		; Pointer to proc vvt slot
00e3 =                       df_lineptr	ds	2		; Pointer to line during searche
00e5 =                       df_lineidx	ds	1		; Pointer to line index during s
00e6 =                       df_ifnest	ds	1		; Global nested if counter
00e7 =                       df_currdat	ds	2		; Data current line pointer
00e9 =                       df_datoff	ds	1		; Data line buffer offset
00ea =                       df_rnd		ds	2		; Random number seed
                             
00ec =                       df_asmpc	ds	2		; Assembler program counter
00ee =                       df_asmopt	ds	1		; Assembler current option
00ef =                       df_asmadmd	ds	1		; Addressing mode
00f0 =                       df_asmopcde	ds	1		; Current opcode
00f1 =                       df_asmoprnd	ds	2		; Current operand
00f3 =                       df_asmlen	ds	1		; Instruction length
                             
                             
                             
                             ;***** END OF ZERO PAGE *****
00f4 =                       _end_zero_page
                             
                             ;***** Page 1 is CPU stack ****
0100 =                       	org 0x0100
0100 =                       _cpu_stack
0100 =                       			ds	256		; All of page 1
                             
                             ;***** Page 2 and 3 is SD card buffer
0200 =                       	org 0x0200			; SD Card data buffer 512 bytes
0200 =                       sd_buf		ds	512
                             
                             ;***** Page 4,5,6,7 is IO space
0400 =                       	org 0x0400
0400 =                       			ds	1024	; 1 k area divided in to 8x128 byte de
                             
                             
                             ;***** Page 8 is serial buffer *****
0800 =                       	org 0x0800
0800 =                       ser_buf		ds	256		; Serial input / output line buf
                             
0900 =                       	org 0x0900			; Page 9 = dflat space
0900 =                       df_linbuff
0900 =                       df_raw		ds	128		; untokenised input line
0980 =                       df_tokbuff
0980 =                       df_tok		ds 	128		; tokenised output line
                             
0a00 =                       	org 0x0a00			; Page 10 = fixed space for runtime
0a00 =                       df_rtstck
0a00 =                       df_rtspace	ds	256
                             
0b00 =                       	org 0x0b00			; Page 11 = 1/2 page fixed space fo
0b00 =                       df_opstck
0b00 =                       df_opspace	ds	128
                             
                             ;***** NON-ZERO PAGE VARIABLES *****
                             
                             ; Acticve IO device settings
0b80 =                       io_default	ds	1		; The default device number
0b81 =                       io_block	ds	io_struct
                             
                             ; File entry current dir entry
AS65 Assembler for R6502 [1.42].                                     Page   15
-------------------------------- bank\bank2.s --------------------------------

0b91 =                       fh_dir		ds	FileHandle
                             
                             ; Dflat top of memory+1 - normally initialised to
0bb9 =                       df_memtop	ds	2
                             
                             ; Scratch area e.g. string and numeric expression
0bbb =                       scratch		ds	256
                             
                             ;***** THIS IS THE START OF FREE SPACE for DFLAT 
0cbb =                       mem_start
                             
                             
                             	include "dflat\dflat.i"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  DFLAT.I
                             ;*  This is the main definitions file for dflat. 
                             ;*  definitions are in here to access the data st
                             ;*  used by dflat.
                             ;*
                             ;************************************************
                             
                             ;* Start dflat program memory
0cbb =                       DF_PROGSTART=	mem_start
                             ;* This is the top of usable dflat memory plus 1
c000 =                       DF_MEMTOP	=	0xc000
                             
                             ;* Offset in to tokenised line of length and line
0000 =                       DFTK_LINLEN	=	0x00
0001 =                       DFTK_LINNUM	=	0x01
                             
                             ;* Flags for token, escape value for data types a
0080 =                       DFTK_TOKEN	=	0x80
0020 =                       DFTK_ESCVAL	=	0x20
0000 =                       DFTK_EOL	=	0x00
                             
                             ;* Numeric constants are encoded based on size an
                             ;* user representation.
                             ;* For example the decimal value 16 will be encod
                             ;* DFTK_INTDEC followed by the bytes 0 and 16 to 
                             ;* The same value in binary will be encoded as DF
                             ;* followed by the same 0 and 16 bytes.  This is 
                             ;* tokenised value to be displayed in original re
                             ;* So in the two examples, they will be shown as 
                             ;* '0x0010' respectively.
0000 =                       DFTK_CHR	=	0x00
0001 =                       DFTK_RESV1	=	0x01
0002 =                       DFTK_RESV2	=	0x02
0003 =                       DFTK_RESV3	=	0x03
0004 =                       DFTK_RESV4	=	0x04
0005 =                       DFTK_BYTDEC	=	0x05
0006 =                       DFTK_BYTHEX = 	0x06
0007 =                       DFTK_BYTBIN =	0x07
0008 =                       DFTK_RESV8	=	0x08
0009 =                       DFTK_INTDEC	=	0x09
000a =                       DFTK_INTHEX =	0x0a
AS65 Assembler for R6502 [1.42].                                     Page   16
-------------------------------- bank\bank2.s --------------------------------

000b =                       DFTK_INTBIN	=	0x0b
000c =                       DFTK_RESVC	=	0x0c
000d =                       DFTK_RESVD	=	0x0d
000e =                       DFTK_RESVE	=	0x0e
000f =                       DFTK_RESVF	=	0x0f
                             
                             ;* String constant, variable and procedure tokens
0010 =                       DFTK_STRLIT	=	0x10
0011 =                       DFTK_VAR	=	0x11
0012 =                       DFTK_PROC	=	0x12
001f =                       DFTK_STEND	=	0x1f
                             
                             ;* Qualifier for non-local parameters passed to a
0026 =                       DFTK_VARPARM=	'&'
                             
                             ;* Variable Value Table (VVT) definitions
                             ;* The VVT records the values of variables define
                             ;* the Variable Name Table (VNT).  When a variabl
                             ;* used, it is added to the VNT, and the position
                             ;* VNT is used as an index in to the VVT.
                             ;* Every VVT entry is 8 bytes - so the VNT index 
                             ;* shifted left 3 bits to get the VVT offset.
                             ;* The VNT grows from top of memory down, the VVT
                             ;* grows from start of VNT down.
                             
                             ;* Index in to each entry of the VVT
0000 =                       DFVVT_TYPE	=	0x00
0001 =                       DFVVT_LO	=	0x01
0002 =                       DFVVT_HI	=	0x02
0003 =                       DFVVT_DIM1	=	0x03
0004 =                       DFVVT_DIM2	=	0x04
0008 =                       DFVVT_SZ	=	0x08	;VVT is aligned to 8 byte blocks
                             
                             ;* The meaning of the DFVVT_TYPE entry
0001 =                       DFVVT_INT	=	0x01
0002 =                       DFVVT_BYT	=	0x02
0004 =                       DFVVT_STR	=	0x04
0008 =                       DFVVT_FLT	=	0x08
0040 =                       DFVVT_PROC	=	0x40
0080 =                       DFVVT_ARRY	=	0x80
                             
                             ;* Flags indicating the meaning of a token
                             ;* A token has the top bit set (0x80), then the
                             ;* remaining bits indicate what it represents.
0001 =                       DFTK_KW		=	0x01
0002 =                       DFTK_FN		=	0x02
0004 =                       DFTK_STROP	=	0x04
0008 =                       DFTK_OP		=	0x08
0010 =                       DFTK_INT	=	0x10
0020 =                       DFTK_BYT	=	0x20
0040 =                       DFTK_STR	=	0x40
0080 =                       DFTK_FLT	=	0x80
0007 =                       DFTK_OPMSK	=	0x07
00f8 =                       DFTK_RTMSK	= 	0xf8
                             
                             ;* Defines what type of value is on the parameter
                             ;* All numerics are stored as INT, all STR
                             ;* are pointers to the actual string, thus
                             ;* all entries in the parmeter stack are 3 bytes
0001 =                       DFST_INT	=	0x01
0080 =                       DFST_STR	=	0x80
                             
AS65 Assembler for R6502 [1.42].                                     Page   17
-------------------------------- bank\bank2.s --------------------------------

                             ;* Token values of specific commands, used during
                             ;* command processing.
                             ;* ANY CHANGE TO THE ORDER OF KEYWORDS NEEDS TO R
0086 =                       DFRT_DEF	=	0x86
0087 =                       DFRT_ENDDEF	=	0x87
0088 =                       DFRT_RETURN	=	0x88
0089 =                       DFRT_ABORT	=	0x89
008c =                       DFRT_REPEAT	=	0x8c
008e =                       DFRT_FOR	=	0x8e
008f =                       DFRT_NEXT	=	0x8f
0090 =                       DFRT_WHILE	=	0x90
0091 =                       DFRT_WEND	=	0x91
0092 =                       DFRT_IF		=	0x92
0093 =                       DFRT_ELSE	=	0x93
0094 =                       DFRT_ENDIF	=	0x94
0095 =                       DFRT_ELSEIF	=	0x95
0096 =                       DFRT_DATA	=	0x96
0097 =                       DFRT_ASM	=	0x97
                             
                             _PushTrueJmp macro
                             	ldx #0xff
                             	txa
                             	jmp df_st_pushInt
                             	endm
                             
                             _PushFalseJmp macro
                             	ldx #0x00
                             	txa
                             	jmp df_st_pushInt
                             	endm
                             
                             	include "dflat\error.i"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  ERROR.I
                             ;*  Error definitions file.
                             ;*  The macro to throw an error is elswhere, but 
                             ;*  it issues a 6502 BRK commmand with the next b
                             ;*  the error code.  The BRK handler then picks u
                             ;*  code and shows the appropriate message plus a
                             ;*  number if a program was running.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
                             ; Error message numbers
0000 =                       DFERR_OK		=	0
0001 =                       DFERR_ERROR		=	1
0002 =                       DFERR_SYNTAX	=	2
0003 =                       DFERR_RUNTIME	=	3
0004 =                       DFERR_TYPEMISM	=	4
0005 =                       DFERR_DIM		=	5
0006 =                       DFERR_UNTIL		=	6
0007 =                       DFERR_NOPROC	=	7
AS65 Assembler for R6502 [1.42].                                     Page   18
-------------------------------- bank\bank2.s --------------------------------

0008 =                       DFERR_PROCPARM	=	8
0009 =                       DFERR_IMMEDIATE	=	9
000a =                       DFERR_UNCLOSEDIF=	10
000b =                       DFERR_NOIF		=	11
000c =                       DFERR_NEXTFOR	=	12
000d =                       DFERR_FNAME		=	13
000e =                       DFERR_STRLONG	=	14
000f =                       DFERR_BREAK		=	15
0010 =                       DFERR_NODATA	=	16
0011 =                       DFERR_WEND		=	17
0012 =                       DFERR_NOLINE	=	18
0013 =                       DFERR_RETURN	=	19
0014 =                       DFERR_ABORT		=	20
0015 =                       DFERR_QUANTITY	=	21
0016 =                       DFERR_NOORG		=	22
0017 =                       DFERR_ADDRMODE	=	23
                             
                             
                             
                             	include "bank\bank.i"
c000 =                       bankjsr_nul_addr	=	0xc000
0000 =                       bankjsr_nul_bank	=	0x00
003f =                       ROM_ZMASK			=	0x3f
00cf =                       RAM_ZMASK			=	0xcf
                             
                             _bankjsr	macro	addr,bank
                             	; Save A
                             	sta tmp_bank1
                             	
                             	; Save current bank
                             	lda bank_num
                             	pha
                             	
                             	; Switch to new bank
                             	lda IO_0+PRB
                             	and #ROM_ZMASK
                             	ora #(bank^3) << 6			; Shift left 6 bits
                             	sta IO_0+PRB
                             
                             	; Restore A
                             	lda tmp_bank1
                             	; JSR to the routine
                             	jsr addr
                             	
                             	jmp _restore_bank
                             	; 62 clock cycles inc restore vs 6 for a near js
                             
                             	endm
                             	
                             _bankram macro bank
                             	pha
                             	lda IO_0+PRB
                             	and #RAM_ZMASK
                             	ora #bank << 4
                             	sta IO_0+PRB
                             	pla
                             	endm
                             	
                             _bankram_fast macro bank
                             	lda IO_0+PRB
                             	and #RAM_ZMASK
                             	ora #bank << 4
AS65 Assembler for R6502 [1.42].                                     Page   19
-------------------------------- bank\bank2.s --------------------------------

                             	sta IO_0+PRB
                             	endm
                             	
                             
                             
                             
                             ;****************************************
                             ;*	Set 6502 default vectors	*
                             ;****************************************
                             	data				; Set vectors
fffa =                       	org 0xfffa			; Vectors lie at addresses
fffa : f7c9                  	fcw nmi				; 0xfffa : NMI Vector
fffc : 98c9                  	fcw init			; 0xfffc : Reset Vector
fffe : 20c6                  	fcw call_irq_master	; 0xfffe : IRQ Vector
                             	
                             	; ROM code
                             	code				;  
c000 =                       	org 0xc000			; Start of ROM
                             
                             	; The bank number is hardwired and aligned to PB
c000 :                       bank_num
                             	if BANK0
                             	  db 192
                             	endif
                             	if BANK1
                             	  db 128
                             	endif
                             	if BANK2
c000 : 40                    	  db 64
                             	endif
                             	if BANK3
                             	  db 0
                             	endif
                             
c001 :                       _code_start
                             	; Restore current bank always at address c001
c001 :                       _OSVectors
                             	include "kernel\osvec.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  OSVEC.S
                             ;*  Simply this is a bunch of JMP XXXX the order 
                             ;*  will always be maintained.  This is to allow 
                             ;*  code programs to be able to rely on fixed loc
                             ;*  some key low-level functions.
                             ;*  Only low level functions are needed, the idea
                             ;*  as the assembler is part of the BASIC, one ca
                             ;*  level slow stuff using BASIC then switch to M
                             ;*  speed up.
                             ;*  This code goes straight after the bank number
                             ;*  Each JMP is at 0xc001+3*(vector #)
                             ;*
                             ;************************************************
                             
c001 : 4c49c4           [ 3] 	jmp	io_put_ch			; Vec 0
c004 : 4c46c4           [ 3] 	jmp io_get_ch			; Vec 1
AS65 Assembler for R6502 [1.42].                                     Page   20
-------------------------------- bank\bank2.s --------------------------------

c007 : 4cd6c4           [ 3] 	jmp vdp_wr_reg			; Vec 2
c00a : 4c0ec5           [ 3] 	jmp vdp_poke			; Vec 3
c00d : 4c1ac5           [ 3] 	jmp vdp_peek			; Vec 4
c010 : 4c7bc5           [ 3] 	jmp snd_get_joy0		; Vec 5
c013 : 4c23c5           [ 3] 	jmp snd_set				; Vec 6
c016 : 4ce3c4           [ 3] 	jmp vdp_wr_addr			; Vec 7
c019 : 4cfac4           [ 3] 	jmp	vdp_rd_addr			; Vec 8
c01c :                       _restore_bank
                             	; Save A
c01c : 8500             [ 3] 	sta tmp_bank1
                             	; Get old bank from stack
c01e : 68               [ 4] 	pla
c01f : 8501             [ 3] 	sta tmp_bank2
c021 : ad0004           [ 4] 	lda IO_0+PRB
c024 : 293f             [ 2] 	and #ROM_ZMASK
c026 : 0501             [ 3] 	ora tmp_bank2
c028 : 8d0004           [ 4] 	sta IO_0+PRB
                             	
                             	; Restore A
c02b : a500             [ 3] 	lda tmp_bank1
                             
c02d : 60               [ 6] 	rts
                             
                             	; include cross-bank functions (see extern.mak)
                             	include "bank\autogen.s"	
                             ; 
c02e :                       mod_sz_autogen_s 
c02e :                       _df_init 
                               _bankjsr $ef9a, 1 
                             
c046 :                       _df_pg_dflat 
                               _bankjsr $d677, 1 
                             
c05e :                       _fs_chdir 
                               _bankjsr $d1e3, 2 
                             
c076 :                       _fs_delete 
                               _bankjsr $d1a9, 2 
                             
c08e :                       _fs_close 
                               _bankjsr $d188, 2 
                             
c0a6 :                       _fs_get_next_byte 
                               _bankjsr $cf13, 2 
                             
c0be :                       _fs_open_read 
                               _bankjsr $d126, 2 
                             
c0d6 :                       _fs_open_write 
                               _bankjsr $d14f, 2 
                             
c0ee :                       _fs_put_byte 
                               _bankjsr $d044, 2 
                             
c106 :                       _get_byte 
                               _bankjsr $ca78, 0 
                             
c11e :                       _put_byte 
                               _bankjsr $ca88, 0 
                             
c136 :                       _gr_get_key 
                               _bankjsr $d996, 0 
AS65 Assembler for R6502 [1.42].                                     Page   21
-------------------------------- bank\bank2.s --------------------------------

                             
c14e :                       _gr_put_byte 
                               _bankjsr $d9a3, 0 
                             
c166 :                       _gr_init_screen 
                               _bankjsr $d455, 0 
                             
c17e :                       _init_acia 
                               _bankjsr $ca95, 0 
                             
c196 :                       _init_cia0 
                               _bankjsr $ca25, 0 
                             
c1ae :                       _init_cia1 
                               _bankjsr $ca56, 0 
                             
c1c6 :                       _init_fs 
                               _bankjsr $ccc3, 2 
                             
c1de :                       _init_sdcard 
                               _bankjsr $c9f8, 2 
                             
c1f6 :                       _init_snd 
                               _bankjsr $cc6c, 0 
                             
c20e :                       _init_keyboard 
                               _bankjsr $caa3, 0 
                             
c226 :                       _kb_read_raw 
                               _bankjsr $cab2, 0 
                             
c23e :                       _command_line 
                               _bankjsr $d23e, 2 
                             
c256 :                       _fs_dir_find_entry 
                               _bankjsr $cdc4, 2 
                             
c26e :                       _fs_dir_root_start 
                               _bankjsr $cdab, 2 
                             
c286 :                       _gr_cls 
                               _bankjsr $d45f, 0 
                             
c29e :                       _gr_init_hires 
                               _bankjsr $d412, 0 
                             
c2b6 :                       _gr_line 
                               _bankjsr $d7d0, 0 
                             
c2ce :                       _gr_box 
                               _bankjsr $d610, 0 
                             
c2e6 :                       _gr_circle 
                               _bankjsr $d71b, 0 
                             
c2fe :                       _gr_plot 
                               _bankjsr $d4ca, 0 
                             
c316 :                       _gr_hchar 
                               _bankjsr $d504, 0 
                             
c32e :                       _gr_point 
AS65 Assembler for R6502 [1.42].                                     Page   22
-------------------------------- bank\bank2.s --------------------------------

                               _bankjsr $d5c5, 0 
                             
c346 :                       _gr_get 
                               _bankjsr $d4e1, 0 
                             
c35e :                       _gr_set_cur 
                               _bankjsr $d4e9, 0 
                             
c376 :                       _snd_get_note 
                               _bankjsr $cc65, 0 
                             
c38e :                       _snd_get_joy0 
                               _bankjsr $c57b, 0 
                             
c3a6 :                       _snd_set 
                               _bankjsr $c523, 0 
                             
c3be :                       _vdp_peek 
                               _bankjsr $c51a, 0 
                             
c3d6 :                       _vdp_poke 
                               _bankjsr $c50e, 0 
                             
c3ee :                       _vdp_init 
                               _bankjsr $d200, 0 
                             
c406 :                       mod_sz_autogen_e 
                             
                             	
c406 :                       mod_sz_kernel_s
                             
                             ;* Include all common code in the right order
                             	include "io\io.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  IO.S
                             ;*  General IO module.  Allows different IO devic
                             ;*  utilised transparently by the rest of the cod
                             ;*  Other code should use "io_" commands so that 
                             ;*  do not need to know what specific device is p
                             ;*  input and output capabilities.  On startup, t
                             ;*  examines the BBC DIP switch to decide whether
                             ;*  initialise the IO to serial through the ACIA 
                             ;*  the BBC keyboard for input with the VDP for o
                             ;*  Loading and saving files from the SD card is 
                             ;*  achieved by pointing to SD card get and put b
                             ;*  routines.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             
c406 :                       mod_sz_io_s
                             
                             ;****************************************
AS65 Assembler for R6502 [1.42].                                     Page   23
-------------------------------- bank\bank2.s --------------------------------

                             ;* io_init
                             ;* Initialise the default device and make active
                             ;* No keys pressed = serial (default)
                             ;* F0 pressed = KB/VDP
                             ;* F1 pressed = Serial
                             ;* Keyboard and screen or serial port
                             ;* Output : None
                             ;* Regs affected : P, A
                             ;****************************************
c406 :                       io_init
c406 : 2026c2           [ 6] 	jsr _kb_read_raw	; Check pressed key
c409 : a900             [ 2] 	lda #0				; Default = Serial
c40b : e080             [ 2] 	cpx #0x80			; f0 key pressed?
c40d : d004             [ 3] 	bne io_init_skip_f0
c40f : a901             [ 2] 	lda #1				; Default = KB/VDP
c411 : 8006             [ 3] 	bra io_init_done
c413 :                       io_init_skip_f0
c413 : e081             [ 2] 	cpx #0x81			; f1 key pressed?
c415 : d002             [ 3] 	bne io_init_done
c417 : a900             [ 2] 	lda #0				; f1 pressed = serial
c419 :                       io_init_done
c419 : 8d800b           [ 4] 	sta io_default
c41c : 4c22c4           [ 3] 	jmp io_active_device; Activate the device
                             
                             
                             ;****************************************
                             ;* io_set_default, io_active_device
                             ;* Activate device based on default or A
                             ;* Input : A = Device number
                             ;* Output : None
                             ;* Regs affected : P, A
                             ;****************************************
c41f :                       io_set_default			; Entry point for default
c41f : ad800b           [ 4] 	lda io_default
c422 :                       io_active_device		; Entry point for A set
c422 : 0a               [ 2] 	asl	a				; x16 the Block number
c423 : 0a               [ 2] 	asl a
c424 : 0a               [ 2] 	asl a
c425 : 0a               [ 2] 	asl a
c426 : a8               [ 2] 	tay
c427 : a200             [ 2] 	ldx #0
                             	; Copy device settings to io block
c429 :                       io_copy_data
c429 : b9a6c4           [ 4] 	lda io_devices,y
c42c : 9d810b           [ 5] 	sta io_block,x
c42f : c8               [ 2] 	iny
c430 : e8               [ 2] 	inx
c431 : e010             [ 2] 	cpx #16
c433 : d0f4             [ 3] 	bne io_copy_data
                             	
c435 : a900             [ 2] 	lda #lo(ser_buf)	; Initialise buffer and size
c437 : 8540             [ 3] 	sta buf_lo
c439 : a908             [ 2] 	lda #hi(ser_buf)
c43b : 8541             [ 3] 	sta buf_hi
c43d : a9ff             [ 2] 	lda #255
c43f : 8542             [ 3] 	sta buf_sz
c441 : a90d             [ 2] 	lda #UTF_CR		; Line terminator is CR
c443 : 8543             [ 3] 	sta buf_ef
c445 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* io_get_ch
AS65 Assembler for R6502 [1.42].                                     Page   24
-------------------------------- bank\bank2.s --------------------------------

                             ;* Get a char (wait forever or just check)
                             ;* Input : C = 1 for synchronous, 0 for async
                             ;* Output : A = Byte code, C = 0 means A is inval
                             ;* Regs affected : P, A
                             ;****************************************
c446 :                       io_get_ch
c446 : 6c810b           [ 6] 	jmp (io_block+io_get_byte)
                             	
                             
                             ;****************************************
                             ;* io_put_ch
                             ;* Put a char
                             ;* Input : A = char
                             ;* Regs affected : P, A
                             ;****************************************
c449 :                       io_put_ch
c449 : 6c830b           [ 6] 	jmp (io_block+io_put_byte)
                             	
                             ;****************************************
                             ;* io_open_read
                             ;* Open for reading
                             ;* Input : X,A = pointer to filename (zero termin
                             ;* Output : C=0 success
                             ;* Regs affected : All
                             ;****************************************
c44c :                       io_open_read
c44c : 6c850b           [ 6] 	jmp (io_block+io_open_r)
                             	
                             ;****************************************
                             ;* io_open_write
                             ;* Open for reading
                             ;* Input : X,A = pointer to filename (zero termin
                             ;* Output : C=0 success
                             ;* Regs affected : All
                             ;****************************************
c44f :                       io_open_write
c44f : 6c870b           [ 6] 	jmp (io_block+io_open_w)
                             
                             ;****************************************
                             ;* io_close
                             ;* Close a file
                             ;* Input : 
                             ;* Output : C=0 success
                             ;* Regs affected : All
                             ;****************************************
c452 :                       io_close
c452 : 6c890b           [ 6] 	jmp (io_block+io_close_f)
                             	
                             ;****************************************
                             ;* io_delete
                             ;* Delete a file
                             ;* Input : 
                             ;* Output : C=0 success
                             ;* Regs affected : All
                             ;****************************************
c455 :                       io_delete
c455 : 6c8b0b           [ 6] 	jmp (io_block+io_del_f)
                             	
                             ;****************************************
                             ;* io_read_line
                             ;* Read a line, terminated by terminating char or
                             ;* Input : buf_(lo/hi/sz/ef) : Address, Max size,
AS65 Assembler for R6502 [1.42].                                     Page   25
-------------------------------- bank\bank2.s --------------------------------

                             ;* Output : Y = Line length C = Buffer limit reac
                             ;* Regs affected : None
                             ;****************************************
c458 :                       io_read_line
c458 : 48               [ 3] 	pha
                             
c459 : 08               [ 3] 	php					; Save echo state
                             	
c45a : a000             [ 2] 	ldy #0x00			; Starting at first byte
c45c :                       io_get_line_byte
c45c : 38               [ 2] 	sec					; Getting bytes synchronously
c45d : 2046c4           [ 6] 	jsr io_get_ch		; Get a byte
c460 : b027             [ 3] 	bcs io_get_line_done; Got nothing then finish
c462 : 28               [ 4] 	plp					; Get echo state
c463 : 08               [ 3] 	php					; Instantly save it back
c464 : 900c             [ 3] 	bcc io_skip_echo	; Carry not set = don't echo
c466 : c97f             [ 2] 	cmp #UTF_DEL		; Delete?
c468 : d005             [ 3] 	bne io_do_echo
c46a : c000             [ 2] 	cpy #0				; Already at beginning?
c46c : f004             [ 3] 	beq io_skip_echo	; Don't echo delete
c46e : 88               [ 2] 	dey					; Else decrement length
c46f :                       io_do_echo
c46f : 2049c4           [ 6] 	jsr io_put_ch		; Echo it
c472 :                       io_skip_echo
c472 : c920             [ 2] 	cmp #UTF_SPECIAL	; Special character?
c474 : 9007             [ 3] 	bcc io_skip_special	; Skip if so (don't add to b
c476 : c97f             [ 2] 	cmp #UTF_DEL		; Don't proces DEL either
c478 : f003             [ 3] 	beq io_skip_special
c47a : 9140             [ 5] 	sta (buf_lo),y		; Save it
c47c : c8               [ 2] 	iny					; Increase length
c47d :                       io_skip_special
c47d : c543             [ 3] 	cmp buf_ef			; Is it the terminating char?
c47f : f008             [ 3] 	beq io_get_line_done	; If yes then done
c481 : c442             [ 3] 	cpy buf_sz			; Reached the buffer max size?
c483 : d0d7             [ 3] 	bne io_get_line_byte	; No, get another byte
c485 : 28               [ 4] 	plp					; Remember to pull echo state off stack
c486 : 38               [ 2] 	sec					; Yes, set carry flag
c487 : 68               [ 4] 	pla
c488 : 60               [ 6] 	rts					; And done
c489 :                       io_get_line_done
c489 : a900             [ 2] 	lda #0
c48b : 9140             [ 5] 	sta (buf_lo),y		; Terminate with 0
c48d : 28               [ 4] 	plp					; Remember to pull echo state off stack
c48e : 18               [ 2] 	clc					; Clear carry flag
c48f : 68               [ 4] 	pla
c490 : 60               [ 6] 	rts					; Fin
                             
                             ;****************************************
                             ;* io_print_line
                             ;* Print a line (when data is not already in seri
                             ;* Input : X = Address Lo, A = Address Hi
                             ;* Output : Y=number chars output
                             ;* Regs affected : All
                             ;****************************************
c491 :                       io_print_line
c491 : 48               [ 3] 	pha
                             
c492 : 863d             [ 3] 	stx tmp_clo					; Store the string pointer
c494 : 853e             [ 3] 	sta tmp_chi					; lo and hi
c496 : a000             [ 2] 	ldy #0						; Start at the beginning!
c498 :                       io_print_line_byte
c498 : b13d             [ 5] 	lda (tmp_clo),y				; Copy byte to
AS65 Assembler for R6502 [1.42].                                     Page   26
-------------------------------- bank\bank2.s --------------------------------

c49a : f006             [ 3] 	beq io_print_done			; If zero then done - print
c49c : 2049c4           [ 6] 	jsr io_put_ch				; Transmit
c49f : c8               [ 2] 	iny
c4a0 : d0f6             [ 3] 	bne io_print_line_byte		; Carry on until zero fo
c4a2 :                       io_print_done
c4a2 : 68               [ 4] 	pla
c4a3 : 60               [ 6] 	rts
                             
                             
                             ;*** Null operation just clc and return ***
c4a4 :                       io_null_op
c4a4 : 18               [ 2] 	clc
c4a5 : 60               [ 6] 	rts
                             	
                             ;* IO devices defined here
c4a6 :                       io_devices
                             ;* Device zero is the serial port
                             ;* only offers get and put
c4a6 :                       io_device0					; Serial device, input = Ser, outp
c4a6 : 06c1                  	dw	_get_byte			; io_get_ch
c4a8 : 1ec1                  	dw	_put_byte			; io_put_ch
c4aa : a4c4                  	dw	io_null_op			; io_open_r
c4ac : a4c4                  	dw	io_null_op			; io_open_w
c4ae : a4c4                  	dw	io_null_op			; io_close_f
c4b0 : a4c4                  	dw	io_null_op			; io_del_f
c4b2 : a4c4                  	dw	io_null_op			; io_ext1
c4b4 : a4c4                  	dw	io_null_op			; io_ext2
                             ;* Device one is keyboard / screen
                             ;* only offers get and put
c4b6 :                       io_device1					; Default device, input = screen e
c4b6 : 36c1                  	dw	_gr_get_key			; io_get_ch
c4b8 : 4ec1                  	dw	_gr_put_byte		; io_put_ch
c4ba : a4c4                  	dw	io_null_op			; io_open_r
c4bc : a4c4                  	dw	io_null_op			; io_open_w
c4be : a4c4                  	dw	io_null_op			; io_close_f
c4c0 : a4c4                  	dw	io_null_op			; io_del_f
c4c2 : a4c4                  	dw	io_null_op			; io_ext1
c4c4 : a4c4                  	dw	io_null_op			; io_ext2
                             ;* Device two is the file system on SD card
                             ;* Offers all IO functions
c4c6 :                       io_device2					; SD device, input = SD, output = 
c4c6 : a6c0                  	dw	_fs_get_next_byte	; io_get_ch
c4c8 : eec0                  	dw	_fs_put_byte		; io_put_ch
c4ca : bec0                  	dw	_fs_open_read		; io_open_r
c4cc : d6c0                  	dw	_fs_open_write		; io_open_w
c4ce : 8ec0                  	dw	_fs_close			; io_close_f
c4d0 : 76c0                  	dw	_fs_delete			; io_del_f
c4d2 : a4c4                  	dw	io_null_op			; io_ext1
c4d4 : a4c4                  	dw	io_null_op			; io_ext2
                             
c4d6 :                       mod_sz_io_e
                             
                             
                             	include "kernel\vdp-low.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
AS65 Assembler for R6502 [1.42].                                     Page   27
-------------------------------- bank\bank2.s --------------------------------

                             ;*  VDP-LOW.S
                             ;*  Low level VDP routines which will always be p
                             ;*  every ROM bank.  This is to ensure if IRQ nee
                             ;*  no slow bank switching is needed, but also to
                             ;*	OS vectored access to VDP routines for M/C fro
                             ;*
                             ;************************************************
                             
                             ;****************************************
                             ;* vdp_wr_reg
                             ;* Write to Register A the value X
                             ;* Input : A - Register Number, X - Data
                             ;* Output : None
                             ;* Regs affected : P
                             ;****************************************
c4d6 :                       vdp_wr_reg
c4d6 : 8e0105           [ 4] 	stx VDP_MODE1
                             ; Extra nop for fast CPU
c4d9 : ea               [ 2] 	nop
c4da : ea               [ 2] 	nop
c4db : 0980             [ 2] 	ora #0x80
c4dd : 8d0105           [ 4] 	sta VDP_MODE1
c4e0 : 4980             [ 2] 	eor #0x80
c4e2 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* vdp_wr_addr
                             ;* Write to address in X (low) and A (high) - for
                             ;* Input : A - Address high byte, X - Address low
                             ;* Output : None
                             ;* Regs affected : P
                             ;****************************************
c4e3 :                       vdp_wr_addr
c4e3 : 8e0105           [ 4] 	stx VDP_MODE1
                             ; Extra nop for fast CPU
c4e6 : ea               [ 2] 	nop
c4e7 : ea               [ 2] 	nop
c4e8 : 0940             [ 2] 	ora #0x40		; Required by VDP
c4ea : 8d0105           [ 4] 	sta VDP_MODE1
c4ed : 4940             [ 2] 	eor #0x40		; Undo that bit
c4ef : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* vdp_mem_wait
                             ;* Delay some time before a memory access,
                             ;* taking in to account mode 9918 needs up
                             ;* to 3.1uS for text mode, 8uS for graphics
                             ;* I and II
                             ;* @ 5.35Mhz	= 16 cycles for 3.1uS
                             ;*				= 43 cycles for 8uS
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
c4f0 :                       vdp_mem_wait
c4f0 : da               [ 3] 	phx								; 3
c4f1 : a613             [ 3] 	ldx vdp_delay					; 3
c4f3 : f003             [ 3] 	beq vdp_mem_wait_end			; 3
c4f5 :                       vdp_mem_wait_loop
c4f5 : ca               [ 2] 	dex								; 2
c4f6 : d0fd             [ 3] 	bne	vdp_mem_wait_loop			; 3
AS65 Assembler for R6502 [1.42].                                     Page   28
-------------------------------- bank\bank2.s --------------------------------

c4f8 :                       vdp_mem_wait_end
c4f8 : fa               [ 4] 	plx								; 3
c4f9 : 60               [ 6] 	rts								; 6
                             	
                             ;****************************************
                             ;* vdp_rd_addr
                             ;* Set read address 
                             ;* Input : A - high, X - low 
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
c4fa :                       vdp_rd_addr
c4fa : 8e0105           [ 4] 	stx VDP_MODE1
                             ; These nops are needed for fast CPU
c4fd : ea               [ 2] 	nop
c4fe : ea               [ 2] 	nop
c4ff : 8d0105           [ 4] 	sta VDP_MODE1
c502 : 80ec             [ 4] 	bra vdp_mem_wait
                             	
                             ;****************************************
                             ;* vdp_rd_vram
                             ;* Read VRAM byte, result in A
                             ;* Input : None
                             ;* Output : A - Byte from VRAM
                             ;* Regs affected : P
                             ;****************************************
c504 :                       vdp_rd_vram
c504 : ad0005           [ 4] 	lda VDP_VRAM
c507 : 80e7             [ 4] 	bra vdp_mem_wait
                             	
                             ;****************************************
                             ;* vdp_wr_vram
                             ;* Write VRAM byte in A
                             ;* Input : A - Byte to write
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
c509 :                       vdp_wr_vram
c509 : 8d0005           [ 4] 	sta VDP_VRAM
c50c : 80e2             [ 4] 	bra vdp_mem_wait
                             	
                             ;****************************************
                             ;* vdp_poke
                             ;* Write VRAM byte in A, (YX)
                             ;* Input : A - Byte to write
                             ;*		   X = Low Address
                             ;*		   Y = High Address
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
c50e :                       vdp_poke
c50e : 48               [ 3] 	pha
c50f : 98               [ 2] 	tya
c510 : 78               [ 2] 	sei
c511 : 20e3c4           [ 6] 	jsr vdp_wr_addr
c514 : 68               [ 4] 	pla
c515 : 2009c5           [ 6] 	jsr vdp_wr_vram
c518 : 58               [ 2] 	cli
c519 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* vdp_peek
AS65 Assembler for R6502 [1.42].                                     Page   29
-------------------------------- bank\bank2.s --------------------------------

                             ;* Get VRAM byte in (AX)
                             ;*		   X = Low Address
                             ;*		   A = High Address
                             ;* Output : A = byte read
                             ;* Regs affected : None
                             ;****************************************
c51a :                       vdp_peek
c51a : 78               [ 2] 	sei
c51b : 20fac4           [ 6] 	jsr vdp_rd_addr
c51e : 2004c5           [ 6] 	jsr vdp_rd_vram
c521 : 58               [ 2] 	cli
c522 : 60               [ 6] 	rts
                             
                             	include "kernel\snd-low.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  SND-LOW.S
                             ;*  Low level sound routines which will always be
                             ;*  in every ROM bank.  Mainly to provide fast OS
                             ;*	access to VDP routines for M/C from BASIC
                             ;*
                             ;************************************************
                             
                             ;****************************************
                             ;* snd_set
                             ;* Set AY register X to value Y
                             ;* Input : X = Reg no, Y = Value
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
c523 :                       snd_set
c523 : 48               [ 3] 	pha
                             
c524 : a9ff             [ 2] 	lda #0xff				; Set Port A to output
c526 : 8d8304           [ 4] 	sta IO_1 + DDRA
                             
c529 : 8e8104           [ 4] 	stx SND_ADBUS			; Put X on the sound bus (X = re
                             
c52c : ad8004           [ 4] 	lda SND_MODE			; Need to preserve contents of ot
c52f : 29bd             [ 2] 	and #SND_DESELECT_MASK	; Mask off mode bits
c531 : 0942             [ 2] 	ora #SND_SELSETADDR		; Select AY mode to latch a
c533 : 8d8004           [ 4] 	sta SND_MODE			; This write will process the dat
                             
c536 : 29bd             [ 2] 	and #SND_DESELECT_MASK	; Mask off mode bits
c538 : 8d8004           [ 4] 	sta SND_MODE			; This write will deselect the AY
                             	
c53b : 8c8104           [ 4] 	sty SND_ADBUS			; Put Y on the sound bus (Y = va
c53e : 0902             [ 2] 	ora #SND_SELWRITE		; Select mode for writing dat
c540 : 8d8004           [ 4] 	sta SND_MODE			; This write will process the dat
                             	
c543 : 29bd             [ 2] 	and #SND_DESELECT_MASK	; Mask off mode bits
c545 : 8d8004           [ 4] 	sta SND_MODE			; This write will deselect the AY
                             
c548 : 68               [ 4] 	pla
                             	
c549 : 60               [ 6] 	rts
AS65 Assembler for R6502 [1.42].                                     Page   30
-------------------------------- bank\bank2.s --------------------------------

                             
                             ;****************************************
                             ;* snd_get
                             ;* Get AY register X to Y
                             ;* Input : X = Reg no
                             ;* Output : Y = Value
                             ;* Regs affected : None
                             ;****************************************
c54a :                       snd_get
c54a : 48               [ 3] 	pha
                             
c54b : a9ff             [ 2] 	lda #0xff				; Set Port A to output
c54d : 8d8304           [ 4] 	sta IO_1 + DDRA
                             
c550 : 8e8104           [ 4] 	stx SND_ADBUS			; Put X on the sound bus (X = re
                             
c553 : ad8004           [ 4] 	lda SND_MODE			; Need to preserve contents of ot
c556 : 29bd             [ 2] 	and #SND_DESELECT_MASK	; Mask off mode bits
c558 : 0942             [ 2] 	ora #SND_SELSETADDR		; Select AY mode to latch a
c55a : 8d8004           [ 4] 	sta SND_MODE			; This write will process the dat
                             
c55d : 29bd             [ 2] 	and #SND_DESELECT_MASK	; Mask off mode bits
c55f : 8d8004           [ 4] 	sta SND_MODE			; This write will deselect the AY
                             
c562 : a900             [ 2] 	lda #0x00				; Set Port A to input
c564 : 8d8304           [ 4] 	sta IO_1 + DDRA
                             
c567 : ad8004           [ 4] 	lda SND_MODE			; Need to preserve contents of ot
c56a : 29bd             [ 2] 	and #SND_DESELECT_MASK	; Mask off mode bits
c56c : 0940             [ 2] 	ora #SND_SELREAD		; Select mode for reading data
c56e : 8d8004           [ 4] 	sta SND_MODE			; This write will process the dat
                             
c571 : ac8104           [ 4] 	ldy SND_ADBUS			; Get value in to Y
                             	
c574 : 29bd             [ 2] 	and #SND_DESELECT_MASK	; Mask off mode bits
c576 : 8d8004           [ 4] 	sta SND_MODE			; This write will deselect the AY
                             
c579 : 68               [ 4] 	pla
                             	
c57a : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* snd_get_joy0
                             ;* Return value of joystick 0
                             ;* Input : None
                             ;* Output : Y = Value
                             ;* Regs affected : X
                             ;****************************************
c57b :                       snd_get_joy0
c57b : a20f             [ 2] 	ldx #SND_REG_IOB		; Joystick is plugged in to IO
c57d : 204ac5           [ 6] 	jsr snd_get				; Get IOB, result in Y
c580 : 60               [ 6] 	rts
                             
                             	include "kernel\main.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
AS65 Assembler for R6502 [1.42].                                     Page   31
-------------------------------- bank\bank2.s --------------------------------

                             ;*  MAIN.S
                             ;*  This is where the main user program is execut
                             ;*  the 'kernel' once the system is initialised a
                             ;*  Today, main does very little - first shows th
                             ;*  boot up message, and then passes control to d
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
c581 :                       main
                             	_println msg_hello_world
                             
                             
c58e :                       infinity
c58e : 2046c0           [ 6] 	jsr _df_pg_dflat
c591 : 4c8ec5           [ 3] 	jmp infinity
                             
c594 :                       msg_hello_world
                             	;* build.s is generate by the assemble.bat file
                             	;* all it does is echo an assembler line to
                             	;* including the build date in the message.
                             	include "kernel\build.s"
c594 : 4275696c64203a..       db "Build : 25/10/2020\r" 
c5a7 : 424243202d2031..       db "BBC - 128K Breadboard Computer\r" 
c5c6 : 42792040363530..       db "By @6502Nerd (Dolo Miah)\r" 
c5df : 436f7079726967..       db "Copyright (c) 2015-20\r\r",0 
                             
                             
                             	include "kernel\irq.s"
                             	
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  IRQ.S
                             ;*	This is the IRQ handler - handles both the ver
                             ;*  blank interrupt from the VDP as well as softw
                             ;*  
                             ;*  As the handler has to be in every bank and it
                             ;*  accesses the VDP, then low level VDP routines
                             ;*  bundled in this file to ensure they are alway
                             ;*  without a bank switch being needed (which is 
                             ;************************************************
                             
                             ;* Obviously this can only be done with
                             ;* interrupts disabled!
c5f7 :                       init_irq
                             	; Core IRQ handler
c5f7 : a931             [ 2] 	lda #lo(irq)
c5f9 : 8502             [ 3] 	sta int_irq
c5fb : a9c6             [ 2] 	lda #hi(irq)
c5fd : 8503             [ 3] 	sta int_irq+1
                             	
                             	; Core BRK handler
c5ff : a95f             [ 2] 	lda #lo(irq_brk)
c601 : 8504             [ 3] 	sta int_brk
AS65 Assembler for R6502 [1.42].                                     Page   32
-------------------------------- bank\bank2.s --------------------------------

c603 : a9c6             [ 2] 	lda #hi(irq_brk)
c605 : 8505             [ 3] 	sta int_brk+1
                             
                             	; User handlers for VDP, PIA0, PIA1 interrupts
c607 : a930             [ 2] 	lda #lo(null_handler)
c609 : 8506             [ 3] 	sta int_uservdp
c60b : a9c6             [ 2] 	lda #hi(null_handler)
c60d : 8507             [ 3] 	sta int_uservdp+1
                             
c60f : a930             [ 2] 	lda #lo(null_handler)
c611 : 8508             [ 3] 	sta int_usercia0
c613 : a9c6             [ 2] 	lda #hi(null_handler)
c615 : 8509             [ 3] 	sta int_usercia0+1
                             
c617 : a930             [ 2] 	lda #lo(null_handler)
c619 : 850a             [ 3] 	sta int_usercia1
c61b : a9c6             [ 2] 	lda #hi(null_handler)
c61d : 850b             [ 3] 	sta int_usercia1+1
                             
c61f : 60               [ 6] 	rts
                             
                             ;* Calls the master IRQ handler
c620 :                       call_irq_master
c620 : 6c0200           [ 6] 	jmp (int_irq)
                             	
                             ;* Calls the BRK handler
c623 :                       call_irq_brk
c623 : 6c0400           [ 6] 	jmp (int_brk)
                             
                             ;* Call the userVDP handler
c626 :                       call_irq_uservdp
c626 : 6c0600           [ 6] 	jmp (int_uservdp)
                             	
                             ;* Call the user CIA0 handler
c629 :                       call_irq_usercia0
c629 : 6c0800           [ 6] 	jmp (int_usercia0)
                             
                             ;* Call the user CIA1 handler
c62c :                       call_irq_usercia1
c62c : 6c0a00           [ 6] 	jmp (int_usercia1)
                             	
                             ;* null interrupt
c62f :                       null_irq
c62f : 40               [ 6] 	rti
                             
                             ;* null handler
c630 :                       null_handler
c630 : 60               [ 6] 	rts
                             	
                             
                             ;* Master IRQ handler
c631 :                       irq
                             	_pushAXY
                             
                             
                             	; Check if IRQ or BRK
                             	; load P from stack in to A
c634 : ba               [ 2] 	tsx
c635 : bd0401           [ 4] 	lda 0x104,x
                             	; BRK bit set?
c638 : 2910             [ 2] 	and #0x10
c63a : d0e7             [ 3] 	bne call_irq_brk
AS65 Assembler for R6502 [1.42].                                     Page   33
-------------------------------- bank\bank2.s --------------------------------

                             	
c63c : 18               [ 2] 	clc						; Standard behaviour
                             	
                             	;* Try PIA1 first for rapid Timer handling
c63d : ad8d04           [ 4] 	lda IO_1 + IFR
c640 : 1003             [ 3] 	bpl irq_check_vdp
c642 : 202cc6           [ 6] 	jsr call_irq_usercia1	; Call user cia1 handler
                             
                             	;* Try VDP next
c645 :                       irq_check_vdp	
c645 : ad0105           [ 4] 	lda VDP_STATUS			; Read status register
c648 : 1009             [ 3] 	bpl	irq_check_cia0		; Skip if not VBLANK
c64a : 2026c6           [ 6] 	jsr call_irq_uservdp	; Call use VDP handler
c64d : 20acc6           [ 6] 	jsr int_vdp_handler		; Call  OS VDP handler
c650 : 208ac6           [ 6] 	jsr int_kb_handler		; Call OS cia0 handler (keyb
                             
                             	;* Try VIA0 last as it's keyboard (low speed)
c653 :                       irq_check_cia0
c653 : ad0d04           [ 4] 	lda IO_0 + IFR
c656 : 1003             [ 3] 	bpl irq_fin
c658 : 2029c6           [ 6] 	jsr call_irq_usercia0	; Call user cia0 handler
                             
c65b :                       irq_fin
                             	_pullAXY
                             
c65e : 40               [ 6] 	rti
                             	
                             ;* Handle BRK
c65f :                       irq_brk
                             	; Handle BRK
                             	; Get PCL,H minus 2 gives the BRK instruction ad
c65f : 38               [ 2] 	sec
c660 : bd0501           [ 4] 	lda 0x0105,x
c663 : e902             [ 2] 	sbc #2
c665 : 85ab             [ 3] 	sta df_brkpc
c667 : bd0601           [ 4] 	lda 0x0106,x
c66a : e900             [ 2] 	sbc #0
c66c : 85ac             [ 3] 	sta df_brkpc+1
                             	; Get the byte pointed to by old PC
                             	; which is 1 on from the BRK
c66e : a001             [ 2] 	ldy #1
c670 : b1ab             [ 5] 	lda (df_brkpc),y
c672 : 85ad             [ 3] 	sta df_brkval
c674 : 85a6             [ 3] 	sta errno
                             	; now update the return address
c676 : a5a9             [ 3] 	lda df_pc
c678 : 9d0501           [ 5] 	sta 0x105,x
c67b : a5aa             [ 3] 	lda df_pc+1
c67d : 9d0601           [ 5] 	sta 0x106,x
                             	
                             	_pullAXY
                             
                             	; Save the registers in temp area
c683 : 858e             [ 3] 	sta num_a
c685 : 868f             [ 3] 	stx num_a+1
c687 : 8490             [ 3] 	sty num_a+2
                             	; when RTI occurs:
                             	;  will return to error handler
                             	;  df_brkval will contain signature
c689 : 40               [ 6] 	rti
                             	
                             ;****************************************
AS65 Assembler for R6502 [1.42].                                     Page   34
-------------------------------- bank\bank2.s --------------------------------

                             ;* int_kb_handler
                             ;* Keyboard interrupt handler
                             ;****************************************
c68a :                       int_kb_handler	
c68a : a533             [ 3] 	lda kb_deb				; If keyboard pressed is debounce 
c68c : d00d             [ 3] 	bne int_skip_scan		; If not zero, then don't che
c68e : ad0d04           [ 4] 	lda IO_0 + IFR			; Check status register CIA0
c691 : 2901             [ 2] 	and #IFR_CA2			; Keyboard pressed?
c693 : f00c             [ 3] 	beq int_keys_up
c695 :                       int_do_read
c695 : 8538             [ 3] 	sta kb_pressed			; Put non-zero in to this flag
c697 : a537             [ 3] 	lda kb_debounce			; Set debounce
c699 : 8533             [ 3] 	sta kb_deb
c69b :                       int_skip_scan
c69b : a901             [ 2] 	lda #IFR_CA2			; Clear CA2
c69d : 8d0d04           [ 4] 	sta IO_0 + IFR
c6a0 : 60               [ 6] 	rts
c6a1 :                       int_keys_up					; No key pressed
c6a1 : 642f             [ 3] 	stz kb_raw				; Using 65c02 stz opcode
c6a3 : 6430             [ 3] 	stz kb_last
c6a5 : 6431             [ 3] 	stz kb_code
c6a7 : 6433             [ 3] 	stz kb_deb
c6a9 : 6434             [ 3] 	stz kb_rep
c6ab : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* int_vdp_handler
                             ;* VDP interrupt handler
                             ;****************************************
c6ac :                       int_vdp_handler
c6ac : 20d7c6           [ 6] 	jsr update_timers	; If it is then update system 
c6af : a50f             [ 3] 	lda vdp_curoff		; Is cursor enabled?
c6b1 : d023             [ 3] 	bne int_vdp_fin		; Skip if so
c6b3 : a910             [ 2] 	lda #VDP_FLASH		; Check bit 5 of low timer
c6b5 : 250c             [ 3] 	and vdp_cnt
c6b7 : c510             [ 3] 	cmp vdp_curstat		; Same as curent state?
c6b9 : f01b             [ 3] 	beq int_vdp_fin		; If so no change required
c6bb : 8510             [ 3] 	sta vdp_curstat		; Save new state
                             
c6bd : 18               [ 2] 	clc					; Add offset for cursor address in vram
c6be : a528             [ 3] 	lda gr_scrngeom+gr_cur_ptr
c6c0 : 6525             [ 3] 	adc gr_scrngeom+gr_cur_off
c6c2 : aa               [ 2] 	tax
c6c3 : a529             [ 3] 	lda gr_scrngeom+gr_cur_ptr+1
c6c5 : 6900             [ 2] 	adc #0
                             
c6c7 : 20e3c4           [ 6] 	jsr vdp_wr_addr
                             	
c6ca : a50c             [ 3] 	lda vdp_cnt			; Use counter to determine normal/
c6cc : 0a               [ 2] 	asl a				; Move bit 4 to bit 7 to create inverse
c6cd : 0a               [ 2] 	asl a
c6ce : 0a               [ 2] 	asl a
c6cf : 2980             [ 2] 	and #0x80			; Only top bit is what we want
c6d1 : 4511             [ 3] 	eor vdp_curval		; EOR top bit with what is under
c6d3 : 2009c5           [ 6] 	jsr vdp_wr_vram
c6d6 :                       int_vdp_fin	
c6d6 : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* update_timers
                             ;* Update 24 bit timer and debounce counters
AS65 Assembler for R6502 [1.42].                                     Page   35
-------------------------------- bank\bank2.s --------------------------------

                             ;****************************************
c6d7 :                       update_timers
c6d7 : e60c             [ 5] 	inc vdp_cnt
c6d9 : d006             [ 3] 	bne inc_kb_timers
c6db : e60d             [ 5] 	inc vdp_cnt_hi
c6dd : d002             [ 3] 	bne inc_kb_timers
c6df : e60e             [ 5] 	inc vdp_cnt_hi2
c6e1 :                       inc_kb_timers
c6e1 : a633             [ 3] 	ldx kb_deb			; Is debounce 0?
c6e3 : f002             [ 3] 	beq skip_kb_deb
c6e5 : c633             [ 5] 	dec kb_deb
c6e7 :                       skip_kb_deb
c6e7 : a634             [ 3] 	ldx kb_rep			; Is repeat timer 0?
c6e9 : f002             [ 3] 	beq skip_kb_rep
c6eb : c634             [ 5] 	dec kb_rep
c6ed :                       skip_kb_rep
c6ed : 60               [ 6] 	rts
                             	
                             
                             	include "utils\misc.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  MISC.S
                             ;*  Miscellaneous module for commmon utility func
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             
                             ;****************************************
                             ;* long_delay
                             ;* Long delay (X decremented every 0.125ms)
                             ;* Input : X = number of 0.125ms ticks to wait (m
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
c6ee :                       long_delay
c6ee : 08               [ 3] 	php
                             	_pushAXY
                             
                             	
c6f2 : a000             [ 2] 	ldy #0x00
c6f4 :                       long_delay_1
c6f4 : ea               [ 2] 	nop
c6f5 : ea               [ 2] 	nop
c6f6 : ea               [ 2] 	nop
c6f7 : ea               [ 2] 	nop
c6f8 : 88               [ 2] 	dey
c6f9 : d0f9             [ 3] 	bne long_delay_1
c6fb : ca               [ 2] 	dex
c6fc : d0f6             [ 3] 	bne long_delay_1
                             
                             	_pullAXY
                             
c701 : 28               [ 4] 	plp
AS65 Assembler for R6502 [1.42].                                     Page   36
-------------------------------- bank\bank2.s --------------------------------

                             	
c702 : 60               [ 6] 	rts
                             
                             
                             	include "utils\utils.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  UTILS.S
                             ;*  This module implements various utility functi
                             ;*  converting from ASCII to binary form for numb
                             ;*  vice-versa to allow humans to actually be abl
                             ;*  and read numbers in their prefered form!
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             
c703 :                       jsrPrintA
c703 : 48               [ 3] 	pha
c704 : da               [ 3] 	phx
c705 : 2022c7           [ 6] 	jsr str_a_to_x
c708 : 2049c4           [ 6] 	jsr io_put_ch
c70b : 8a               [ 2] 	txa
c70c : 2049c4           [ 6] 	jsr io_put_ch
c70f : fa               [ 4] 	plx
c710 : 68               [ 4] 	pla
c711 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* util_clr_mem
                             ;* Clear a block of main ram
                             ;* Input : X, A = Block start, Y = Block size
                             ;* Regs affected : P
                             ;****************************************
c712 :                       util_clr_mem
c712 : 48               [ 3] 	pha
c713 : 5a               [ 3] 	phy
c714 : 8639             [ 3] 	stx tmp_alo
c716 : 853a             [ 3] 	sta tmp_ahi
c718 : a900             [ 2] 	lda #0
c71a :                       mem_clr_byte
c71a : 88               [ 2] 	dey
c71b : 9139             [ 5] 	sta (tmp_alo),y
c71d : d0fb             [ 3] 	bne mem_clr_byte
c71f : 7a               [ 4] 	ply
c720 : 68               [ 4] 	pla
c721 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* str_a_to_x
                             ;* Convert accumulator to hex string
                             ;* Input : A = Byte to convert
                             ;* Output : A = High Char, X = Low Char
                             ;* Regs affected : P
                             ;****************************************
AS65 Assembler for R6502 [1.42].                                     Page   37
-------------------------------- bank\bank2.s --------------------------------

c722 :                       str_a_to_x
c722 : 48               [ 3] 	pha					; Save the byte using later on
c723 : 290f             [ 2] 	and #0x0f			; Mask low nibble
c725 : 18               [ 2] 	clc
c726 : 6930             [ 2] 	adc #'0'			; Convert to UTF
c728 : c93a             [ 2] 	cmp #('9'+1)		; If A greater than '9' then
c72a : 9002             [ 3] 	bcc skip_a_f_1		; skip a-f adjustment
c72c : 6926             [ 2] 	adc #0x26			; Add 27 (6+C) to get in to A-F rang
c72e :                       skip_a_f_1
c72e : aa               [ 2] 	tax					; Low char is in X
c72f : 68               [ 4] 	pla					; Get byte back
c730 : 4a               [ 2] 	lsr a				; Make high nibble low
c731 : 4a               [ 2] 	lsr a
c732 : 4a               [ 2] 	lsr a
c733 : 4a               [ 2] 	lsr a
c734 : 18               [ 2] 	clc
c735 : 6930             [ 2] 	adc #'0'			; Convert to UTF
c737 : c93a             [ 2] 	cmp #('9'+1)		; If A greater than '9' then
c739 : 9002             [ 3] 	bcc skip_a_f_2		; skip a-f adjustment
c73b : 6926             [ 2] 	adc #0x26			; Add 27 (6+C) to get in to A-F rang
c73d :                       skip_a_f_2
                             
c73d : 18               [ 2] 	clc					; No error
c73e : 60               [ 6] 	rts					; A high nibble
                             
                             ;****************************************
                             ;* str_x_to_a
                             ;* Convert hex string to accumulator
                             ;* Input : A = High Char, X = Low Char
                             ;* Output : A = Value
                             ;* Regs affected : P
                             ;****************************************
c73f :                       str_x_to_a
c73f : 0920             [ 2] 	ora #0x20			; Make alpha in to lower case
c741 : 38               [ 2] 	sec					; Process high char in A
c742 : e930             [ 2] 	sbc #'0'			; Convert to hex nibble
c744 : c90a             [ 2] 	cmp #10				; If A < 10 then
c746 : 9002             [ 3] 	bcc skip_x_f_1		; skip a-f adjustment
c748 : e927             [ 2] 	sbc #0x27			; Sub 7 to get in to A-F range
c74a :                       skip_x_f_1
c74a : c910             [ 2] 	cmp #0x10			; Nibble should be <= 0x0f
c74c : b01d             [ 3] 	bcs	str_x_to_a_err	; Error if not
                             
c74e : 0a               [ 2] 	asl a				; This is the high nibble
c74f : 0a               [ 2] 	asl a
c750 : 0a               [ 2] 	asl a
c751 : 0a               [ 2] 	asl a
c752 : 48               [ 3] 	pha					; Save the high nibble
c753 : 8a               [ 2] 	txa					; Now process the low char in X
c754 : 0920             [ 2] 	ora #0x20			; Make alpha in to lower case
c756 : 38               [ 2] 	sec
c757 : e930             [ 2] 	sbc #'0'			; Convert to hex nibble
c759 : c90a             [ 2] 	cmp #10				; If A < 10 then
c75b : 9002             [ 3] 	bcc skip_x_f_2		; skip a-f adjustment
c75d : e927             [ 2] 	sbc #0x27			; Sub 7 to get in to A-F range
c75f :                       skip_x_f_2
c75f : c910             [ 2] 	cmp #0x10			; Nibble should be <= 0x0f
c761 : b007             [ 3] 	bcs	str_x_to_a_errl	; Error if not
                             
c763 : 858e             [ 3] 	sta num_a			; Store low nibble in temp
c765 : 68               [ 4] 	pla					; Get high nibble
c766 : 058e             [ 3] 	ora num_a			; OR with low nibble
AS65 Assembler for R6502 [1.42].                                     Page   38
-------------------------------- bank\bank2.s --------------------------------

                             
c768 : 18               [ 2] 	clc					; No error
c769 : 60               [ 6] 	rts					; A contains value
                             
c76a :                       str_x_to_a_errl
c76a : 68               [ 4] 	pla
c76b :                       str_x_to_a_err
                             	SWBRK CMD_ERR_VAL
                             
                             
                             ;****************************************
                             ;* con_n_to_a
                             ;* Convert numeric string to accumulator (unsigne
                             ;* Input : Pointer to string (X=L, A=H), Y = Sour
                             ;* Output : num_a, num_a+1 contains word, X=numbe
                             ;* A = Source type detected
                             ;* Regs affected : CS = Error
                             ;****************************************
c76d :                       con_n_to_a
c76d : 869a             [ 3] 	stx num_tmp
c76f : 859b             [ 3] 	sta num_tmp+1
c771 : 648e             [ 3] 	stz num_a
c773 : 648f             [ 3] 	stz num_a+1
c775 : c000             [ 2] 	cpy #NUM_ANY
c777 : f014             [ 3] 	beq con_n_to_a_detect
c779 : 88               [ 2] 	dey
c77a : d003             [ 3] 	bne con_n_not_dec
c77c :                       con_dec_jmp
c77c : 4c10c8           [ 3] 	jmp con_dec_to_a_int
c77f :                       con_n_not_dec
c77f : 88               [ 2] 	dey
c780 : d003             [ 3] 	bne con_n_not_hex
c782 :                       con_hex_jmp
c782 : 4ca7c7           [ 3] 	jmp con_hex_to_a_int
c785 :                       con_n_not_hex
c785 : 88               [ 2] 	dey
c786 : d003             [ 3] 	bne con_n_err
c788 :                       con_bin_jmp
c788 : 4ce6c7           [ 3] 	jmp con_bin_to_a_int
c78b :                       con_n_err
c78b : 38               [ 2] 	sec
c78c : 60               [ 6] 	rts
c78d :                       con_n_to_a_detect
c78d : b29a             [ 5] 	lda (num_tmp)
c78f : c930             [ 2] 	cmp #'0'
c791 : d0e9             [ 3] 	bne con_dec_jmp
c793 : a001             [ 2] 	ldy #1
c795 : b19a             [ 5] 	lda (num_tmp),y
c797 : 0920             [ 2] 	ora #0x20
c799 : c978             [ 2] 	cmp #'x'
c79b : f0e5             [ 3] 	beq con_hex_jmp
c79d : c962             [ 2] 	cmp #'b'
c79f : f0e7             [ 3] 	beq con_bin_jmp
c7a1 : 80d9             [ 3] 	bra con_dec_jmp
                             
                             ;****************************************
                             ;* con_hex_to_a
                             ;* Convert hex string to accumulator (unsigned)
                             ;* Input : Pointer to string (X=L, A=H)
                             ;* Output : num_a, num_a+1 contains word, X=numbe
                             ;* Regs affected : CS = Error
                             ;****************************************
AS65 Assembler for R6502 [1.42].                                     Page   39
-------------------------------- bank\bank2.s --------------------------------

c7a3 :                       con_hex_to_a
c7a3 : 869a             [ 3] 	stx num_tmp
c7a5 : 859b             [ 3] 	sta num_tmp+1
c7a7 :                       con_hex_to_a_int
c7a7 : a205             [ 2] 	ldx #5			; > 4 digits will cause error
c7a9 : a002             [ 2] 	ldy #2			; start at first digit
c7ab :                       con_hex_digit
c7ab : b19a             [ 5] 	lda (num_tmp),y
c7ad : 0920             [ 2] 	ora #0x20					; Make alpha in to lower case
c7af : 38               [ 2] 	sec							; Process high char in A
c7b0 : e930             [ 2] 	sbc #'0'					; Convert to hex nibble
c7b2 : c90a             [ 2] 	cmp #10						; If A < 10 then
c7b4 : 9002             [ 3] 	bcc con_hex_skip_x_f_1		; skip a-f adjustment
c7b6 : e927             [ 2] 	sbc #0x27					; Sub 7 to get in to A-F range
c7b8 :                       con_hex_skip_x_f_1
c7b8 : c910             [ 2] 	cmp #0x10					; Nibble should be <= 0x0f
c7ba : b01c             [ 3] 	bcs	con_hex_done			; Potentially done if not
c7bc : 48               [ 3] 	pha
                             	; make room for lo nibble
c7bd : 068e             [ 5] 	asl num_a
c7bf : 268f             [ 5] 	rol num_a+1
c7c1 : 068e             [ 5] 	asl num_a
c7c3 : 268f             [ 5] 	rol num_a+1
c7c5 : 068e             [ 5] 	asl num_a
c7c7 : 268f             [ 5] 	rol num_a+1
c7c9 : 068e             [ 5] 	asl num_a
c7cb : 268f             [ 5] 	rol num_a+1
                             	; save in low nibble
c7cd : 68               [ 4] 	pla
c7ce : 058e             [ 3] 	ora num_a
c7d0 : 858e             [ 3] 	sta num_a
c7d2 : c8               [ 2] 	iny
c7d3 : ca               [ 2] 	dex
c7d4 : d0d5             [ 3] 	bne con_hex_digit
                             	; if got to a 5th digit then error
c7d6 :                       con_hex_err
c7d6 : 38               [ 2] 	sec
c7d7 : 60               [ 6] 	rts
                             	; found a non-hex digit
c7d8 :                       con_hex_done
                             	; if no digits processed then error
c7d8 : c002             [ 2] 	cpy #2
c7da : f0fa             [ 3] 	beq con_hex_err
                             	; move y to x for digits processed
c7dc : 98               [ 2] 	tya
c7dd : aa               [ 2] 	tax
c7de : a902             [ 2] 	lda #NUM_HEX
c7e0 : 18               [ 2] 	clc
c7e1 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* con_bin_to_a
                             ;* Convert hex string to accumulator (unsigned)
                             ;* Input : Pointer to string (X=L, A=H)
                             ;* Output : num_a, num_a+1 contains word, X=numbe
                             ;* Regs affected : CS = Error
                             ;****************************************
c7e2 :                       con_bin_to_a
c7e2 : 869a             [ 3] 	stx num_tmp
c7e4 : 859b             [ 3] 	sta num_tmp+1
c7e6 :                       con_bin_to_a_int
c7e6 : a002             [ 2] 	ldy #2
AS65 Assembler for R6502 [1.42].                                     Page   40
-------------------------------- bank\bank2.s --------------------------------

c7e8 : a211             [ 2] 	ldx #17						; Max 16 binary digits allowed
c7ea :                       con_bin_digit
c7ea : b19a             [ 5] 	lda (num_tmp),y
c7ec : c930             [ 2] 	cmp #'0'
c7ee : 9010             [ 4] 	bcc con_bin_done
c7f0 : c932             [ 2] 	cmp #'1'+1
c7f2 : b00c             [ 4] 	bcs con_bin_done
                             	; sets C if '1' else resets C
c7f4 : 69cf             [ 2] 	adc #0xff-'0'
                             	; shift in digit
c7f6 : 268e             [ 5] 	rol num_a
c7f8 : 268f             [ 5] 	rol num_a+1
c7fa : c8               [ 2] 	iny
c7fb : ca               [ 2] 	dex
c7fc : d0ec             [ 3] 	bne con_bin_digit
                             	; on the 17th digit is too much, error
c7fe : 800a             [ 4] 	bra con_bin_err
c800 :                       con_bin_done
                             	; didn't process any digit = error
c800 : c002             [ 2] 	cpy #2
c802 : f006             [ 3] 	beq con_bin_err
                             	; put digits processed in to X
c804 : 98               [ 2] 	tya
c805 : aa               [ 2] 	tax
c806 : a903             [ 2] 	lda #NUM_BIN
c808 : 18               [ 2] 	clc
c809 : 60               [ 6] 	rts
c80a :                       con_bin_err
c80a : 38               [ 2] 	sec
c80b : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* con_d_to_a
                             ;* Convert decimal string to accumulator (SIGNED)
                             ;* Input : Pointer to string (X=L, A=H)
                             ;* Output : num_a, num_a+1 contains word, X=numbe
                             ;* Regs affected : CS = Error
                             ;****************************************
c80c :                       con_dec_to_a
c80c : 869a             [ 3] 	stx num_tmp
c80e : 859b             [ 3] 	sta num_tmp+1
c810 :                       con_dec_to_a_int
c810 : a000             [ 2] 	ldy #0
                             	; Detect if leading minus sign
c812 : b29a             [ 5] 	lda (num_tmp)
c814 : c92d             [ 2] 	cmp #'-'
c816 : d001             [ 3] 	bne str_d_find_end
                             	; skip over minus if found
c818 : c8               [ 2] 	iny
c819 :                       str_d_find_end
c819 : b19a             [ 5] 	lda (num_tmp),y
c81b : c930             [ 2] 	cmp #'0'
c81d : 9007             [ 3] 	bcc str_d_found_end
c81f : c93a             [ 2] 	cmp #'9'+1
c821 : b003             [ 3] 	bcs str_d_found_end
c823 : c8               [ 2] 	iny
c824 : 80f3             [ 3] 	bra str_d_find_end
c826 :                       str_d_found_end
c826 : c006             [ 2] 	cpy #6				; Biggest int is 6 chars
c828 : b04e             [ 3] 	bcs str_d_error		; e.g. -32767
c82a : 849d             [ 3] 	sty num_tmp+3
c82c : 649c             [ 3] 	stz num_tmp+2
AS65 Assembler for R6502 [1.42].                                     Page   41
-------------------------------- bank\bank2.s --------------------------------

c82e : 648e             [ 3] 	stz num_a
c830 : 648f             [ 3] 	stz num_a+1
c832 :                       str_d_process_digit
c832 : 88               [ 2] 	dey
c833 : 3026             [ 3] 	bmi str_d_digits_done
                             
c835 : b19a             [ 5] 	lda (num_tmp),y
                             
c837 : c92d             [ 2] 	cmp #'-'			; Got to minus sign?
c839 : f020             [ 3] 	beq str_d_digits_done ; also done
                             
c83b : 38               [ 2] 	sec
c83c : e930             [ 2] 	sbc #'0'
                             	; Convert digit to number
                             	; and then offset in to
                             	; look up table of powers
c83e : 18               [ 2] 	clc
c83f : 0a               [ 2] 	asl a
c840 : 659c             [ 3] 	adc num_tmp+2
                             	; X contains index to powers
c842 : aa               [ 2] 	tax
c843 : a58e             [ 3] 	lda num_a
c845 : 7d7ac8           [ 4] 	adc str_d_powers,x
c848 : 858e             [ 3] 	sta num_a
c84a : a58f             [ 3] 	lda num_a+1
c84c : 7d7bc8           [ 4] 	adc str_d_powers+1,x
c84f : 858f             [ 3] 	sta num_a+1
c851 : b025             [ 3] 	bcs str_d_error
                             	; Move to next power of 10 index
c853 : a59c             [ 3] 	lda num_tmp+2
c855 : 6914             [ 2] 	adc #20
c857 : 859c             [ 3] 	sta num_tmp+2
c859 : 80d7             [ 3] 	bra str_d_process_digit
c85b :                       str_d_digits_done
                             	; check if minus
c85b : b29a             [ 5] 	lda (num_tmp)
c85d : c92d             [ 2] 	cmp #'-'
c85f : d011             [ 3] 	bne str_d_skip_neg
c861 : a69d             [ 3] 	ldx num_tmp+3		; Must have >= 2 chars
c863 : e002             [ 2] 	cpx #2				; else it's an error
c865 : 9011             [ 3] 	bcc str_d_error
c867 : a68e             [ 3] 	ldx num_a
c869 : a58f             [ 3] 	lda num_a+1
c86b : 20dec8           [ 6] 	jsr twos_complement
c86e : 868e             [ 3] 	stx num_a
c870 : 858f             [ 3] 	sta num_a+1
c872 :                       str_d_skip_neg
c872 : a69d             [ 3] 	ldx num_tmp+3
c874 : a901             [ 2] 	lda #NUM_DEC
c876 : 18               [ 2] 	clc
c877 : 60               [ 6] 	rts
c878 :                       str_d_error
c878 : 38               [ 2] 	sec
c879 : 60               [ 6] 	rts
                             
c87a :                       str_d_powers
c87a : 00000100020003..      	dw	0, 1, 2, 3, 4, 5, 6, 7, 8, 9
c88e : 00000a0014001e..      	dw	0, 10, 20, 30, 40, 50, 60, 70, 80, 90
c8a2 : 00006400c8002c..      	dw	0, 100, 200, 300, 400, 500, 600, 700, 800, 90
c8b6 : 0000e803d007b8..      	dw	0, 1000, 2000, 3000, 4000, 5000, 6000, 7000, 
c8ca : 00001027204e30..      	dw	0, 10000, 20000, 30000, 40000, 50000, 60000, 
                             	
AS65 Assembler for R6502 [1.42].                                     Page   42
-------------------------------- bank\bank2.s --------------------------------

                             
                             ;****************************************
                             ;* twos_complement
                             ;* Twos complement of X,A (X=low)
                             ;* Input : X = Low byte, A = High Byte to convert
                             ;* Output : X,A in 2's complement
                             ;* Regs affected : P
                             ;****************************************
c8de :                       twos_complement
c8de : 49ff             [ 2] 	eor #0xff
c8e0 : 48               [ 3] 	pha
c8e1 : 8a               [ 2] 	txa
c8e2 : 49ff             [ 2] 	eor #0xff
c8e4 : aa               [ 2] 	tax
c8e5 : 68               [ 4] 	pla
c8e6 : e8               [ 2] 	inx
c8e7 : d001             [ 3] 	bne twos_complement_skip_X
c8e9 : 1a               [ 2] 	inc a
c8ea :                       twos_complement_skip_X
c8ea : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* hex_to_bcd
                             ;* Convert accumulator,X to BCD
                             ;* Input : X = Low byte, A = High Byte to convert
                             ;* Output : 3 bytes of num_a is updated
                             ;* Regs affected : P
                             ;****************************************
c8eb :                       hex_to_bcd
c8eb : 08               [ 3] 	php
c8ec : 48               [ 3] 	pha
c8ed : da               [ 3] 	phx
                             
c8ee : 869a             [ 3] 	stx num_tmp
c8f0 : 859b             [ 3] 	sta num_tmp+1
c8f2 : c980             [ 2] 	cmp #0x80			; Negative?
c8f4 : 9003             [ 3] 	bcc hex_to_bcd_skip_neg
c8f6 : 20dec8           [ 6] 	jsr twos_complement
c8f9 :                       hex_to_bcd_skip_neg
c8f9 : 648e             [ 3] 	stz num_a
c8fb : 648f             [ 3] 	stz num_a+1
c8fd : 6490             [ 3] 	stz num_a+2
c8ff : 6491             [ 3] 	stz num_a+3
c901 : a210             [ 2] 	ldx #16
c903 : f8               [ 2] 	sed
c904 :                       bin_to_bcd_bit
c904 : 069a             [ 5] 	asl num_tmp
c906 : 269b             [ 5] 	rol num_tmp+1
c908 : a58e             [ 3] 	lda num_a
c90a : 658e             [ 3] 	adc num_a
c90c : 858e             [ 3] 	sta num_a
c90e : a58f             [ 3] 	lda num_a+1
c910 : 658f             [ 3] 	adc num_a+1
c912 : 858f             [ 3] 	sta num_a+1
c914 : a590             [ 3] 	lda num_a+2
c916 : 6590             [ 3] 	adc num_a+2
c918 : 8590             [ 3] 	sta num_a+2
c91a : ca               [ 2] 	dex
c91b : d0e7             [ 3] 	bne bin_to_bcd_bit
                             	
c91d : fa               [ 4] 	plx
AS65 Assembler for R6502 [1.42].                                     Page   43
-------------------------------- bank\bank2.s --------------------------------

c91e : 68               [ 4] 	pla
c91f : 28               [ 4] 	plp
c920 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* bcd_to_str
                             ;* Convert num_buf to chars
                             ;* Input : num_a in BCD format
                             ;* Output : num_buf in ASCII 6 digits
                             ;* Output is big endian, input is not
                             ;* Regs affected : P
                             ;****************************************
c921 :                       bcd_to_str
c921 : 48               [ 3] 	pha
c922 : da               [ 3] 	phx
c923 : 5a               [ 3] 	phy
                             
c924 : a205             [ 2] 	ldx #5						; Index in to string
c926 : a000             [ 2] 	ldy #0						; Current BCD digit
c928 :                       bcd_str
c928 : b98e00           [ 4] 	lda num_a,y
                             	; Convert 1s digit of byte
c92b : 48               [ 3] 	pha
c92c : 290f             [ 2] 	and #0xf
c92e : 18               [ 2] 	clc
c92f : 6930             [ 2] 	adc #0x30
c931 : 959e             [ 4] 	sta num_buf,x
                             	; Convert 10s digit of byte
c933 : 68               [ 4] 	pla
c934 : 4a               [ 2] 	lsr a
c935 : 4a               [ 2] 	lsr a
c936 : 4a               [ 2] 	lsr a
c937 : 4a               [ 2] 	lsr a
c938 : 18               [ 2] 	clc
c939 : 6930             [ 2] 	adc #0x30					; Convert to ASCII
c93b : 959d             [ 4] 	sta num_buf-1,x
c93d : ca               [ 2] 	dex
c93e : ca               [ 2] 	dex
c93f : c8               [ 2] 	iny
c940 : c003             [ 2] 	cpy #3						; 3 BCD digits max
c942 : d0e4             [ 3] 	bne bcd_str
                             
c944 : 7a               [ 4] 	ply
c945 : fa               [ 4] 	plx
c946 : 68               [ 4] 	pla
c947 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* out_bcd
                             ;* Output a bcd string in num_buf
                             ;* Input : num_buf has the ASCII
                             ;* Input : C=1 print leading zeros else not
                             ;* Output : num_buf in ASCII 6 digits
                             ;* Output is big endian, input is not, Y=digits p
                             ;* Regs affected : P
                             ;****************************************
c948 :                       out_bcd
c948 : 48               [ 3] 	pha
c949 : da               [ 3] 	phx
c94a : 08               [ 3] 	php
c94b : a000             [ 2] 	ldy #0						; How many digits printed
c94d : a200             [ 2] 	ldx #0						; Index in to string
AS65 Assembler for R6502 [1.42].                                     Page   44
-------------------------------- bank\bank2.s --------------------------------

c94f :                       out_bcd_digit
c94f : b59e             [ 4] 	lda num_buf,x
c951 : c000             [ 2] 	cpy #0						; If not in leading zero mode
c953 : d008             [ 3] 	bne out_bcd_print			; No then go print
                             
c955 : c930             [ 2] 	cmp #'0'					; else check if zero
c957 : d004             [ 3] 	bne out_bcd_print			; No then go print
                             
c959 : 28               [ 4] 	plp
c95a : 08               [ 3] 	php
c95b : 9004             [ 3] 	bcc out_bcd_next			; If C=0 go to next digit, el
c95d :                       out_bcd_print
c95d : c8               [ 2] 	iny
c95e : 2049c4           [ 6] 	jsr io_put_ch
c961 :                       out_bcd_next
c961 : e8               [ 2] 	inx
c962 : e006             [ 2] 	cpx #6
c964 : d0e9             [ 3] 	bne out_bcd_digit
c966 : c000             [ 2] 	cpy #0						; If nothing printed
c968 : d006             [ 3] 	bne out_bcd_fin
c96a : a930             [ 2] 	lda #'0'					; Need to put out 1 zero
c96c : 2049c4           [ 6] 	jsr io_put_ch
c96f : c8               [ 2] 	iny
c970 :                       out_bcd_fin
c970 : 28               [ 4] 	plp
c971 : fa               [ 4] 	plx
c972 : 68               [ 4] 	pla
c973 : 18               [ 2] 	clc
c974 : 60               [ 6] 	rts
                             	
                             	
                             ;****************************************
                             ;* print_a_to_d
                             ;* Convert X,A to decimal string
                             ;* Input : X,A = number Low,High
                             ;* Input : C=1 print leading zeros else not
                             ;* Output : num_buf in ASCII max 6 digits
                             ;*          Y=digits printed including sign
                             ;* Output is big endian, input is not
                             ;* Regs affected : P
                             ;****************************************
c975 :                       print_a_to_d
c975 : 08               [ 3] 	php
c976 : 8980             [ 2] 	bit #0x80					; Check if sign bit is set
c978 : 1014             [ 3] 	bpl print_a_to_d_skip_neg	; Skip if not (postive
c97a : 20dec8           [ 6] 	jsr twos_complement			; Flip from 2s complement
c97d : a92d             [ 2] 	lda #'-'
c97f : 2049c4           [ 6] 	jsr io_put_ch
c982 : 20ebc8           [ 6] 	jsr hex_to_bcd				; Convert to BCD
c985 : 2021c9           [ 6] 	jsr bcd_to_str				; Convert BCD to string
c988 : 28               [ 4] 	plp							; Leading zeros preference
c989 : 2048c9           [ 6] 	jsr out_bcd
c98c : c8               [ 2] 	iny							; Account for sign
c98d : 60               [ 6] 	rts
c98e :                       print_a_to_d_skip_neg
c98e : 20ebc8           [ 6] 	jsr hex_to_bcd				; Convert to BCD
c991 : 2021c9           [ 6] 	jsr bcd_to_str				; Convert BCD to string
c994 : 28               [ 4] 	plp							; Leading zeros preference
c995 : 4c48c9           [ 3] 	jmp out_bcd					; Print +ve string
                             
                             
                             ;* Reset vector points here - 6502 starts here
AS65 Assembler for R6502 [1.42].                                     Page   45
-------------------------------- bank\bank2.s --------------------------------

c998 :                       init
                             ;	jmp init_test
                             	; First clear ram
                             ;	sei					; No need as disabled on startup
c998 : 4ccec9           [ 3] 	jmp init_ram		; jmp not jsr to ram initialiser
c99b :                       init_2					; init_ram will jump back to here
c99b : a2ff             [ 2] 	ldx #0xff			; Initialise stack pointer
c99d : 9a               [ 2] 	txs
                             ;	cld					; No need as disabled on startup
                             	
c99e : 20a4c9           [ 6] 	jsr kernel_init
                             
c9a1 : 4c81c5           [ 3] 	jmp main
                             
c9a4 :                       kernel_init
c9a4 : 20f7c5           [ 6] 	jsr init_irq		; Initialise IRQ handling
c9a7 : 207ec1           [ 6] 	jsr _init_acia		; initialise the serial chip
                             	
c9aa : 2096c1           [ 6] 	jsr _init_cia0		; initialise cia 0
c9ad : 20aec1           [ 6] 	jsr _init_cia1		; initialise cia 1
                             
c9b0 :                       kernel_test
c9b0 : 20f6c1           [ 6] 	jsr _init_snd		; initialise the sound chip
c9b3 : 200ec2           [ 6] 	jsr _init_keyboard	; initialise keyboard timer s
c9b6 : 20eec3           [ 6] 	jsr _vdp_init		; initialise vdp
c9b9 : a900             [ 2] 	lda #0				; Default = 40 column mode
c9bb : 2066c1           [ 6] 	jsr _gr_init_screen
c9be : 2006c4           [ 6] 	jsr io_init			; Set default input/output device
c9c1 : 20dec1           [ 6] 	jsr _init_sdcard	; initialise the sd card interf
c9c4 : 20c6c1           [ 6] 	jsr _init_fs		; initialise the filesystem
c9c7 : 640c             [ 3] 	stz vdp_cnt
c9c9 : 202ec0           [ 6] 	jsr _df_init		; Initialise interpreter
                             
c9cc : 58               [ 2] 	cli					; irq interrupts enable
                             
c9cd : 60               [ 6] 	rts
                             
                             	
                             ;* Initialises RAM, skipping pages 4-8 which are 
                             ;* Zeroes all addressable RAM in the default bank
c9ce :                       init_ram
c9ce : 6400             [ 3] 	stz 0x00			; Start at page 0
c9d0 : 6401             [ 3] 	stz 0x01
c9d2 : a002             [ 2] 	ldy #0x02			; But Y initially at 2 to not overwr
c9d4 : a200             [ 2] 	ldx #0x00			; Page counter starts at zero
c9d6 :                       init_ram_1
c9d6 : e004             [ 2] 	cpx	#4				; Page <4 is ok
c9d8 : 9006             [ 3] 	bcc init_ram_fill
c9da : e008             [ 2] 	cpx #8				; Page >=8 is ok
c9dc : b002             [ 3] 	bcs init_ram_fill
c9de : 800a             [ 3] 	bra init_ram_skip
c9e0 :                       init_ram_fill
c9e0 : a900             [ 2] 	lda #0				; Normal RAM filled with zero
c9e2 : e0c0             [ 2] 	cpx #0xc0			; but page 0xC0-0xFF copied from ROM
c9e4 : 9002             [ 3] 	bcc init_ram_zero
c9e6 : b100             [ 5] 	lda (0x00),y		; Read from ROM area
c9e8 :                       init_ram_zero
c9e8 : 9100             [ 5] 	sta (0x00),y		; Write byte to RAM (zero or copy 
c9ea :                       init_ram_skip
c9ea : c8               [ 2] 	iny
c9eb : d0e9             [ 3] 	bne init_ram_1		; Do a whole page
c9ed : e601             [ 5] 	inc 0x01			; Increase page pointer
AS65 Assembler for R6502 [1.42].                                     Page   46
-------------------------------- bank\bank2.s --------------------------------

c9ef : e8               [ 2] 	inx					; Reduce page count
c9f0 : e000             [ 2] 	cpx #0x00			; Do all pages until page 0xff done 
c9f2 : d0e2             [ 3] 	bne init_ram_1
                             	
c9f4 : 4c9bc9           [ 3] 	jmp init_2			; Carry on initialisation
                             
                             ; 6502 Non-maskable interrupt come here
c9f7 :                       nmi
c9f7 : 40               [ 6] 	rti
                             
c9f8 :                       mod_sz_kernel_e
                             
                             
                             	
                             ; Bank specific code goes here
                             	include "sdcard\sdcard.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  SDCARD.S
                             ;*  Low level SD card driver routines.  This modu
                             ;*  software bit banging through VIA 2 port B of 
                             ;*  interface.  So the card is clocked in softwar
                             ;*  not great for performance but fast enough for
                             ;*  purposes.  I think we can get around 8.5KB/s 
                             ;*  read/write speed, translating to around 5.5KB
                             ;*  throughput using the filesystem.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             
                             ;****************************************
                             ;* init_sdcard
                             ;* Initialise SD card interface after CIA2!
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
c9f8 :                       init_sdcard
                             	_println sd_msg_initialising
                             
                             
ca05 : a908             [ 2] 	lda #SD_CS						; Unselect device
ca07 : 0c8004           [ 3] 	tsb SD_REG
ca0a : a901             [ 2] 	lda #SD_CLK						; Set clock low
ca0c : 1c8004           [ 3] 	trb SD_REG
ca0f : a910             [ 2] 	lda #SD_MOSI					; DI/MOSI high
ca11 : 0c8004           [ 3] 	tsb SD_REG
ca14 : a208             [ 2] 	ldx #8							; 8*0.125ms = 1ms
ca16 : 20eec6           [ 6] 	jsr long_delay
                             
ca19 : a208             [ 2] 	ldx #8							; 10 bytes of 0xff
ca1b : a9ff             [ 2] 	lda #0xff
ca1d :                       init_sd_pulse
ca1d : 2069ca           [ 6] 	jsr sd_sendbyte					; Send the 0xff byte
AS65 Assembler for R6502 [1.42].                                     Page   47
-------------------------------- bank\bank2.s --------------------------------

ca20 : ca               [ 2] 	dex
ca21 : d0fa             [ 3] 	bne init_sd_pulse
ca23 : a908             [ 2] 	lda #SD_CS						; Unselect device
ca25 : 0c8004           [ 3] 	tsb SD_REG
                             
ca28 :                       init_cmd0
ca28 : 2022cb           [ 6] 	jsr sd_sendcmd0
ca2b : c9ff             [ 2] 	cmp #0xff						; 0xff is not a valid response
ca2d : d002             [ 3] 	bne init_acmd41
ca2f : 80c7             [ 4] 	bra init_sdcard
                             	
ca31 :                       init_acmd41
ca31 : 2044cb           [ 6] 	jsr sd_sendcmd55
                             
ca34 : 2066cb           [ 6] 	jsr sd_sendcmd41
                             	
ca37 : c900             [ 2] 	cmp #0							; Was R1 = 0
ca39 : d0f6             [ 3] 	bne init_acmd41					; Retry if not
                             	
ca3b :                       init_cmd16
ca3b : 2088cb           [ 6] 	jsr sd_sendcmd16
                             	
ca3e : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* sd_startcmd
                             ;* Start a cmd frame by sending CS high to low
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
ca3f :                       sd_startcmd
ca3f : 48               [ 3] 	pha								; Save A
                             
ca40 : ad0004           [ 4] 	lda IO_0 + PRB					; Get current led status
ca43 : 0902             [ 2] 	ora #KB_LED0					; Initially assume off
ca45 : 4902             [ 2] 	eor #KB_LED0					; Switch on if C=1
ca47 : 8d0004           [ 4] 	sta IO_0 + PRB					; Set the leds
                             
ca4a : a9ff             [ 2] 	lda #0xff						; Send 0xff
ca4c : 2069ca           [ 6] 	jsr sd_sendbyte					; Delay / synch pulses
ca4f : 2069ca           [ 6] 	jsr sd_sendbyte					; With CS not asserted
                             
ca52 : a908             [ 2] 	lda #SD_CS						; Chip select bit
ca54 : 1c8004           [ 3] 	trb SD_REG						; Now set it low
                             
ca57 : 68               [ 4] 	pla								; Restore A
ca58 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* sd_endcmd
                             ;* End a cmd frame by sending CS high
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
ca59 :                       sd_endcmd
ca59 : 48               [ 3] 	pha
                             
ca5a : ad0004           [ 4] 	lda IO_0 + PRB					; Get current led status
ca5d : 0902             [ 2] 	ora #KB_LED0					; Initially assume off
ca5f : 8d0004           [ 4] 	sta IO_0 + PRB					; Set the leds
AS65 Assembler for R6502 [1.42].                                     Page   48
-------------------------------- bank\bank2.s --------------------------------

                             
ca62 : a908             [ 2] 	lda #SD_CS						; Chip select bit
ca64 : 0c8004           [ 3] 	tsb SD_REG						; First set it high
                             
ca67 : 68               [ 4] 	pla
ca68 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* sd_sendbyte
                             ;* Low level byte send routine
                             ;* Input : A = byte to send
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
ca69 :                       sd_sendbyte
ca69 : 48               [ 3] 	pha
ca6a : 5a               [ 3] 	phy
                             
ca6b : 853f             [ 3] 	sta tmp_a						; For shifting out
ca6d : a008             [ 2] 	ldy #8							; 8 bits to shift out
ca6f : ad8004           [ 4] 	lda SD_REG						; Load the SD register to A
ca72 :                       sd_shiftoutbit
ca72 : 0910             [ 2] 	ora #SD_MOSI					; And initially set output bit 
ca74 : 063f             [ 5] 	asl tmp_a						; Unless the bit to transmit is '
ca76 : b002             [ 3] 	bcs sd_shiftskiplo				; so then EOR the bit back
ca78 : 4910             [ 2] 	eor #SD_MOSI
ca7a :                       sd_shiftskiplo
ca7a : 8d8004           [ 4] 	sta SD_REG						; Save data bit first, it seems,
                             	
ca7d : ee8004           [ 6] 	inc SD_REG
ca80 : ce8004           [ 6] 	dec SD_REG
                             
ca83 : 88               [ 2] 	dey								; Count bits
ca84 : d0ec             [ 3] 	bne sd_shiftoutbit				; Until no more bits to se
                             
ca86 : 7a               [ 4] 	ply
ca87 : 68               [ 4] 	pla
                             
ca88 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* sd_getbyte
                             ;* Low level get a byte
                             ;* Input : A = response byte received
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
                             
ca89 :                       sd_getbyte
ca89 : 5a               [ 3] 	phy
ca8a : da               [ 3] 	phx
                             
ca8b : ad8004           [ 4] 	lda SD_REG
ca8e : 0910             [ 2] 	ora #SD_MOSI					; Set MOSI high
ca90 : 8d8004           [ 4] 	sta SD_REG
ca93 : a8               [ 2] 	tay								; Same as A with clock high
ca94 : c8               [ 2] 	iny
ca95 : aa               [ 2] 	tax								; Same as A with clock low
                             	
                             	; Unroll the code almost 20% faster than slow ve
                             	; bit 7
ca96 : 8c8004           [ 4] 	sty SD_REG
AS65 Assembler for R6502 [1.42].                                     Page   49
-------------------------------- bank\bank2.s --------------------------------

ca99 : ad8004           [ 4] 	lda SD_REG						; Sample SD card lines (MISO is 
ca9c : 8e8004           [ 4] 	stx SD_REG
ca9f : c980             [ 2] 	cmp #SD_MISO					; Trial subtract A-MISO, C=1 if
caa1 : 263f             [ 5] 	rol tmp_a						; Rotate carry state in to tmp_a
                             	; bit 6
caa3 : 8c8004           [ 4] 	sty SD_REG
caa6 : ad8004           [ 4] 	lda SD_REG						; Sample SD card lines (MISO is 
caa9 : 8e8004           [ 4] 	stx SD_REG
caac : c980             [ 2] 	cmp #SD_MISO					; Trial subtract A-MISO, C=1 if
caae : 263f             [ 5] 	rol tmp_a						; Rotate carry state in to tmp_a
                             	; bit 5
cab0 : 8c8004           [ 4] 	sty SD_REG
cab3 : ad8004           [ 4] 	lda SD_REG						; Sample SD card lines (MISO is 
cab6 : 8e8004           [ 4] 	stx SD_REG
cab9 : c980             [ 2] 	cmp #SD_MISO					; Trial subtract A-MISO, C=1 if
cabb : 263f             [ 5] 	rol tmp_a						; Rotate carry state in to tmp_a
                             	; bit 4
cabd : 8c8004           [ 4] 	sty SD_REG
cac0 : ad8004           [ 4] 	lda SD_REG						; Sample SD card lines (MISO is 
cac3 : 8e8004           [ 4] 	stx SD_REG
cac6 : c980             [ 2] 	cmp #SD_MISO					; Trial subtract A-MISO, C=1 if
cac8 : 263f             [ 5] 	rol tmp_a						; Rotate carry state in to tmp_a
                             	; bit 3
caca : 8c8004           [ 4] 	sty SD_REG
cacd : ad8004           [ 4] 	lda SD_REG						; Sample SD card lines (MISO is 
cad0 : 8e8004           [ 4] 	stx SD_REG
cad3 : c980             [ 2] 	cmp #SD_MISO					; Trial subtract A-MISO, C=1 if
cad5 : 263f             [ 5] 	rol tmp_a						; Rotate carry state in to tmp_a
                             	; bit 2
cad7 : 8c8004           [ 4] 	sty SD_REG
cada : ad8004           [ 4] 	lda SD_REG						; Sample SD card lines (MISO is 
cadd : 8e8004           [ 4] 	stx SD_REG
cae0 : c980             [ 2] 	cmp #SD_MISO					; Trial subtract A-MISO, C=1 if
cae2 : 263f             [ 5] 	rol tmp_a						; Rotate carry state in to tmp_a
                             	; bit 1
cae4 : 8c8004           [ 4] 	sty SD_REG
cae7 : ad8004           [ 4] 	lda SD_REG						; Sample SD card lines (MISO is 
caea : 8e8004           [ 4] 	stx SD_REG
caed : c980             [ 2] 	cmp #SD_MISO					; Trial subtract A-MISO, C=1 if
caef : 263f             [ 5] 	rol tmp_a						; Rotate carry state in to tmp_a
                             	; bit 0
caf1 : 8c8004           [ 4] 	sty SD_REG
caf4 : ad8004           [ 4] 	lda SD_REG						; Sample SD card lines (MISO is 
caf7 : 8e8004           [ 4] 	stx SD_REG
cafa : c980             [ 2] 	cmp #SD_MISO					; Trial subtract A-MISO, C=1 if
cafc : 263f             [ 5] 	rol tmp_a						; Rotate carry state in to tmp_a
                             
cafe : a53f             [ 3] 	lda tmp_a						; Return response in A
                             
cb00 : fa               [ 4] 	plx
cb01 : 7a               [ 4] 	ply
                             
cb02 : 60               [ 6] 	rts
                             
                             ;sd_getbyte							; OLD and SLOW version
                             ;	phy
                             ;
                             ;	lda SD_REG
                             ;	ora #SD_MOSI					; Set MOSI high
                             ;	sta SD_REG
                             ;	
                             ;	ldy #8							; Shift in the 8 bits
AS65 Assembler for R6502 [1.42].                                     Page   50
-------------------------------- bank\bank2.s --------------------------------

                             ;sd_shiftinbit
                             ;	inc SD_REG
                             ;	lda SD_REG						; Sample SD card lines (MISO is
                             ;	dec SD_REG
                             ;	cmp #SD_MISO					; Trial subtract A-MISO, C=1 i
                             ;	rol tmp_a						; Rotate carry state in to tmp_a
                             ;	dey								; Next bit
                             ;	bne sd_shiftinbit
                             ;
                             ;	lda tmp_a						; Return response in A
                             ;	
                             ;	ply
                             ;
                             ;	rts
                             
                             ;****************************************
                             ;* sd_getrespbyte
                             ;* Low level get response routine
                             ;* Input : A = response byte received
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
cb03 :                       sd_getrespbyte
cb03 : da               [ 3] 	phx
cb04 : a200             [ 2] 	ldx #0							; Try up to 256 times
cb06 :                       sd_respff
cb06 : e8               [ 2] 	inx								; Retry counter
cb07 : f007             [ 3] 	beq sd_resptimeout
cb09 : 2089ca           [ 6] 	jsr sd_getbyte
cb0c : c9ff             [ 2] 	cmp #0xff						; Keep reading MISO until not FF
cb0e : f0f6             [ 3] 	beq sd_respff
cb10 :                       sd_resptimeout
cb10 : fa               [ 4] 	plx
cb11 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* sd_busy
                             ;* Low level busy check routine
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
cb12 :                       sd_busy
cb12 : 48               [ 3] 	pha
cb13 :                       sd_isbusy
cb13 : 2089ca           [ 6] 	jsr sd_getbyte
cb16 : c9ff             [ 2] 	cmp #0xff						; Keep reading MISO until FF
cb18 : d0f9             [ 3] 	bne sd_isbusy
cb1a : 68               [ 4] 	pla
cb1b : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* sd_waitforn0byte
                             ;* Low level routine waits for card to be ready
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
cb1c :                       sd_waitforn0byte
cb1c : 2003cb           [ 6] 	jsr sd_getrespbyte
cb1f : f0fb             [ 3] 	beq sd_waitforn0byte					; Zero byte means not r
cb21 : 60               [ 6] 	rts
AS65 Assembler for R6502 [1.42].                                     Page   51
-------------------------------- bank\bank2.s --------------------------------

                             
                             ;****************************************
                             ;* sd_sendcmd0
                             ;* Send CMD0
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
cb22 :                       sd_sendcmd0
cb22 : 203fca           [ 6] 	jsr sd_startcmd
                             
                             	; Send 0x40, 0x00, 0x00, 0x00, 0x00, 0x95
cb25 : a940             [ 2] 	lda #0x40
cb27 : 2069ca           [ 6] 	jsr sd_sendbyte
cb2a : a900             [ 2] 	lda #0x00
cb2c : 2069ca           [ 6] 	jsr sd_sendbyte
cb2f : 2069ca           [ 6] 	jsr sd_sendbyte
cb32 : 2069ca           [ 6] 	jsr sd_sendbyte
cb35 : 2069ca           [ 6] 	jsr sd_sendbyte
cb38 : a995             [ 2] 	lda #0x95						; Checksum needs to be right
cb3a : 2069ca           [ 6] 	jsr sd_sendbyte
                             
cb3d : 20aecb           [ 6] 	jsr sd_getrespR1				; Get the response
                             
cb40 : 2059ca           [ 6] 	jsr sd_endcmd
                             	
cb43 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* sd_sendcmd55
                             ;* Send CMD55
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
cb44 :                       sd_sendcmd55
cb44 : 203fca           [ 6] 	jsr sd_startcmd
                             
                             	; Send 0x40+55, 0x00, 0x00, 0x00, 0x00, 0x95
cb47 : a977             [ 2] 	lda #0x40+55
cb49 : 2069ca           [ 6] 	jsr sd_sendbyte
cb4c : a900             [ 2] 	lda #0x00
cb4e : 2069ca           [ 6] 	jsr sd_sendbyte
cb51 : 2069ca           [ 6] 	jsr sd_sendbyte
cb54 : 2069ca           [ 6] 	jsr sd_sendbyte
cb57 : 2069ca           [ 6] 	jsr sd_sendbyte
cb5a : a995             [ 2] 	lda #0x95						; Checksum needs to be right
cb5c : 2069ca           [ 6] 	jsr sd_sendbyte
                             
cb5f : 20aecb           [ 6] 	jsr sd_getrespR1				; Get the response
                             
cb62 : 2059ca           [ 6] 	jsr sd_endcmd
                             	
cb65 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* sd_sendcmd41
                             ;* Send ACMD41
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
AS65 Assembler for R6502 [1.42].                                     Page   52
-------------------------------- bank\bank2.s --------------------------------

cb66 :                       sd_sendcmd41
cb66 : 203fca           [ 6] 	jsr sd_startcmd
                             
                             	; Send 0x40+41, 0x00, 0x00, 0x00, 0x00, 0x95
cb69 : a969             [ 2] 	lda #0x40+41
cb6b : 2069ca           [ 6] 	jsr sd_sendbyte
cb6e : a900             [ 2] 	lda #0x00
cb70 : 2069ca           [ 6] 	jsr sd_sendbyte
cb73 : 2069ca           [ 6] 	jsr sd_sendbyte
cb76 : 2069ca           [ 6] 	jsr sd_sendbyte
cb79 : 2069ca           [ 6] 	jsr sd_sendbyte
cb7c : a995             [ 2] 	lda #0x95						; Checksum needs to be right
cb7e : 2069ca           [ 6] 	jsr sd_sendbyte
                             
cb81 : 20aecb           [ 6] 	jsr sd_getrespR1				; Get the response
                             
cb84 : 2059ca           [ 6] 	jsr sd_endcmd
                             	
cb87 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* sd_sendcmd16
                             ;* Send CMD16
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
cb88 :                       sd_sendcmd16
cb88 : 203fca           [ 6] 	jsr sd_startcmd
                             
                             	; Send 0x40+16, 0x00, 0x00, 0x02, 0x00, 0x95
cb8b : a950             [ 2] 	lda #0x40+16
cb8d : 2069ca           [ 6] 	jsr sd_sendbyte
cb90 : a900             [ 2] 	lda #0x00
cb92 : 2069ca           [ 6] 	jsr sd_sendbyte
cb95 : 2069ca           [ 6] 	jsr sd_sendbyte
cb98 : a902             [ 2] 	lda #0x02						; 0x200 block size = 512 bytes
cb9a : 2069ca           [ 6] 	jsr sd_sendbyte
cb9d : a900             [ 2] 	lda #0x00
cb9f : 2069ca           [ 6] 	jsr sd_sendbyte
cba2 : a995             [ 2] 	lda #0x95						; Checksum needs to be right
cba4 : 2069ca           [ 6] 	jsr sd_sendbyte
                             
cba7 : 20aecb           [ 6] 	jsr sd_getrespR1				; Get the response
                             
cbaa : 2059ca           [ 6] 	jsr sd_endcmd
                             	
cbad : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* sd_getrespR1
                             ;* Low level get response R1
                             ;* Input : A = response byte received
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
cbae :                       sd_getrespR1
cbae : 2003cb           [ 6] 	jsr sd_getrespbyte
cbb1 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* sd_sendcmd17
AS65 Assembler for R6502 [1.42].                                     Page   53
-------------------------------- bank\bank2.s --------------------------------

                             ;* Send CMD17
                             ;* Input : sd_sect = 4 bytes of sector offset lit
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
cbb2 :                       sd_sendcmd17
cbb2 : da               [ 3] 	phx
cbb3 : 48               [ 3] 	pha								; A is the page to write to
                             	
cbb4 : 203fca           [ 6] 	jsr sd_startcmd
                             
                             	; Convert sector address to byte address
                             	; Sector address is little endian
                             	; Byte address is big endian
cbb7 : 644d             [ 3] 	stz sd_addr+3					; LSB of address is always 0
cbb9 : a546             [ 3] 	lda sd_sect+0					; LSB of sector goes to addres
cbbb : 854c             [ 3] 	sta sd_addr+2					; Equivalent of * 256
cbbd : a547             [ 3] 	lda sd_sect+1
cbbf : 854b             [ 3] 	sta sd_addr+1
cbc1 : a548             [ 3] 	lda sd_sect+2
cbc3 : 854a             [ 3] 	sta sd_addr+0
cbc5 : 18               [ 2] 	clc								; Now addr*2 so equiv to sect*512
cbc6 : 064d             [ 5] 	asl sd_addr+3
cbc8 : 264c             [ 5] 	rol sd_addr+2
cbca : 264b             [ 5] 	rol sd_addr+1
cbcc : 264a             [ 5] 	rol sd_addr+0
                             
cbce :                       sd_cmd17addr
                             	; Send 0x40+17, 0xA3, 0xA2, 0xA1, 0xA0, 0x95
cbce : a951             [ 2] 	lda #0x40+17
cbd0 : 2069ca           [ 6] 	jsr sd_sendbyte
cbd3 : a54a             [ 3] 	lda sd_addr+0
cbd5 : 2069ca           [ 6] 	jsr sd_sendbyte
cbd8 : a54b             [ 3] 	lda sd_addr+1
cbda : 2069ca           [ 6] 	jsr sd_sendbyte
cbdd : a54c             [ 3] 	lda sd_addr+2
cbdf : 2069ca           [ 6] 	jsr sd_sendbyte
cbe2 : a54d             [ 3] 	lda sd_addr+3
cbe4 : 2069ca           [ 6] 	jsr sd_sendbyte
cbe7 : a995             [ 2] 	lda #0x95						; Checksum needs to be right
cbe9 : 2069ca           [ 6] 	jsr sd_sendbyte
                             
cbec : 2003cb           [ 6] 	jsr sd_getrespbyte
cbef : aa               [ 2] 	tax								; Save response in X for return
                             
cbf0 : 68               [ 4] 	pla								; Get the A param
cbf1 : 20fdcb           [ 6] 	jsr sd_getrespR17				; Get the response
                             
cbf4 : 2012cb           [ 6] 	jsr sd_busy						; Wait for card to be ready
                             	
cbf7 : 2059ca           [ 6] 	jsr sd_endcmd
                             
cbfa : 8a               [ 2] 	txa								; Restore the response byte
cbfb : fa               [ 4] 	plx
                             	
cbfc : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* sd_getrespR17
                             ;* Low level get response R17
                             ;* Input : A = R1 response byte received
                             ;* Output : None
AS65 Assembler for R6502 [1.42].                                     Page   54
-------------------------------- bank\bank2.s --------------------------------

                             ;* Regs affected : None
                             ;****************************************
cbfd :                       sd_getrespR17
cbfd : 48               [ 3] 	pha
cbfe : 5a               [ 3] 	phy
                             
cbff : 853a             [ 3] 	sta tmp_ahi						; Page to read in to
cc01 : 6439             [ 3] 	stz tmp_alo						; Always a page boundary
cc03 :                       sd_getrespR17token
cc03 : 2089ca           [ 6] 	jsr sd_getbyte					; Get a byte
cc06 : c9fe             [ 2] 	cmp #0xfe						; Is it the token?
cc08 : d0f9             [ 3] 	bne sd_getrespR17token			; No
                             	
cc0a : a000             [ 2] 	ldy #0							; read 1st 256 bytes
cc0c :                       sd_getrespR17block1
cc0c : 2089ca           [ 6] 	jsr sd_getbyte					; get a byte
cc0f : 9139             [ 5] 	sta (tmp_alo),y					; Save the byte
cc11 : c8               [ 2] 	iny								; Keep going
cc12 : d0f8             [ 3] 	bne sd_getrespR17block1			; Until all bytes read
                             
cc14 : e63a             [ 5] 	inc tmp_ahi						; Next page
cc16 :                       sd_getrespR17block2
cc16 : 2089ca           [ 6] 	jsr sd_getbyte					; get a byet
cc19 : 9139             [ 5] 	sta (tmp_alo),y					; Save the byte
cc1b : c8               [ 2] 	iny								; Keep going
cc1c : d0f8             [ 3] 	bne sd_getrespR17block2			; Until all bytes read
                             
cc1e : 2089ca           [ 6] 	jsr sd_getbyte					; CRC
cc21 : 2089ca           [ 6] 	jsr sd_getbyte					; CRC
                             	
cc24 : 7a               [ 4] 	ply
cc25 : 68               [ 4] 	pla
                             
cc26 : 60               [ 6] 	rts
                             	
                             
                             ;****************************************
                             ;* sd_sendcmd24
                             ;* Send CMD24
                             ;* Input : sd_sect = 4 bytes of sector offset lit
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
cc27 :                       sd_sendcmd24
cc27 : 5a               [ 3] 	phy
cc28 : 48               [ 3] 	pha
                             
cc29 : 203fca           [ 6] 	jsr sd_startcmd
                             
                             	; Convert sector address to byte address
                             	; Sector address is little endian
                             	; Byte address is big endian
cc2c : 644d             [ 3] 	stz sd_addr+3					; LSB of address is always 0
cc2e : a546             [ 3] 	lda sd_sect+0					; LSB of sector goes to addres
cc30 : 854c             [ 3] 	sta sd_addr+2					; Equivalent of * 256
cc32 : a547             [ 3] 	lda sd_sect+1
cc34 : 854b             [ 3] 	sta sd_addr+1
cc36 : a549             [ 3] 	lda sd_sect+3
cc38 : 854a             [ 3] 	sta sd_addr+0
cc3a : 18               [ 2] 	clc								; Now addr*2 so equiv to sect*512
cc3b : 064d             [ 5] 	asl sd_addr+3
cc3d : 264c             [ 5] 	rol sd_addr+2
AS65 Assembler for R6502 [1.42].                                     Page   55
-------------------------------- bank\bank2.s --------------------------------

cc3f : 264b             [ 5] 	rol sd_addr+1
cc41 : 264a             [ 5] 	rol sd_addr+0
                             
                             	; Send 0x40+24, 0xA0, 0xA1, 0xA2, 0xA3, 0x95
cc43 : a958             [ 2] 	lda #0x40+24
cc45 : 2069ca           [ 6] 	jsr sd_sendbyte
cc48 : a54a             [ 3] 	lda sd_addr+0
cc4a : 2069ca           [ 6] 	jsr sd_sendbyte
cc4d : a54b             [ 3] 	lda sd_addr+1
cc4f : 2069ca           [ 6] 	jsr sd_sendbyte
cc52 : a54c             [ 3] 	lda sd_addr+2
cc54 : 2069ca           [ 6] 	jsr sd_sendbyte
cc57 : a54d             [ 3] 	lda sd_addr+3
cc59 : 2069ca           [ 6] 	jsr sd_sendbyte
cc5c : a995             [ 2] 	lda #0x95					; Checksum needs to be right
cc5e : 2069ca           [ 6] 	jsr sd_sendbyte
                             
cc61 : 2003cb           [ 6] 	jsr sd_getrespbyte			; Get response
                             
cc64 : 2089ca           [ 6] 	jsr sd_getbyte
                             	
cc67 : a9fe             [ 2] 	lda #0xfe					; Start of data token
cc69 : 2069ca           [ 6] 	jsr sd_sendbyte
                             
cc6c : 68               [ 4] 	pla							; Retrieve the address high byte
cc6d : 853a             [ 3] 	sta tmp_ahi
cc6f : 6439             [ 3] 	stz tmp_alo					; Address is always page boundar
                             
cc71 : a000             [ 2] 	ldy #00
cc73 :                       sd_writeblock_1					; Send first 256 bytes
cc73 : b139             [ 5] 	lda (tmp_alo), y
cc75 : 2069ca           [ 6] 	jsr sd_sendbyte
cc78 : c8               [ 2] 	iny
cc79 : d0f8             [ 3] 	bne sd_writeblock_1
cc7b : e63a             [ 5] 	inc tmp_ahi					; Next page for second 256 bytes
cc7d :                       sd_writeblock_2					; Send second 256 bytes
cc7d : b139             [ 5] 	lda (tmp_alo), y
cc7f : 2069ca           [ 6] 	jsr sd_sendbyte
cc82 : c8               [ 2] 	iny
cc83 : d0f8             [ 3] 	bne sd_writeblock_2
                             
cc85 : a9aa             [ 2] 	lda #0xaa					; Arbitrary CRC bytes
cc87 : 2069ca           [ 6] 	jsr sd_sendbyte
cc8a : 2069ca           [ 6] 	jsr sd_sendbyte
                             
cc8d : 2089ca           [ 6] 	jsr sd_getbyte				; Get data response byte
cc90 : 48               [ 3] 	pha							; Save it to return
                             
cc91 :                       sd_waitforwritecomplete
cc91 : 2012cb           [ 6] 	jsr sd_busy					; Wait for card to be ready
                             	
cc94 : 2059ca           [ 6] 	jsr sd_endcmd				; Release the card
                             
cc97 : 68               [ 4] 	pla
cc98 : 7a               [ 4] 	ply
cc99 : 60               [ 6] 	rts
                             
                             	
cc9a :                       sd_msg_initialising
cc9a : 0d496e69746961..      	db "\rInitialising SD Card\r", 0
                             
ccb1 :                       sd_cmd55
AS65 Assembler for R6502 [1.42].                                     Page   56
-------------------------------- bank\bank2.s --------------------------------

ccb1 : 770000000095          	db (0x40+55), 0x00, 0x00, 0x00, 0x00, 0x95
ccb7 :                       sd_cmd58
ccb7 : 7a0000000095          	db (0x40+58), 0x00, 0x00, 0x00, 0x00, 0x95
ccbd :                       sd_acmd41
ccbd : 690000000095          	db (0x40+41), 0x00, 0x00, 0x00, 0x00, 0x95
                             	
                             
                             	include "sdcard\sd_fs.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  SD_FS.S
                             ;*  FAT16 filesystem module.  Implements a basic 
                             ;*  filesystem to enable mass storage support.
                             ;*  I've been a bit naughty in that I have assume
                             ;*  sd card size and sector 0 is the MBR.  This i
                             ;*  always the case, but it works for me so I cou
                             ;*  the time be asked to sort it out. I may fix t
                             ;*  more general use at some point..
                             ;*  The filesystem now supports sub directories a
                             ;*  implements the folling:
                             ;*  - load a file
                             ;*  - save a file
                             ;*  - delete a file from the card
                             ;*  - perform a directory listing
                             ;*  - change to subdirectory
                             ;*  I have to say I am pretty pleased with this, 
                             ;*  of reading and research!
                             ;*
                             ;************************************************
                             
                             
                             	; ROM code
                             	code
                             
ccc3 :                       mod_sz_sd_fs_s
                             
                             ;****************************************
                             ;* init_fs
                             ;* Initialise filesystem - after sd card!
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
ccc3 :                       init_fs
                             	_println msg_initialising_fs
                             
                             
                             	;Load MBR sector 0
ccd0 : a203             [ 2] 	ldx #0x03					; Init sector to 0
ccd2 :                       init_fs_clr_sect
ccd2 : 7446             [ 4] 	stz sd_sect,x
ccd4 : ca               [ 2] 	dex
ccd5 : 10fb             [ 3] 	bpl init_fs_clr_sect
                             
ccd7 : a902             [ 2] 	lda #hi(sd_buf)				; Read in to the buffer
ccd9 : 20b2cb           [ 6] 	jsr sd_sendcmd17			; Call read block
AS65 Assembler for R6502 [1.42].                                     Page   57
-------------------------------- bank\bank2.s --------------------------------

                             
                             	;Find sector of partition 1
ccdc : a203             [ 2] 	ldx #0x03					; Get partition 1
ccde :                       init_fs_get_part1
ccde : bdc603           [ 4] 	lda sd_buf+MBR_BootPart1,x
cce1 : 9546             [ 4] 	sta sd_sect,x
cce3 : 954e             [ 4] 	sta fs_bootsect,x			; This is also the actual bo
cce5 : ca               [ 2] 	dex
cce6 : 10f6             [ 3] 	bpl init_fs_get_part1
                             	; Get partition 1 sector
cce8 : a902             [ 2] 	lda #hi(sd_buf)				; Read in to the buffer
ccea : 20b2cb           [ 6] 	jsr sd_sendcmd17			; Call read block
                             
                             	; Calculate start of FAT tables
                             	; Assumeing there are about 64k clusters
                             	; Each cluster assumed to be 32k sectors
                             	; Giving 64k x 32k x 0.5 ~ 1GB storage
cced : 18               [ 2] 	clc
ccee : a54e             [ 3] 	lda fs_bootsect
ccf0 : 6d0e02           [ 4] 	adc sd_buf+MBR_ResvSect
ccf3 : 8552             [ 3] 	sta fs_fatsect
ccf5 : a54f             [ 3] 	lda fs_bootsect+1
ccf7 : 6d0f02           [ 4] 	adc sd_buf+MBR_ResvSect+1
ccfa : 8553             [ 3] 	sta fs_fatsect+1
ccfc : 6454             [ 3] 	stz fs_fatsect+2
ccfe : 6455             [ 3] 	stz fs_fatsect+3
                             	
                             	; Calculate start of Root Directory
cd00 : ad1602           [ 4] 	lda sd_buf+MBR_SectPerFAT	; Initialise to 2 * Se
cd03 : 0a               [ 2] 	asl a
cd04 : 8556             [ 3] 	sta fs_rootsect
cd06 : ad1702           [ 4] 	lda sd_buf+MBR_SectPerFAT+1
cd09 : 2a               [ 2] 	rol a
cd0a : 8557             [ 3] 	sta fs_rootsect+1
cd0c : 6458             [ 3] 	stz fs_rootsect+2
cd0e : 6459             [ 3] 	stz fs_rootsect+3
                             
                             	; Now add FAT offset
cd10 : 18               [ 2] 	clc
cd11 : a200             [ 2] 	ldx #0x00
cd13 : a004             [ 2] 	ldy #4
cd15 :                       fs_init_add_fat
cd15 : b552             [ 4] 	lda fs_fatsect,x
cd17 : 7556             [ 4] 	adc fs_rootsect,x
cd19 : 9556             [ 4] 	sta fs_rootsect,x
cd1b : e8               [ 2] 	inx
cd1c : 88               [ 2] 	dey
cd1d : d0f6             [ 3] 	bne fs_init_add_fat
                             	
                             	; Calculate start of data area
                             	; Assuming 512 root dir entries
                             	; Each entry = 32 bytes
                             	; Divided by bytes per sector
                             	; to get sector count
cd1f : a920             [ 2] 	lda #32						; (512*32)/512 = 32
cd21 : 855a             [ 3] 	sta fs_datasect
cd23 : 645b             [ 3] 	stz fs_datasect+1
cd25 : 645c             [ 3] 	stz fs_datasect+2
cd27 : 645d             [ 3] 	stz fs_datasect+3
                             
                             	; Now add root directory offset
cd29 : 18               [ 2] 	clc
AS65 Assembler for R6502 [1.42].                                     Page   58
-------------------------------- bank\bank2.s --------------------------------

cd2a : a200             [ 2] 	ldx #0x00
cd2c : a004             [ 2] 	ldy #4
cd2e :                       fs_init_data
cd2e : b556             [ 4] 	lda fs_rootsect,x
cd30 : 755a             [ 4] 	adc fs_datasect,x
cd32 : 955a             [ 4] 	sta fs_datasect,x
cd34 : e8               [ 2] 	inx
cd35 : 88               [ 2] 	dey
cd36 : d0f6             [ 3] 	bne fs_init_data
                             
cd38 : 38               [ 2] 	sec							; Now subtract 2 clusters worth of sec
cd39 : a55a             [ 3] 	lda fs_datasect+0			; to enable easy use of clus
cd3b : e940             [ 2] 	sbc #0x40					; FS handling routines
cd3d : 855a             [ 3] 	sta fs_datasect+0			; Each cluster = 32 sectors
cd3f : a55b             [ 3] 	lda fs_datasect+1			; Therefore take off 0x40 se
cd41 : e900             [ 2] 	sbc #0
cd43 : 855b             [ 3] 	sta fs_datasect+1
cd45 : a55c             [ 3] 	lda fs_datasect+2
cd47 : e900             [ 2] 	sbc #0
cd49 : 855c             [ 3] 	sta fs_datasect+2
cd4b : a55d             [ 3] 	lda fs_datasect+3
cd4d : e900             [ 2] 	sbc #0
cd4f : 855d             [ 3] 	sta fs_datasect+3
                             
                             	; Current directory = root dir
cd51 : 2055cd           [ 6] 	jsr fs_rootdir
                             	
cd54 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* fs_rootdir
                             ;* Change current directory to root
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
cd55 :                       fs_rootdir
cd55 : 48               [ 3] 	pha
cd56 : da               [ 3] 	phx
                             	; Current directory = root dir
cd57 : a203             [ 2] 	ldx #0x03
cd59 :                       fs_rootdir_sect
cd59 : b556             [ 4] 	lda fs_rootsect,x
cd5b : 955e             [ 4] 	sta fs_dirsect,x
cd5d : ca               [ 2] 	dex
cd5e : 10f9             [ 3] 	bpl fs_rootdir_sect
                             
cd60 : fa               [ 4] 	plx
cd61 : 68               [ 4] 	pla
cd62 : 60               [ 6] 	rts
                             	
                             
                             ;****************************************
                             ;* fs_getbyte_sd_buf
                             ;* Given a populated SD buffer, get byte
                             ;* Indexed by X,Y (X=lo,Y=hi) 
                             ;* Input : X,Y make 9 bit index
                             ;* Output : A=Byte
                             ;* Regs affected : None
                             ;****************************************
cd63 :                       fs_getbyte_sd_buf
                             	; if bit 9<>0 then 2nd half of sd_buf
AS65 Assembler for R6502 [1.42].                                     Page   59
-------------------------------- bank\bank2.s --------------------------------

cd63 : 98               [ 2] 	tya
cd64 : 2901             [ 2] 	and #1
cd66 : d004             [ 3] 	bne fs_getbyte_sd_buf_hi
cd68 : bd0002           [ 4] 	lda sd_buf,x
cd6b : 60               [ 6] 	rts
cd6c :                       fs_getbyte_sd_buf_hi
cd6c : bd0003           [ 4] 	lda sd_buf+0x100,x
cd6f : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* fs_putbyte_sd_buf
                             ;* Given a populated SD buffer, put byte
                             ;* Indexed by X,Y (X=lo,Y=hi), A=Val 
                             ;* Input : X,Y make 9 bit index, A=byte
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
cd70 :                       fs_putbyte_sd_buf
cd70 : 48               [ 3] 	pha
                             	; if bit 9<>0 then 2nd half of sd_buf
cd71 : 98               [ 2] 	tya
cd72 : 2901             [ 2] 	and #1
cd74 : d005             [ 3] 	bne fs_putbyte_sd_buf_hi
cd76 : 68               [ 4] 	pla
cd77 : 9d0002           [ 5] 	sta sd_buf,x
cd7a : 60               [ 6] 	rts
cd7b :                       fs_putbyte_sd_buf_hi
cd7b : 68               [ 4] 	pla
cd7c : 9d0003           [ 5] 	sta sd_buf+0x100,x
cd7f : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* fs_getword_sd_buf
                             ;* Given a populated SD buffer, get word
                             ;* Indexed by Y which is word aligned 
                             ;* Input : Y=Word offset in to sd_buf
                             ;* Output : X,A=Word
                             ;* Regs affected : Y
                             ;****************************************
cd80 :                       fs_getword_sd_buf
cd80 : 98               [ 2] 	tya
cd81 : 0a               [ 2] 	asl a
cd82 : a8               [ 2] 	tay
cd83 : b007             [ 3] 	bcs fs_getword_sd_buf_hi
cd85 : be0002           [ 4] 	ldx sd_buf,y
cd88 : b90102           [ 4] 	lda sd_buf+1,y
cd8b : 60               [ 6] 	rts
cd8c :                       fs_getword_sd_buf_hi
cd8c : be0003           [ 4] 	ldx sd_buf+0x100,y
cd8f : b90103           [ 4] 	lda sd_buf+0x100+1,y
cd92 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* fs_putword_sd_buf
                             ;* Given a populated SD buffer, put word
                             ;* Indexed by Y which is word aligned 
                             ;* Input : Y=Word offset in to sd_buf
                             ;* Output : X,A=Word
                             ;* Regs affected : Y
                             ;****************************************
cd93 :                       fs_putword_sd_buf
cd93 : 48               [ 3] 	pha
AS65 Assembler for R6502 [1.42].                                     Page   60
-------------------------------- bank\bank2.s --------------------------------

cd94 : 98               [ 2] 	tya
cd95 : 0a               [ 2] 	asl a
cd96 : a8               [ 2] 	tay
cd97 : b009             [ 3] 	bcs fs_putword_sd_buf_hi
cd99 : 8a               [ 2] 	txa
cd9a : 990002           [ 5] 	sta sd_buf,y
cd9d : 68               [ 4] 	pla
cd9e : 990102           [ 5] 	sta sd_buf+1,y
cda1 : 60               [ 6] 	rts
cda2 :                       fs_putword_sd_buf_hi
cda2 : 8a               [ 2] 	txa
cda3 : 990003           [ 5] 	sta sd_buf+0x100,y
cda6 : 68               [ 4] 	pla
cda7 : 990103           [ 5] 	sta sd_buf+0x100+1,y
cdaa : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* fs_dir_root_start
                             ;* Initialise ready to read root directory
                             ;* Input : dirsect is current directory pointer
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
cdab :                       fs_dir_root_start
cdab : 48               [ 3] 	pha
cdac : da               [ 3] 	phx
                             
                             	; Set SD sector to root directory
cdad : a203             [ 2] 	ldx #0x03
cdaf :                       fs_dir_set_sd
cdaf : b55e             [ 4] 	lda fs_dirsect,x
cdb1 : 9546             [ 4] 	sta sd_sect,x
cdb3 : ca               [ 2] 	dex
cdb4 : 10f9             [ 3] 	bpl fs_dir_set_sd
                             
                             	; SD buffer is where blocks will be read to
cdb6 : 6444             [ 3] 	stz sd_slo
cdb8 : a902             [ 2] 	lda #hi(sd_buf)
cdba : 8545             [ 3] 	sta sd_shi
                             
                             	; Load up first sector in to SD buf
cdbc : a902             [ 2] 	lda #hi(sd_buf)
cdbe : 20b2cb           [ 6] 	jsr sd_sendcmd17
                             
cdc1 : fa               [ 4] 	plx
cdc2 : 68               [ 4] 	pla
cdc3 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* fs_dir_find_entry
                             ;* Read directory entry
                             ;* Input : sd_slo, sd_shi : Pointer to directory 
                             ;* Input : C = 0 only find active files.  C = 1 f
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
cdc4 :                       fs_dir_find_entry
cdc4 : 48               [ 3] 	pha
cdc5 : da               [ 3] 	phx
cdc6 : 5a               [ 3] 	phy
cdc7 : 08               [ 3] 	php							; Save C state for checking later
AS65 Assembler for R6502 [1.42].                                     Page   61
-------------------------------- bank\bank2.s --------------------------------

cdc8 :                       fs_dir_check_entry
                             	; Not LFN aware
cdc8 : a00b             [ 2] 	ldy #FAT_Attr				; Check attribute
cdca : a9ce             [ 2] 	lda #0xce					; Any of H, S, V, I then skip
cdcc : 3144             [ 5] 	and (sd_slo),y
cdce : d01a             [ 3] 	bne fs_dir_invalid_entry
cdd0 : a000             [ 2] 	ldy #FAT_Name				; Examine 1st byte of name
cdd2 : b144             [ 5] 	lda (sd_slo),y
cdd4 : 28               [ 4] 	plp							; Check C
cdd5 : 08               [ 3] 	php
cdd6 : 900a             [ 3] 	bcc	fs_find_active_slot		; Looking to find an ac
cdd8 : c900             [ 2] 	cmp #0						; Else looking for 0 or 0xe5
cdda : f017             [ 3] 	beq fs_dir_found_entry
cddc : c9e5             [ 2] 	cmp #0xe5
cdde : f013             [ 3] 	beq fs_dir_found_entry
cde0 : 8008             [ 3] 	bra fs_dir_invalid_entry	; Else not an entry we'
cde2 :                       fs_find_active_slot
cde2 : c900             [ 2] 	cmp #0
cde4 : f009             [ 3] 	beq fs_dir_done				; If zero then no more entrie
cde6 : c9e5             [ 2] 	cmp #0xe5					; Deleted entry?
cde8 : d009             [ 3] 	bne fs_dir_found_entry
cdea :                       fs_dir_invalid_entry
cdea : 20ffcd           [ 6] 	jsr fs_dir_next_entry		; Advance read for next i
cded : 80d9             [ 3] 	bra fs_dir_check_entry
                             
                             	; Found a valid entry or finished
cdef :                       fs_dir_done						; No more entries
cdef : 28               [ 4] 	plp							; Remove temp P from stack
cdf0 : 38               [ 2] 	sec							; Set carry to indicate no more
cdf1 : 8008             [ 3] 	bra fs_dir_fin
cdf3 :                       fs_dir_found_entry
cdf3 : 28               [ 4] 	plp							; Remove temp P from stack
cdf4 : 2031ce           [ 6] 	jsr fs_dir_copy_entry		; Copy the important entr
cdf7 : 20ffcd           [ 6] 	jsr fs_dir_next_entry		; Advance read for next i
cdfa : 18               [ 2] 	clc							; Clear carry to indicate found
cdfb :                       fs_dir_fin						; Finalise
cdfb : 7a               [ 4] 	ply
cdfc : fa               [ 4] 	plx
cdfd : 68               [ 4] 	pla
cdfe : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* fs_dir_next_entry
                             ;* Jump to next directory entry (32 bytes)
                             ;* Load next sector if required
                             ;* Input : sd_slo, sd_shi : Pointer to directory 
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
cdff :                       fs_dir_next_entry
cdff : 48               [ 3] 	pha
ce00 : da               [ 3] 	phx
ce01 : 5a               [ 3] 	phy
                             	
ce02 : 18               [ 2] 	clc							; Jump to next 32 byte entry
ce03 : a544             [ 3] 	lda sd_slo					; Update sd_slo, sd_shi
ce05 : 6920             [ 2] 	adc #32
ce07 : 8544             [ 3] 	sta sd_slo
ce09 : a545             [ 3] 	lda sd_shi
ce0b : 6900             [ 2] 	adc #0
ce0d : 8545             [ 3] 	sta sd_shi
ce0f : c904             [ 2] 	cmp #hi(sd_buf+0x200)		; If not at end of sector
AS65 Assembler for R6502 [1.42].                                     Page   62
-------------------------------- bank\bank2.s --------------------------------

ce11 : d01a             [ 3] 	bne fs_dir_next_done		; then don't load next sec
                             
                             	; Advance the sector
ce13 : a200             [ 2] 	ldx #0x00
ce15 : a004             [ 2] 	ldy #0x04
ce17 : 38               [ 2] 	sec
ce18 :                       fs_dir_inc_sect
ce18 : b546             [ 4] 	lda sd_sect,x
ce1a : 6900             [ 2] 	adc #0
ce1c : 9546             [ 4] 	sta sd_sect,x
ce1e : e8               [ 2] 	inx
ce1f : 88               [ 2] 	dey
ce20 : d0f6             [ 3] 	bne fs_dir_inc_sect
                             	
                             	; Reset SD buffer  where blocks will be read to
ce22 : 6444             [ 3] 	stz sd_slo
ce24 : a902             [ 2] 	lda #hi(sd_buf)
ce26 : 8545             [ 3] 	sta sd_shi
                             
ce28 : a902             [ 2] 	lda #hi(sd_buf)				; Goes in to sd_buf
ce2a : 20b2cb           [ 6] 	jsr sd_sendcmd17			; Load it
                             
ce2d :                       fs_dir_next_done
ce2d : 7a               [ 4] 	ply
ce2e : fa               [ 4] 	plx
ce2f : 68               [ 4] 	pla
ce30 : 60               [ 6] 	rts
                             	
                             
                             ;****************************************
                             ;* fs_dir_copy_entry
                             ;* Copy directory entry
                             ;* Input : sd_slo, sd_shi : Pointer to directory 
                             ;* Input : C = 0 for an active entry (copy loaded
                             ;* Input : C = 1 for an empty entry (don't copy s
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
ce31 :                       fs_dir_copy_entry
ce31 : 48               [ 3] 	pha
ce32 : da               [ 3] 	phx
ce33 : 5a               [ 3] 	phy
ce34 : b04a             [ 3] 	bcs fs_dir_empty_slot		; If an empty slot, then 
                             
                             	;Normal processing of an entry loaded from the d
ce36 : a200             [ 2] 	ldx #FH_Name				; Point to where name will go
ce38 : a000             [ 2] 	ldy #FAT_Name
ce3a :                       fs_dir_get_name_ch
ce3a : b144             [ 5] 	lda (sd_slo),y				; Get name char
ce3c : c920             [ 2] 	cmp #' '					; Don't copy space
ce3e : f010             [ 3] 	beq	fs_dir_skip_name_ch
ce40 : c008             [ 2] 	cpy #FAT_Ext				; At extension?
ce42 : d008             [ 3] 	bne fs_dir_skip_ext_ch
ce44 : 48               [ 3] 	pha							; Save A
ce45 : a92e             [ 2] 	lda #'.'					; Inject '.'
ce47 : 9d910b           [ 5] 	sta fh_dir,x				; Copy byte
ce4a : 68               [ 4] 	pla							; Restore A
ce4b : e8               [ 2] 	inx							; Advance
ce4c :                       fs_dir_skip_ext_ch
ce4c : 9d910b           [ 5] 	sta fh_dir,x				; Copy byte
ce4f : e8               [ 2] 	inx							; Advance
ce50 :                       fs_dir_skip_name_ch
AS65 Assembler for R6502 [1.42].                                     Page   63
-------------------------------- bank\bank2.s --------------------------------

ce50 : c8               [ 2] 	iny							; Next SD dir entry
ce51 : c00b             [ 2] 	cpy #FAT_Attr				; Passed end of name?
ce53 : d0e5             [ 3] 	bne fs_dir_get_name_ch	
ce55 :                       fs_dir_entry_pad_name
ce55 : e00d             [ 2] 	cpx #FH_Size				; End of FH name space?
ce57 : f006             [ 3] 	beq fs_dir_entry_size		; Yes, then copy size
ce59 : 9e910b           [ 5] 	stz fh_dir,x				; Else put 0
ce5c : e8               [ 2] 	inx
ce5d : 80f6             [ 3] 	bra fs_dir_entry_pad_name
                             
ce5f :                       fs_dir_entry_size
ce5f : a20d             [ 2] 	ldx #FH_Size				; Point to where size will go
ce61 : a01c             [ 2] 	ldy #FAT_FileSize			; Point to get size from
ce63 : 2098ce           [ 6] 	jsr fs_dir_util_copy		; Copy 4 bytes
ce66 : 2098ce           [ 6] 	jsr fs_dir_util_copy
ce69 : 2098ce           [ 6] 	jsr fs_dir_util_copy
ce6c : 2098ce           [ 6] 	jsr fs_dir_util_copy
                             	
ce6f :                       fs_dir_entry_attr
ce6f : a211             [ 2] 	ldx #FH_Attr				; Point to where attributes go
ce71 : a00b             [ 2] 	ldy #FAT_Attr				; Point from where to get attri
ce73 : 2098ce           [ 6] 	jsr fs_dir_util_copy		; Copy 1 byte
                             
ce76 :                       fs_dir_entry_clust
ce76 : a223             [ 2] 	ldx #FH_FirstClust
ce78 : a01a             [ 2] 	ldy	#FAT_FirstClust
ce7a : 2098ce           [ 6] 	jsr fs_dir_util_copy		; Copy 2 bytes
ce7d : 2098ce           [ 6] 	jsr fs_dir_util_copy
                             
                             	; Empty slot data goes here
ce80 :                       fs_dir_empty_slot
ce80 :                       fs_dir_entry_dirsect			; Directory sector in whic
ce80 : a203             [ 2] 	ldx #0x03
ce82 :                       fs_dir_copy_sd_sect
ce82 : b546             [ 4] 	lda sd_sect,x
ce84 : 9dae0b           [ 5] 	sta fh_dir+FH_DirSect,x
ce87 : ca               [ 2] 	dex
ce88 : 10f8             [ 3] 	bpl fs_dir_copy_sd_sect
                             	
ce8a :                       fs_dir_entry_diroffset			; Offset in to directory
ce8a : a544             [ 3] 	lda sd_slo
ce8c : 8db20b           [ 4] 	sta fh_dir+FH_DirOffset
ce8f : a545             [ 3] 	lda sd_shi
ce91 : 8db30b           [ 4] 	sta fh_dir+FH_DirOffset+1
                             	
ce94 : 7a               [ 4] 	ply
ce95 : fa               [ 4] 	plx
ce96 : 68               [ 4] 	pla
                             	
ce97 : 60               [ 6] 	rts
                             	
                             
                             ;****************************************
                             ;* fs_dir_util_copy
                             ;* Copy SD bytes to directory entry area
                             ;* Input 	: y = offset in to sd directory
                             ;*		 	: x = offset in to dir entry
                             ;* Output 	: None
                             ;* Regs affected : All
                             ;****************************************
ce98 :                       fs_dir_util_copy
ce98 : 48               [ 3] 	pha
AS65 Assembler for R6502 [1.42].                                     Page   64
-------------------------------- bank\bank2.s --------------------------------

ce99 : b144             [ 5] 	lda (sd_slo),y
ce9b : 9d910b           [ 5] 	sta fh_dir,x
ce9e : c8               [ 2] 	iny
ce9f : e8               [ 2] 	inx
cea0 : 68               [ 4] 	pla
cea1 : 60               [ 6] 	rts
                             
                             
                             
                             ;****************************************
                             ;* fs_get_next_cluster
                             ;* Given current cluster, find the next
                             ;* Input : fh_handle
                             ;* Output : 
                             ;* Regs affected : None
                             ;****************************************
cea2 :                       fs_get_next_cluster
cea2 : 48               [ 3] 	pha
cea3 : da               [ 3] 	phx
cea4 : 5a               [ 3] 	phy
                             
                             	; Get the FAT sector that current clust is in
cea5 : 20fbcf           [ 6] 	jsr fs_get_FAT_clust_sect
                             
                             	; Get next from this cluster index need low byte
                             	; as each FAT cluster contains 256 cluster entri
cea8 : a478             [ 3] 	ldy fh_handle+FH_CurrClust
                             	; X = Low byte, A = High byte of cluster
ceaa : 2080cd           [ 6] 	jsr fs_getword_sd_buf
                             	; Make this the current cluster
cead : 8678             [ 3] 	stx fh_handle+FH_CurrClust
ceaf : 8579             [ 3] 	sta fh_handle+FH_CurrClust+1
                             	
                             	; Calculate the sector address
ceb1 : 2032cf           [ 6] 	jsr fs_get_start_sect_data
ceb4 : a920             [ 2] 	lda #0x20					; 32 sector per cluster countdown	
ceb6 : 857a             [ 3] 	sta fh_handle+FH_SectCounter
                             
ceb8 : 7a               [ 4] 	ply
ceb9 : fa               [ 4] 	plx
ceba : 68               [ 4] 	pla
cebb : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* fs_IsEOF
                             ;* End of File check (compare file pointer to fil
                             ;* Input : fh_handle
                             ;* Output : 
                             ;* Regs affected : None
                             ;****************************************
cebc :                       fs_isEOF
cebc : 48               [ 3] 	pha
cebd : da               [ 3] 	phx
                             	
cebe : a203             [ 2] 	ldx #0x03
cec0 :                       fs_is_eof_cmp
cec0 : b57f             [ 4] 	lda fh_handle+FH_Pointer,x
cec2 : d573             [ 4] 	cmp fh_handle+FH_Size,x
cec4 : d007             [ 3] 	bne fs_notEOF
cec6 : ca               [ 2] 	dex
cec7 : 10f7             [ 3] 	bpl fs_is_eof_cmp
                             
AS65 Assembler for R6502 [1.42].                                     Page   65
-------------------------------- bank\bank2.s --------------------------------

cec9 : fa               [ 4] 	plx
ceca : 68               [ 4] 	pla
cecb : 38               [ 2] 	sec							; C = 1 for EOF
cecc : 60               [ 6] 	rts
                             
cecd :                       fs_notEOF	
cecd : fa               [ 4] 	plx
cece : 68               [ 4] 	pla
cecf : 18               [ 2] 	clc							; C = 0 for not EOF
ced0 : 60               [ 6] 	rts
                             
                             	
                             ;****************************************
                             ;* fs_inc_pointer
                             ;* Increment file point, loading sectors and clus
                             ;* This results in sd_buf containing the sector t
                             ;* Input : fh_handle
                             ;* Output : 
                             ;* Regs affected : None
                             ;****************************************
ced1 :                       fs_inc_pointer
ced1 : 48               [ 3] 	pha
ced2 : da               [ 3] 	phx
ced3 : 5a               [ 3] 	phy
                             	
                             	;Increment pointer
ced4 : a200             [ 2] 	ldx #0x00
ced6 : a004             [ 2] 	ldy #0x04
ced8 : 38               [ 2] 	sec									; Always adds 1 first
ced9 :                       fs_inc_fh_pointer
ced9 : b57f             [ 4] 	lda fh_handle+FH_Pointer,x
cedb : 6900             [ 2] 	adc #0x00
cedd : 957f             [ 4] 	sta fh_handle+FH_Pointer,x
cedf : e8               [ 2] 	inx
cee0 : 88               [ 2] 	dey
cee1 : d0f6             [ 3] 	bne fs_inc_fh_pointer
                             
cee3 : a57f             [ 3] 	lda fh_handle+FH_Pointer			; If low order == 0
cee5 : f004             [ 3] 	beq fs_inc_sector_ov				; Then sector 8 bits has
cee7 :                       fs_inc_fin
cee7 : 7a               [ 4] 	ply
cee8 : fa               [ 4] 	plx
cee9 : 68               [ 4] 	pla
                             	
ceea : 60               [ 6] 	rts
ceeb :                       fs_inc_sector_ov						; Check if sector bit 8 has
ceeb : a580             [ 3] 	lda fh_handle+FH_Pointer+1			; Load up next high
ceed : 2901             [ 2] 	and #1								; If bit zero = 0 then must have
ceef : d0f6             [ 3] 	bne fs_inc_fin						; overflowed.
                             	;Sector change required
cef1 : a200             [ 2] 	ldx #0x00
cef3 : a004             [ 2] 	ldy #0x04
cef5 : 38               [ 2] 	sec									; Always adds 1 first
cef6 :                       fs_inc_fh_sect
cef6 : b57b             [ 4] 	lda fh_handle+FH_CurrSec,x
cef8 : 6900             [ 2] 	adc #0x00
cefa : 957b             [ 4] 	sta fh_handle+FH_CurrSec,x
cefc : e8               [ 2] 	inx
cefd : 88               [ 2] 	dey
cefe : d0f6             [ 3] 	bne fs_inc_fh_sect
cf00 :                       fs_inc_skip_sec_wrap
cf00 : c67a             [ 5] 	dec fh_handle+FH_SectCounter		; If reached the e
AS65 Assembler for R6502 [1.42].                                     Page   66
-------------------------------- bank\bank2.s --------------------------------

cf02 : d003             [ 3] 	bne fs_inc_load_sector				; Then get next cluste
                             	; Cluster change required
cf04 : 20a2ce           [ 6] 	jsr fs_get_next_cluster				; Get next cluster ba
cf07 :                       fs_inc_load_sector
cf07 : 20bcce           [ 6] 	jsr fs_isEOF						; Check not EOF
cf0a : b003             [ 3] 	bcs fs_skip_load_sect				; if so then don't load
cf0c : 2062cf           [ 6] 	jsr fs_load_curr_sect				; Load the sector
cf0f :                       fs_skip_load_sect
cf0f : 7a               [ 4] 	ply
cf10 : fa               [ 4] 	plx
cf11 : 68               [ 4] 	pla
cf12 : 60               [ 6] 	rts
                             
                             
                             	
                             ;****************************************
                             ;* fs_get_next_byte
                             ;* Get a byte
                             ;* Input : fh_handle
                             ;* Output : A = char, C = 1 (EOF)
                             ;* Regs affected : None
                             ;****************************************
cf13 :                       fs_get_next_byte
cf13 : da               [ 3] 	phx
cf14 : 5a               [ 3] 	phy
                             
cf15 : 20bcce           [ 6] 	jsr fs_isEOF						; If at EOF then error
cf18 : 9008             [ 3] 	bcc fs_get_skip_EOF
                             
cf1a : a901             [ 2] 	lda #FS_ERR_EOF
cf1c : 85a6             [ 3] 	sta errno
cf1e : 38               [ 2] 	sec
cf1f : 7a               [ 4] 	ply
cf20 : fa               [ 4] 	plx
cf21 : 60               [ 6] 	rts
                             
cf22 :                       fs_get_skip_EOF
cf22 : a67f             [ 3] 	ldx fh_handle+FH_Pointer			; Low 8 bits of secto
cf24 : a480             [ 3] 	ldy fh_handle+FH_Pointer+1			; Which half of sec
                             	; A=SD buffer byte
cf26 : 2063cd           [ 6] 	jsr fs_getbyte_sd_buf
cf29 : 20d1ce           [ 6] 	jsr fs_inc_pointer					; Increment file pointers
                             
cf2c : 18               [ 2] 	clc									; No error
cf2d : 64a6             [ 3] 	stz errno
cf2f : 7a               [ 4] 	ply
cf30 : fa               [ 4] 	plx
cf31 : 60               [ 6] 	rts
                             	
                             
                             
                             ;****************************************
                             ; Find the sector given the data cluster
                             ; Given clust in LoX,HiA
                             ; Outputs to fh_handle->FH_CurrSec
                             ;****************************************
cf32 :                       fs_get_start_sect_data
cf32 : 48               [ 3] 	pha
cf33 : da               [ 3] 	phx
cf34 : 5a               [ 3] 	phy
                             	
cf35 : 8678             [ 3] 	stx fh_handle+FH_CurrClust
AS65 Assembler for R6502 [1.42].                                     Page   67
-------------------------------- bank\bank2.s --------------------------------

cf37 : 8579             [ 3] 	sta fh_handle+FH_CurrClust+1
                             	
                             	; Initialise to input sector
cf39 : 867b             [ 3] 	stx fh_handle+FH_CurrSec+0
cf3b : 857c             [ 3] 	sta fh_handle+FH_CurrSec+1
cf3d : 647d             [ 3] 	stz fh_handle+FH_CurrSec+2
cf3f : 647e             [ 3] 	stz fh_handle+FH_CurrSec+3
                             	
                             	; Sector = Cluster * 32
                             	; Shift left 5 times
cf41 : a005             [ 2] 	ldy #5
cf43 :                       fs_get_data_sect_m5
cf43 : 18               [ 2] 	clc
cf44 : 067b             [ 5] 	asl fh_handle+FH_CurrSec+0
cf46 : 267c             [ 5] 	rol fh_handle+FH_CurrSec+1
cf48 : 267d             [ 5] 	rol fh_handle+FH_CurrSec+2
cf4a : 267e             [ 5] 	rol fh_handle+FH_CurrSec+3
cf4c : 88               [ 2] 	dey
cf4d : d0f4             [ 3] 	bne fs_get_data_sect_m5
                             
                             	; Add data sector offset
cf4f : a200             [ 2] 	ldx #0x00
cf51 : a004             [ 2] 	ldy #0x04
cf53 : 18               [ 2] 	clc
cf54 :                       fs_get_start_data
cf54 : b57b             [ 4] 	lda fh_handle+FH_CurrSec,x
cf56 : 755a             [ 4] 	adc fs_datasect,x
cf58 : 957b             [ 4] 	sta fh_handle+FH_CurrSec,x
cf5a : e8               [ 2] 	inx
cf5b : 88               [ 2] 	dey
cf5c : d0f6             [ 3] 	bne fs_get_start_data
                             
cf5e : 7a               [ 4] 	ply
cf5f : fa               [ 4] 	plx
cf60 : 68               [ 4] 	pla
cf61 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ; Load the current sector in FH
                             ;****************************************
cf62 :                       fs_load_curr_sect
cf62 : 48               [ 3] 	pha
cf63 : da               [ 3] 	phx
                             
cf64 : a203             [ 2] 	ldx #0x03
cf66 :                       fs_load_cpy_sect
cf66 : b57b             [ 4] 	lda fh_handle+FH_CurrSec,x
cf68 : 9546             [ 4] 	sta sd_sect,x
cf6a : ca               [ 2] 	dex
cf6b : 10f9             [ 3] 	bpl fs_load_cpy_sect
cf6d : a902             [ 2] 	lda #hi(sd_buf)
cf6f : 20b2cb           [ 6] 	jsr sd_sendcmd17
                             
cf72 : fa               [ 4] 	plx
cf73 : 68               [ 4] 	pla
cf74 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ; Flush the current sector
                             ;****************************************
cf75 :                       fs_flush_curr_sect
cf75 : 48               [ 3] 	pha
AS65 Assembler for R6502 [1.42].                                     Page   68
-------------------------------- bank\bank2.s --------------------------------

cf76 : da               [ 3] 	phx
                             
cf77 : a203             [ 2] 	ldx #0x03
cf79 :                       fs_flush_cpy_sect
cf79 : b57b             [ 4] 	lda fh_handle+FH_CurrSec,x
cf7b : 9546             [ 4] 	sta sd_sect,x
cf7d : ca               [ 2] 	dex
cf7e : 10f9             [ 3] 	bpl fs_flush_cpy_sect
cf80 : a902             [ 2] 	lda #hi(sd_buf)				; Sending data in sd_buf
cf82 : 2027cc           [ 6] 	jsr sd_sendcmd24
                             	
cf85 : fa               [ 4] 	plx
cf86 : 68               [ 4] 	pla
cf87 : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* fs_copy_dir_to_fh
                             ;* Copy directory entry (fh) to file handle
                             ;* Input : fh_dir contains directory entry
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
cf88 :                       fs_copy_dir_to_fh
cf88 : 48               [ 3] 	pha
cf89 : da               [ 3] 	phx
cf8a : a200             [ 2] 	ldx #FH_Name			; By default copy all
cf8c : 9002             [ 3] 	bcc fs_copy_dir_to_fh_byte
cf8e : a20d             [ 2] 	ldx #FH_Size			; But skip name if new file
cf90 :                       fs_copy_dir_to_fh_byte
cf90 : bd910b           [ 4] 	lda fh_dir,x
cf93 : 9566             [ 4] 	sta fh_handle,x
cf95 : e8               [ 2] 	inx
cf96 : e028             [ 2] 	cpx #FileHandle
cf98 : d0f6             [ 3] 	bne fs_copy_dir_to_fh_byte
cf9a : fa               [ 4] 	plx
cf9b : 68               [ 4] 	pla
cf9c : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* fs_find_empty_clust
                             ;* Find an empty cluster to write to
                             ;* Input : None
                             ;* Output : fh_handle->FH_CurrClust is the empty 
                             ;* Regs affected : None
                             ;****************************************
cf9d :                       fs_find_empty_clust
cf9d : 48               [ 3] 	pha
cf9e : da               [ 3] 	phx
cf9f : 5a               [ 3] 	phy
                             
                             	; Starting at cluster 0x0002
cfa0 : a902             [ 2] 	lda #02
cfa2 : 8578             [ 3] 	sta fh_handle+FH_CurrClust
cfa4 : 6479             [ 3] 	stz fh_handle+FH_CurrClust+1
                             
                             	
                             	; Start at the first FAT sector
cfa6 : a203             [ 2] 	ldx #0x03
cfa8 :                       fs_find_init_fat
cfa8 : b552             [ 4] 	lda fs_fatsect,x
cfaa : 957b             [ 4] 	sta fh_handle+FH_CurrSec,x
AS65 Assembler for R6502 [1.42].                                     Page   69
-------------------------------- bank\bank2.s --------------------------------

cfac : ca               [ 2] 	dex
cfad : 10f9             [ 3] 	bpl fs_find_init_fat
                             
                             	; There is only enough room for 512/2 = 256 clus
                             	; There are 256 sectors of FAT entries
                             
cfaf :                       fs_check_empty_sector
cfaf : 2062cf           [ 6] 	jsr fs_load_curr_sect			; Load a FAT sector
cfb2 :                       fs_check_curr_clust
cfb2 : a478             [ 3] 	ldy fh_handle+FH_CurrClust		; Index in to this F
cfb4 : 2080cd           [ 6] 	jsr fs_getword_sd_buf
cfb7 : e000             [ 2] 	cpx #0
cfb9 : d01b             [ 3] 	bne fs_next_fat_entry
cfbb : c900             [ 2] 	cmp #0
cfbd : d017             [ 3] 	bne fs_next_fat_entry
                             	
                             	; If got here then empty cluster found
                             	; fh_handle->FH_CurrClust is the empty cluster
                             	
                             	; Mark this cluster as used
cfbf : a2ff             [ 2] 	ldx #0xff
cfc1 : a9ff             [ 2] 	lda #0xff
cfc3 : 2093cd           [ 6] 	jsr fs_putword_sd_buf
                             
                             	; flush this FAT entry back so this cluster is s
cfc6 : 2075cf           [ 6] 	jsr fs_flush_curr_sect
                             	
cfc9 : 647a             [ 3] 	stz fh_handle+FH_SectCounter	; Zero the sector c
cfcb : a678             [ 3] 	ldx fh_handle+FH_CurrClust
cfcd : a579             [ 3] 	lda fh_handle+FH_CurrClust+1
cfcf : 2032cf           [ 6] 	jsr fs_get_start_sect_data		; Initialise the sec
cfd2 : 7a               [ 4] 	ply
cfd3 : fa               [ 4] 	plx
cfd4 : 68               [ 4] 	pla
cfd5 : 60               [ 6] 	rts
                             	; If got here then need to find another cluster
cfd6 :                       fs_next_fat_entry
                             	_incZPWord fh_handle+FH_CurrClust	; Increment th
                             
                             	; Only 256 FAT entries in a sector of 512 bytes
cfdc : a578             [ 3] 	lda fh_handle+FH_CurrClust		; Check low byte of 
cfde : d0d2             [ 3] 	bne fs_check_curr_clust			; Else keep checking c
                             	; Every 256 FAT entries, need to get a new FAT s
cfe0 :                       fs_next_fat_sect
cfe0 : 20e5cf           [ 6] 	jsr fs_inc_curr_sec				; Increment to the next F
cfe3 : 80ca             [ 3] 	bra fs_check_empty_sector		; Go an load the new 
                             	
                             
                             ;****************************************
                             ;* fs_inc_curr_sec
                             ;* Increment sector by 1
                             ;* Input : fh_handle has the sector
                             ;****************************************
cfe5 :                       fs_inc_curr_sec
cfe5 : 48               [ 3] 	pha
cfe6 : da               [ 3] 	phx
cfe7 : 5a               [ 3] 	phy
                             	
                             	; add 1 to LSB as sector address is little endia
cfe8 : a200             [ 2] 	ldx #0x00
cfea : a004             [ 2] 	ldy #0x04
cfec : 38               [ 2] 	sec
AS65 Assembler for R6502 [1.42].                                     Page   70
-------------------------------- bank\bank2.s --------------------------------

cfed :                       fs_inc_sec_byte
cfed : b57b             [ 4] 	lda fh_handle+FH_CurrSec,x
cfef : 6900             [ 2] 	adc #0x00
cff1 : 957b             [ 4] 	sta fh_handle+FH_CurrSec,x
cff3 : e8               [ 2] 	inx
cff4 : 88               [ 2] 	dey
cff5 : d0f6             [ 3] 	bne fs_inc_sec_byte
                             
cff7 : 7a               [ 4] 	ply
cff8 : fa               [ 4] 	plx
cff9 : 68               [ 4] 	pla
cffa : 60               [ 6] 	rts
                             	
                             
                             ;****************************************
                             ;* fs_get_FAT_clust_sect
                             ;* Given FH_CurrClust, set FH_CurrSec so that
                             ;* the sector contains the FAT entry
                             ;* Input : fh_handle has the details
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
cffb :                       fs_get_FAT_clust_sect
cffb : 48               [ 3] 	pha
cffc : da               [ 3] 	phx
cffd : 5a               [ 3] 	phy
                             	
                             	; Sector offset in to FAT = high byte
                             	; because a sector can hold 256 FAT entries
cffe : a579             [ 3] 	lda fh_handle+FH_CurrClust+1
d000 : 857b             [ 3] 	sta fh_handle+FH_CurrSec
d002 : 647c             [ 3] 	stz fh_handle+FH_CurrSec+1
d004 : 647d             [ 3] 	stz fh_handle+FH_CurrSec+2
d006 : 647e             [ 3] 	stz fh_handle+FH_CurrSec+3
                             	
                             	; Add the FAT offset
d008 : 18               [ 2] 	clc
d009 : a200             [ 2] 	ldx #0x00
d00b : a004             [ 2] 	ldy #0x04
d00d :                       fs_get_add_fat
d00d : b57b             [ 4] 	lda fh_handle+FH_CurrSec,x
d00f : 7552             [ 4] 	adc fs_fatsect,x
d011 : 957b             [ 4] 	sta fh_handle+FH_CurrSec,x
d013 : e8               [ 2] 	inx
d014 : 88               [ 2] 	dey
d015 : d0f6             [ 3] 	bne fs_get_add_fat
                             
                             	; Now load the sector containing this cluster en
d017 : 2062cf           [ 6] 	jsr fs_load_curr_sect
                             
d01a : 7a               [ 4] 	ply
d01b : fa               [ 4] 	plx
d01c : 68               [ 4] 	pla
d01d : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* fs_update_FAT_entry
                             ;* FH_LastClust updated with FH_CurrClust
                             ;* Input : fh_handle has the details
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
AS65 Assembler for R6502 [1.42].                                     Page   71
-------------------------------- bank\bank2.s --------------------------------

d01e :                       fs_update_FAT_entry
d01e : 48               [ 3] 	pha
d01f : da               [ 3] 	phx
d020 : 5a               [ 3] 	phy
                             	
d021 : a578             [ 3] 	lda fh_handle+FH_CurrClust+0	; Save current clus
d023 : 48               [ 3] 	pha
d024 : a579             [ 3] 	lda fh_handle+FH_CurrClust+1	; Save current clus
d026 : 48               [ 3] 	pha
                             	; Move back to the last cluster entry
                             	_cpyZPWord fh_handle+FH_LastClust,fh_handle+FH_C
                             
                             
d02f : 20fbcf           [ 6] 	jsr fs_get_FAT_clust_sect		; Get the FAT sector 
                             	; Index in to the FAT sector
d032 : a48b             [ 3] 	ldy fh_handle+FH_LastClust
                             	; Get current cluster hi,lo from stack
d034 : 68               [ 4] 	pla
d035 : fa               [ 4] 	plx
                             	; Update FAT entry Y with cluster X,A
d036 : 2093cd           [ 6] 	jsr fs_putword_sd_buf
                             
                             	; The appropriate FAT sector has been updated
                             	; Now flush that sector back	
d039 : 2075cf           [ 6] 	jsr fs_flush_curr_sect
                             	
                             	; And restore the current cluster
d03c : 8678             [ 3] 	stx fh_handle+FH_CurrClust		; Make it the curren
d03e : 8579             [ 3] 	sta fh_handle+FH_CurrClust+1	; Make it the curre
                             	
d040 : 7a               [ 4] 	ply
d041 : fa               [ 4] 	plx
d042 : 68               [ 4] 	pla
d043 : 60               [ 6] 	rts
                             	
                             
                             ;****************************************
                             ;* fs_put_byte
                             ;* Put out a byte, incrementing size
                             ;* and committing clusters as necessary
                             ;* including reflecting this in the FAT table
                             ;* Input : fh_handle has the details, A = Byte to
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
d044 :                       fs_put_byte
d044 : da               [ 3] 	phx
d045 : 5a               [ 3] 	phy
d046 : 48               [ 3] 	pha
                             
                             	; Before writing a byte, need to check if the cu
                             	; sector is full.
                             	; Check low 9 bits of size and if zero size (i.e
d047 : a573             [ 3] 	lda fh_handle+FH_Size
d049 : d024             [ 3] 	bne fs_put_do_put
d04b : a574             [ 3] 	lda fh_handle+FH_Size+1
d04d : f020             [ 3] 	beq fs_put_do_put
d04f : 2901             [ 2] 	and #1
d051 : d01c             [ 3] 	bne fs_put_do_put
                             
                             	; We need to flush this sector to disk
d053 : 2075cf           [ 6] 	jsr fs_flush_curr_sect
AS65 Assembler for R6502 [1.42].                                     Page   72
-------------------------------- bank\bank2.s --------------------------------

                             	; Move to next sector in the cluster
d056 : 20e5cf           [ 6] 	jsr fs_inc_curr_sec
                             	; Bump the sector counter
d059 : e67a             [ 5] 	inc fh_handle+FH_SectCounter
                             	; Check if counter at sectors per cluster limit
d05b : a57a             [ 3] 	lda fh_handle+FH_SectCounter
d05d : c920             [ 2] 	cmp #0x20
d05f : d00e             [ 3] 	bne fs_put_do_put
                             	; We need to find a new cluster now
                             	; But first update the FAT chain
                             	; so that the last cluster points to this
d061 : 201ed0           [ 6] 	jsr fs_update_FAT_entry
                             	; Before finding a new cluster
                             	; make the current the last
                             	_cpyZPWord fh_handle+FH_CurrClust,fh_handle+FH_L
                             
                             	; Go find a new empty clust
                             	; starts at sector 0
d06c : 209dcf           [ 6] 	jsr fs_find_empty_clust
                             	; Finally, can write a byte to the
                             	; SD buffer in memory
d06f :                       fs_put_do_put	
d06f : a673             [ 3] 	ldx fh_handle+FH_Size			; Load size low as index
d071 : a474             [ 3] 	ldy fh_handle+FH_Size+1			; Check which half
d073 : 68               [ 4] 	pla								; Get A off stack and put back
d074 : 48               [ 3] 	pha
d075 : 2070cd           [ 6] 	jsr fs_putbyte_sd_buf
d078 :                       fs_put_inc_size
d078 : 38               [ 2] 	sec
d079 : a200             [ 2] 	ldx #0x00
d07b : a004             [ 2] 	ldy #0x04
d07d :                       fs_put_inc_size_byte
d07d : b573             [ 4] 	lda fh_handle+FH_Size,x
d07f : 6900             [ 2] 	adc #0
d081 : 9573             [ 4] 	sta fh_handle+FH_Size,x
d083 : e8               [ 2] 	inx
d084 : 88               [ 2] 	dey
d085 : d0f6             [ 3] 	bne fs_put_inc_size_byte
d087 :                       fs_put_fin
d087 : 68               [ 4] 	pla
d088 : 7a               [ 4] 	ply
d089 : fa               [ 4] 	plx
d08a : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* fs_dir_save_entry
                             ;* Save dir entry back to disk
                             ;* Input : fh_handle has all the details
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
d08b :                       fs_dir_save_entry
d08b : 48               [ 3] 	pha
d08c : da               [ 3] 	phx
d08d : 5a               [ 3] 	phy
                             
                             	; Retrieve the sector where the file entry goes
d08e : a203             [ 2] 	ldx #0x03
d090 :                       fs_dir_curr_sect
d090 : b583             [ 4] 	lda fh_handle+FH_DirSect,x
d092 : 957b             [ 4] 	sta fh_handle+FH_CurrSec,x
d094 : ca               [ 2] 	dex
AS65 Assembler for R6502 [1.42].                                     Page   73
-------------------------------- bank\bank2.s --------------------------------

d095 : 10f9             [ 3] 	bpl fs_dir_curr_sect
                             	
d097 : 2062cf           [ 6] 	jsr fs_load_curr_sect
                             
                             	; Restore index in to the correct entry
d09a : a587             [ 3] 	lda fh_handle+FH_DirOffset
d09c : 8544             [ 3] 	sta sd_slo
d09e : a588             [ 3] 	lda fh_handle+FH_DirOffset+1
d0a0 : 8545             [ 3] 	sta sd_shi
                             	
                             	;Save the filename
d0a2 : a200             [ 2] 	ldx #FH_Name				; Point to where name will go
d0a4 : a000             [ 2] 	ldy #FAT_Name
d0a6 :                       fs_dir_save_name_ch
d0a6 : b566             [ 4] 	lda fh_handle,x				; Get a char
d0a8 : f011             [ 3] 	beq fs_dir_name_done		; If zero then name done
d0aa : c92e             [ 2] 	cmp #'.'					; Is it '.'
d0ac : d003             [ 3] 	bne fs_dir_name_skip		; If so then don't conside
d0ae : e8               [ 2] 	inx							; Jump over '.'
d0af : 800a             [ 3] 	bra fs_dir_name_done		; and start processing the
d0b1 :                       fs_dir_name_skip
d0b1 : c008             [ 2] 	cpy #FAT_Ext				; Reached the end of the name?
d0b3 : f006             [ 3] 	beq fs_dir_name_done
d0b5 : 9144             [ 5] 	sta (sd_slo),y				; No, so store the byte in nam
d0b7 : e8               [ 2] 	inx
d0b8 : c8               [ 2] 	iny
d0b9 : 80eb             [ 3] 	bra fs_dir_save_name_ch
d0bb :                       fs_dir_name_done
                             	
d0bb : a920             [ 2] 	lda #' '					; Pad name with spaces
d0bd :                       fs_dir_pad_name
d0bd : c008             [ 2] 	cpy #FAT_Ext				; Padded enough?
d0bf : f005             [ 3] 	beq fs_dir_pad_name_done
d0c1 : 9144             [ 5] 	sta (sd_slo),y				; Fill with space
d0c3 : c8               [ 2] 	iny
d0c4 : 80f7             [ 3] 	bra fs_dir_pad_name
d0c6 :                       fs_dir_pad_name_done
                             	
d0c6 :                       fs_dir_save_ext_ch
d0c6 : c00b             [ 2] 	cpy #FAT_Attr				; End of extension?
d0c8 : f00a             [ 3] 	beq fs_dir_ext_done
d0ca : b566             [ 4] 	lda fh_handle,x				; Get a char
d0cc : f006             [ 3] 	beq fs_dir_ext_done			; If zero then name done
d0ce : 9144             [ 5] 	sta (sd_slo),y
d0d0 : e8               [ 2] 	inx
d0d1 : c8               [ 2] 	iny
d0d2 : 80f2             [ 3] 	bra fs_dir_save_ext_ch	
d0d4 :                       fs_dir_ext_done
                             	
d0d4 : a920             [ 2] 	lda #' '					; Pad out any remaining with space
d0d6 :                       fs_dir_ext_pad
d0d6 : c00b             [ 2] 	cpy #FAT_Attr				; Reached the end of the extens
d0d8 : f005             [ 3] 	beq fs_dir_ext_pad_done
d0da : 9144             [ 5] 	sta (sd_slo),y
d0dc : c8               [ 2] 	iny
d0dd : 80f7             [ 3] 	bra fs_dir_ext_pad
                             	; At the Attribute byte, zero out everything unt
d0df :                       fs_dir_ext_pad_done
                             	
d0df : a900             [ 2] 	lda #0
d0e1 :                       fs_dir_save_rest_ch
d0e1 : 9144             [ 5] 	sta (sd_slo),y
AS65 Assembler for R6502 [1.42].                                     Page   74
-------------------------------- bank\bank2.s --------------------------------

d0e3 : c8               [ 2] 	iny
d0e4 : c01a             [ 2] 	cpy #FAT_FirstClust
d0e6 : d0f9             [ 3] 	bne fs_dir_save_rest_ch
                             	; Now save first cluster
d0e8 : a589             [ 3] 	lda fh_handle+FH_FirstClust
d0ea : 9144             [ 5] 	sta (sd_slo),y
d0ec : c8               [ 2] 	iny
d0ed : a58a             [ 3] 	lda fh_handle+FH_FirstClust+1
d0ef : 9144             [ 5] 	sta (sd_slo),y
d0f1 : c8               [ 2] 	iny
                             
                             	; Now save size
d0f2 : a200             [ 2] 	ldx #0
d0f4 :                       df_dir_save_size_ch
d0f4 : b573             [ 4] 	lda fh_handle+FH_Size,x
d0f6 : 9144             [ 5] 	sta (sd_slo),y
d0f8 : c8               [ 2] 	iny
d0f9 : e8               [ 2] 	inx
d0fa : e004             [ 2] 	cpx #4
d0fc : d0f6             [ 3] 	bne df_dir_save_size_ch
                             
                             	; Ok done copying data to directory entry
                             	; Now flush this back to disk
                             	
d0fe : 2075cf           [ 6] 	jsr fs_flush_curr_sect
                             	
                             	; Phew we are done
d101 : 7a               [ 4] 	ply
d102 : fa               [ 4] 	plx
d103 : 68               [ 4] 	pla
d104 : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* fs_util_find
                             ;* Find a file in current directory
                             ;* Input : fh_handle has the name
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
d105 :                       fs_util_find
d105 : 48               [ 3] 	pha
d106 : da               [ 3] 	phx
d107 : 5a               [ 3] 	phy
                             
d108 : 20abcd           [ 6] 	jsr fs_dir_root_start		; Start at root
d10b :                       fs_util_find_entry
d10b : 18               [ 2] 	clc							; Only look for active files
d10c : 20c4cd           [ 6] 	jsr fs_dir_find_entry		; Find a valid entry
d10f : b011             [ 3] 	bcs	fs_util_not_found		; If C then no more entri
d111 : a200             [ 2] 	ldx #0						; Check name matches
d113 :                       fs_util_check_name
d113 : b566             [ 4] 	lda fh_handle,x
d115 : dd910b           [ 4] 	cmp fh_dir,x
d118 : d0f1             [ 3] 	bne fs_util_find_entry
d11a : c900             [ 2] 	cmp #0						; If no more bytes in name to check
d11c : f003             [ 3] 	beq fs_util_found
d11e : e8               [ 2] 	inx
d11f : 80f2             [ 3] 	bra fs_util_check_name
d121 :                       fs_util_found
d121 : 18               [ 2] 	clc							; C=0 file found
d122 :                       fs_util_not_found				; If C already set then not 
AS65 Assembler for R6502 [1.42].                                     Page   75
-------------------------------- bank\bank2.s --------------------------------

d122 : 7a               [ 4] 	ply
d123 : fa               [ 4] 	plx
d124 : 68               [ 4] 	pla
d125 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* fs_open_read
                             ;* Open a file for reading
                             ;* Input : fh_handle has the name
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
d126 :                       fs_open_read
d126 : 48               [ 3] 	pha
d127 : da               [ 3] 	phx
d128 : 5a               [ 3] 	phy
                             
d129 : 2005d1           [ 6] 	jsr fs_util_find			; Try to find the file
d12c : b01d             [ 3] 	bcs fs_open_not_found		; C=1 not found
d12e :                       fs_open_found
d12e : 2088cf           [ 6] 	jsr fs_copy_dir_to_fh		; Put entry in to fh_hand
                             
d131 : a920             [ 2] 	lda #0x20					; 32 sector per cluster countdown	
d133 : 857a             [ 3] 	sta fh_handle+FH_SectCounter
                             
d135 : a689             [ 3] 	ldx fh_handle+FH_FirstClust	; Load up first clus
d137 : a58a             [ 3] 	lda fh_handle+FH_FirstClust+1
                             
d139 : 2032cf           [ 6] 	jsr fs_get_start_sect_data	; Calc the first sect
d13c : 2062cf           [ 6] 	jsr fs_load_curr_sect		; Load it in to sd_buf
                             
                             
d13f : a203             [ 2] 	ldx #0x03					; Initialise pointer to beginning
d141 :                       fs_open_init_pointer
d141 : 747f             [ 4] 	stz fh_handle+FH_Pointer,x
d143 : ca               [ 2] 	dex
d144 : 10fb             [ 3] 	bpl fs_open_init_pointer
                             
                             	; Set file mode to read
d146 : a900             [ 2] 	lda #0x00
d148 : 858d             [ 3] 	sta fh_handle+FH_FileMode
                             
d14a : 18               [ 2] 	clc
d14b :                       fs_open_not_found
d14b : 7a               [ 4] 	ply
d14c : fa               [ 4] 	plx
d14d : 68               [ 4] 	pla
d14e : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* fs_open_write
                             ;* Open a file for writing
                             ;* Input : fh_handle has the name
                             ;*		 : existing file will overwritten
                             ;*		 : new file will be created
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
d14f :                       fs_open_write
d14f : 48               [ 3] 	pha
d150 : da               [ 3] 	phx
AS65 Assembler for R6502 [1.42].                                     Page   76
-------------------------------- bank\bank2.s --------------------------------

d151 : 5a               [ 3] 	phy
                             
                             	; try and delete any file with the same name fir
d152 : a566             [ 3] 	lda fh_handle+FH_Name		; save first char as it g
d154 : 48               [ 3] 	pha
d155 : 20a9d1           [ 6] 	jsr fs_delete				; now delete it
d158 : 68               [ 4] 	pla							; restore first char
d159 : 8566             [ 3] 	sta fh_handle+FH_Name
d15b : 20abcd           [ 6] 	jsr fs_dir_root_start		; Start at root
d15e : 38               [ 2] 	sec							; Find an empty file entry
d15f : 20c4cd           [ 6] 	jsr fs_dir_find_entry		; Find a valid entry
d162 : b020             [ 3] 	bcs	fs_open_write_fin		; Error, didn't find!
d164 : 38               [ 2] 	sec
d165 : 2088cf           [ 6] 	jsr fs_copy_dir_to_fh		; Copy entry to file hand
                             
d168 : 6473             [ 3] 	stz fh_handle+FH_Size+0		; Size is zero initiall
d16a : 6474             [ 3] 	stz fh_handle+FH_Size+1
d16c : 6475             [ 3] 	stz fh_handle+FH_Size+2
d16e : 6476             [ 3] 	stz fh_handle+FH_Size+3
                             
d170 : 209dcf           [ 6] 	jsr fs_find_empty_clust		; Where will be the fir
                             
                             	; Set current, last and first cluster
d173 : a578             [ 3] 	lda fh_handle+FH_CurrClust
d175 : 8589             [ 3] 	sta fh_handle+FH_FirstClust
d177 : 858b             [ 3] 	sta fh_handle+FH_LastClust
d179 : a579             [ 3] 	lda fh_handle+FH_CurrClust+1
d17b : 858a             [ 3] 	sta fh_handle+FH_FirstClust+1
d17d : 858c             [ 3] 	sta fh_handle+FH_LastClust+1
                             
                             	; Set file mode to write
d17f : a9ff             [ 2] 	lda #0xff
d181 : 858d             [ 3] 	sta fh_handle+FH_FileMode
                             
d183 : 18               [ 2] 	clc
d184 :                       fs_open_write_fin
d184 : 7a               [ 4] 	ply
d185 : fa               [ 4] 	plx
d186 : 68               [ 4] 	pla
d187 : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* fs_close
                             ;* Close a file, only important for new files
                             ;* Input : fh_handle details
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
d188 :                       fs_close
d188 : 48               [ 3] 	pha
                             
                             	; Only need to close down stuff in write mode
d189 : a58d             [ 3] 	lda fh_handle+FH_FileMode
d18b : f01a             [ 3] 	beq fs_close_done
                             	
                             	; Flush the current sector
d18d : 2075cf           [ 6] 	jsr fs_flush_curr_sect
                             
                             	; Update the chain from the last cluster
d190 : 201ed0           [ 6] 	jsr fs_update_FAT_entry
                             
AS65 Assembler for R6502 [1.42].                                     Page   77
-------------------------------- bank\bank2.s --------------------------------

                             	; Make current sector = last
d193 : a578             [ 3] 	lda fh_handle+FH_CurrClust
d195 : 858b             [ 3] 	sta fh_handle+FH_LastClust
d197 : a579             [ 3] 	lda fh_handle+FH_CurrClust+1
d199 : 858c             [ 3] 	sta fh_handle+FH_LastClust+1
                             	; Need to update the FAT entry
                             	; to show this cluster is last
d19b : a9ff             [ 2] 	lda #0xff
d19d : 8578             [ 3] 	sta fh_handle+FH_CurrClust
d19f : 8579             [ 3] 	sta fh_handle+FH_CurrClust+1
                             	; Now update the FAT entry to mark the last clus
                             
d1a1 : 201ed0           [ 6] 	jsr fs_update_FAT_entry
                             
d1a4 : 208bd0           [ 6] 	jsr fs_dir_save_entry
                             
d1a7 :                       fs_close_done
d1a7 : 68               [ 4] 	pla
d1a8 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* fs_delete
                             ;* Delete a file
                             ;* Input : fh_handle has the name
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
d1a9 :                       fs_delete
d1a9 : 48               [ 3] 	pha
d1aa : da               [ 3] 	phx
d1ab : 5a               [ 3] 	phy
                             
d1ac : 2026d1           [ 6] 	jsr fs_open_read			; Try and open the file
d1af : b02e             [ 3] 	bcs fs_delete_fin			; If not found then fin
                             	
                             	; Mark first char with deleted indicator
d1b1 : a9e5             [ 2] 	lda #0xe5
d1b3 : 8566             [ 3] 	sta fh_handle+FH_Name
                             
                             	; Save this back to directory table
d1b5 : 208bd0           [ 6] 	jsr fs_dir_save_entry
                             
                             	; Now mark all related clusters as free
d1b8 : a689             [ 3] 	ldx fh_handle+FH_FirstClust
d1ba : 8678             [ 3] 	stx fh_handle+FH_CurrClust
d1bc : a48a             [ 3] 	ldy fh_handle+FH_FirstClust+1
d1be : 8479             [ 3] 	sty fh_handle+FH_CurrClust+1
d1c0 :                       fs_delete_clust
                             	; X and Y always contain current cluster
                             	; Make last = current
d1c0 : 868b             [ 3] 	stx fh_handle+FH_LastClust
d1c2 : 848c             [ 3] 	sty fh_handle+FH_LastClust+1
                             
                             	; Given current cluster, find next
                             	; save in X,Y
d1c4 : 20a2ce           [ 6] 	jsr fs_get_next_cluster
                             	; load X,Y with the next cluster
d1c7 : a678             [ 3] 	ldx fh_handle+FH_CurrClust
d1c9 : a479             [ 3] 	ldy fh_handle+FH_CurrClust+1
                             	
                             	; Zero out the cluster number
d1cb : 6478             [ 3] 	stz fh_handle+FH_CurrClust
AS65 Assembler for R6502 [1.42].                                     Page   78
-------------------------------- bank\bank2.s --------------------------------

d1cd : 6479             [ 3] 	stz fh_handle+FH_CurrClust+1
                             
                             	; Update FAT entry of Last Cluster with zero
d1cf : 201ed0           [ 6] 	jsr fs_update_FAT_entry
                             
                             	; Restore the next cluster found earlier
d1d2 : 8678             [ 3] 	stx fh_handle+FH_CurrClust
d1d4 : 8479             [ 3] 	sty fh_handle+FH_CurrClust+1
                             
                             	; If the next cluster is not 0xffff
                             	; then continue
d1d6 : e0ff             [ 2] 	cpx #0xff
d1d8 : d0e6             [ 3] 	bne fs_delete_clust
d1da : c0ff             [ 2] 	cpy #0xff
d1dc : d0e2             [ 3] 	bne fs_delete_clust
d1de : 18               [ 2] 	clc
d1df :                       fs_delete_fin
d1df : 7a               [ 4] 	ply
d1e0 : fa               [ 4] 	plx
d1e1 : 68               [ 4] 	pla
d1e2 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* fs_chdir
                             ;* Change root directory
                             ;* Input : fh_handle has the name
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
d1e3 :                       fs_chdir
d1e3 : 48               [ 3] 	pha
d1e4 : da               [ 3] 	phx
d1e5 : 5a               [ 3] 	phy
                             
d1e6 : a566             [ 3] 	lda fh_handle				; First byte of name == 0?
d1e8 : f020             [ 4] 	beq fs_chdir_root			; Then go to root
                             
d1ea : 2005d1           [ 6] 	jsr fs_util_find			; Try to find the file
d1ed : b01f             [ 4] 	bcs fs_chdir_not_found		; C=1 not found
                             
d1ef : 2088cf           [ 6] 	jsr fs_copy_dir_to_fh		; Put entry in to fh_hand
                             
                             	; if the director cluster = 0 then root sector
d1f2 : a589             [ 3] 	lda fh_handle+FH_FirstClust
d1f4 : 058a             [ 3] 	ora fh_handle+FH_FirstClust+1
d1f6 : f012             [ 4] 	beq fs_chdir_root
                             
                             	; Else calculate sector from this directory clus
d1f8 : a689             [ 3] 	ldx fh_handle+FH_FirstClust
d1fa : a58a             [ 3] 	lda fh_handle+FH_FirstClust+1
d1fc : 2032cf           [ 6] 	jsr fs_get_start_sect_data	; Calc the first sect
                             	
d1ff : a203             [ 2] 	ldx #3						; Copy sector to dirsect
d201 :                       fs_chdir_sect
d201 : b57b             [ 4] 	lda fh_handle+FH_CurrSec,x
d203 : 955e             [ 4] 	sta fs_dirsect,x
d205 : ca               [ 2] 	dex
d206 : 10f9             [ 3] 	bpl fs_chdir_sect
d208 : 8003             [ 3] 	bra fs_chdir_fin
                             
d20a :                       fs_chdir_root					; Back to root directory
d20a : 2055cd           [ 6] 	jsr fs_rootdir
AS65 Assembler for R6502 [1.42].                                     Page   79
-------------------------------- bank\bank2.s --------------------------------

                             
d20d :                       fs_chdir_fin
d20d : 18               [ 2] 	clc
d20e :                       fs_chdir_not_found
d20e : 7a               [ 4] 	ply
d20f : fa               [ 4] 	plx
d210 : 68               [ 4] 	pla
d211 : 60               [ 6] 	rts
                             
                             
                             	
d212 :                       msg_initialising_fs
d212 : 496e697469616c..      	db "Initialising filesystem\r",0
d22b :                       fs_msg_directory_listing
d22b : 53442043617264..      	db "SD Card Directory\r",0
                             
d23e :                       mod_sz_sd_fs_e
                             
                             	include "monitor\cmd.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  CMD.S
                             ;*  This file is deprecated, it was the code file
                             ;*  for the simple command line / monitor utility
                             ;*  in a bid to free up space for some more usefu
                             ;*  the command line is no longer included in the
                             ;*
                             ;************************************************
                             
0000 =                       CMD_ERR_NOERROR			= 0x00
0001 =                       CMD_ERR_NOTFOUND		= 0x01
0002 =                       CMD_ERR_PARM			= 0x02
0003 =                       CMD_ERR_VAL				= 0x03
00e7 =                       cmd_lo					= df_currdat
00e8 =                       cmd_hi					= (df_currdat+1)
00e9 =                       cmd_mem					= df_datoff
                             
                             	; ROM code
                             	code  
                             
d23e :                       command_line
d23e : a900             [ 2] 	lda #0						; Initialise monitor
d240 : 85e7             [ 3] 	sta cmd_lo					; Monitor address lo
d242 : 85e8             [ 3] 	sta cmd_hi					; Monitor address hi
d244 : 85e9             [ 3] 	sta cmd_mem					; Memory = 0 RAM, 1 = VRAM
d246 : a0a0             [ 2] 	ldy #160					; Maximum line length
d248 : 8442             [ 3] 	sty buf_sz
                             
d24a :                       cmd_ready
                             	_println msg_ready
                             
                             
d257 : 38               [ 2] 	sec							; Set carry flag = echo characters
d258 : 2058c4           [ 6] 	jsr io_read_line			; Get a command line
d25b : 2099d2           [ 6] 	jsr cmd_parse				; Find command and execute
d25e : b003             [ 3] 	bcs cmd_error				; Carry set = error condition
AS65 Assembler for R6502 [1.42].                                     Page   80
-------------------------------- bank\bank2.s --------------------------------

d260 : 4c4ad2           [ 3] 	jmp cmd_ready
                             
d263 :                       cmd_error
d263 : a5a6             [ 3] 	lda errno
d265 : 1004             [ 3] 	bpl cmd_skip_quit
d267 : 64a6             [ 3] 	stz errno					; Clear error
d269 : 18               [ 2] 	clc							; Clear carry
d26a : 60               [ 6] 	rts							; Return to caller
d26b :                       cmd_skip_quit	
d26b : 2071d2           [ 6] 	jsr cmd_print_error
d26e : 4c4ad2           [ 3] 	jmp cmd_ready
                             
                             ;****************************************
                             ;* cmd_print_error
                             ;* Given error code and Y offset in to buffer
                             ;* print the error message
                             ;* Input : errno, Y
                             ;* Regs affected :
                             ;****************************************
d271 :                       cmd_print_error
d271 : 48               [ 3] 	pha
d272 : 5a               [ 3] 	phy
d273 : a5a6             [ 3] 	lda errno
d275 : 0a               [ 2] 	asl a
d276 : a8               [ 2] 	tay
d277 : bee1d4           [ 4] 	ldx cmd_error_messages,y
d27a : b9e2d4           [ 4] 	lda cmd_error_messages+1,y
d27d : 2091c4           [ 6] 	jsr io_print_line
d280 : a920             [ 2] 	lda #' '
d282 : 2049c4           [ 6] 	jsr io_put_ch
d285 : 68               [ 4] 	pla								; Pull Y off stack
d286 : 48               [ 3] 	pha								; And put it back
d287 : 2022c7           [ 6] 	jsr str_a_to_x
d28a : 2049c4           [ 6] 	jsr io_put_ch
d28d : 8a               [ 2] 	txa
d28e : 2049c4           [ 6] 	jsr io_put_ch
d291 : a90d             [ 2] 	lda #UTF_CR
d293 : 2049c4           [ 6] 	jsr io_put_ch
                             	
d296 : 7a               [ 4] 	ply
d297 : 68               [ 4] 	pla
d298 : 60               [ 6] 	rts
                             	
                             
                             ;****************************************
                             ;* cmd_parse
                             ;* Parse the command line in the io buffer
                             ;* Input : buflo, bufhi
                             ;* Output : y = start of first parm byte
                             ;*          x = index to routine pointer
                             ;* Regs affected : A
                             ;****************************************
d299 :                       cmd_parse
d299 : 48               [ 3] 	pha
d29a : da               [ 3] 	phx
                             	
d29b : a200             [ 2] 	ldx #0
d29d :                       find_cmd_loop
d29d : a000             [ 2] 	ldy #0
d29f :                       find_cmd_byte
d29f : bdb7d4           [ 4] 	lda cmd_list,x			; Check the command list
d2a2 : c980             [ 2] 	cmp #0x80				; If not end of this command in lis
AS65 Assembler for R6502 [1.42].                                     Page   81
-------------------------------- bank\bank2.s --------------------------------

d2a4 : d008             [ 3] 	bne cmd_do_match		; then do the check
d2a6 : b140             [ 5] 	lda (buf_lo),y			; Check the command line
d2a8 : f02c             [ 3] 	beq cmd_found			; If zero then found
d2aa : c920             [ 2] 	cmp #' '				; If space then
d2ac : f028             [ 3] 	beq cmd_found			; also found
d2ae :                       cmd_do_match				; If here then line <> 0/space an
d2ae : b140             [ 5] 	lda (buf_lo),y			; Get char from command buffer
d2b0 : 0920             [ 2] 	ora #0x20				; Make lower case
d2b2 : ddb7d4           [ 4] 	cmp cmd_list,x			; Compare with char from comman
d2b5 : d004             [ 3] 	bne cmd_no_match		; Different = command does not
d2b7 : c8               [ 2] 	iny						; Advance command buffer and list
d2b8 : e8               [ 2] 	inx
d2b9 : 80e4             [ 3] 	bra find_cmd_byte		; Go check the next bytes
d2bb :                       cmd_no_match				; A command didn't match, so find
d2bb : bdb7d4           [ 4] 	lda cmd_list,x			; Get the non-matching command 
d2be : c980             [ 2] 	cmp #0x80				; If already at command terminator 
d2c0 : f007             [ 3] 	beq cmd_next_cmd		; set up for next command
d2c2 : c9ff             [ 2] 	cmp #0xff				; If end of command list
d2c4 : f008             [ 3] 	beq cmd_not_found		; then not found
d2c6 : e8               [ 2] 	inx						; Else check next char
d2c7 : 80f2             [ 3] 	bra cmd_no_match
d2c9 :                       cmd_next_cmd
d2c9 : e8               [ 2] 	inx						; Jump over 0x80
d2ca : e8               [ 2] 	inx						; Jump over command address
d2cb : e8               [ 2] 	inx
d2cc : 80cf             [ 3] 	bra find_cmd_loop		; Check for match again
                             
d2ce :                       cmd_not_found
d2ce : a901             [ 2] 	lda #CMD_ERR_NOTFOUND
d2d0 : 85a6             [ 3] 	sta errno
d2d2 : 68               [ 4] 	pla
d2d3 : fa               [ 4] 	plx
d2d4 : 38               [ 2] 	sec
d2d5 : 60               [ 6] 	rts
                             	
d2d6 :                       cmd_found					; Found the command
d2d6 : bdb8d4           [ 4] 	lda cmd_list+1,x		; Low byte of jump pointer
d2d9 : 8539             [ 3] 	sta tmp_alo				; Store in temp location
d2db : bdb9d4           [ 4] 	lda cmd_list+2,x		; High byte of jump pointer
d2de : 853a             [ 3] 	sta tmp_ahi				; Store in temp location
d2e0 : 68               [ 4] 	pla
d2e1 : fa               [ 4] 	plx
d2e2 : 6c3900           [ 6] 	jmp (tmp_alo)			; Jump to command (Y points at l
                             	
                             ;****************************************
                             ;* cmd_memtype
                             ;* Set the memory type to V or M
                             ;* Input : buflo, bufhi
                             ;* Output : y = start of first parm byte
                             ;*          x = index to routine pointer
                             ;* Regs affected : A
                             ;****************************************
d2e5 :                       cmd_memtype
d2e5 : 48               [ 3] 	pha
d2e6 : 18               [ 2] 	clc
d2e7 : 209fd4           [ 6] 	jsr cmd_parse_next_parm
d2ea : a902             [ 2] 	lda #CMD_ERR_PARM
d2ec : b01b             [ 4] 	bcs cmd_memtype_err
d2ee : b140             [ 5] 	lda (buf_lo),y
d2f0 : 0920             [ 2] 	ora #0x20
d2f2 : c976             [ 2] 	cmp #'v'
d2f4 : f008             [ 3] 	beq cmd_setmemtypeV
AS65 Assembler for R6502 [1.42].                                     Page   82
-------------------------------- bank\bank2.s --------------------------------

d2f6 : c96d             [ 2] 	cmp #'m'
d2f8 : f00a             [ 4] 	beq cmd_setmemtypeM
d2fa : a903             [ 2] 	lda #CMD_ERR_VAL
d2fc : 800b             [ 4] 	bra cmd_memtype_err
d2fe :                       cmd_setmemtypeV
d2fe : a901             [ 2] 	lda #1
d300 : 85e9             [ 3] 	sta cmd_mem
d302 : 8002             [ 3] 	bra cmd_memtypeFin
d304 :                       cmd_setmemtypeM
d304 : 64e9             [ 3] 	stz cmd_mem
d306 :                       cmd_memtypeFin
d306 : 68               [ 4] 	pla
d307 : 18               [ 2] 	clc
d308 : 60               [ 6] 	rts
d309 :                       cmd_memtype_err
d309 : 85a6             [ 3] 	sta errno
d30b : 38               [ 2] 	sec
d30c : 68               [ 4] 	pla
d30d : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* cmd_setmem
                             ;* Set the memory at address AAAA to byte string
                             ;* Input : buflo, bufhi
                             ;* Output : y = start of first parm byte
                             ;*          x = index to routine pointer
                             ;* Regs affected : A
                             ;****************************************
d30e :                       cmd_setmem
d30e : 48               [ 3] 	pha
d30f : da               [ 3] 	phx
                             	
d310 : 18               [ 2] 	clc
d311 : 209fd4           [ 6] 	jsr cmd_parse_next_parm
d314 : b022             [ 3] 	bcs cmd_setmem_err
d316 : 2084d4           [ 6] 	jsr cmd_parse_word
d319 : b01d             [ 3] 	bcs cmd_setmem_err
d31b : 86e7             [ 3] 	stx cmd_lo
d31d : 85e8             [ 3] 	sta cmd_hi
d31f : 209fd4           [ 6] 	jsr cmd_parse_next_parm		; Should be at least 1 
d322 : b014             [ 3] 	bcs cmd_setmem_err
d324 :                       cmd_setmem_byte
d324 : 2063d4           [ 6] 	jsr cmd_parse_byte
d327 : b00f             [ 3] 	bcs cmd_setmem_err
d329 : 204dd4           [ 6] 	jsr cmd_poke				; Poke A in to cmd_lo, hi
d32c : 2035d4           [ 6] 	jsr cmd_incmem
d32f : 209fd4           [ 6] 	jsr cmd_parse_next_parm		; Try and find another 
d332 : 90f0             [ 3] 	bcc cmd_setmem_byte			; Process if found, else f
d334 :                       cmd_setmemFin
d334 : 18               [ 2] 	clc
d335 : fa               [ 4] 	plx
d336 : 68               [ 4] 	pla
d337 : 60               [ 6] 	rts
d338 :                       cmd_setmem_err
d338 : 38               [ 2] 	sec
d339 : fa               [ 4] 	plx
d33a : 68               [ 4] 	pla
d33b : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* cmd_dumpmem
AS65 Assembler for R6502 [1.42].                                     Page   83
-------------------------------- bank\bank2.s --------------------------------

                             ;* Dump memory at address AAAA
                             ;* Input : buflo, bufhi
                             ;* Output : y = start of first parm byte
                             ;* Regs affected : A
                             ;****************************************
d33c :                       cmd_dumpmem
d33c : 48               [ 3] 	pha
d33d : da               [ 3] 	phx
d33e : 5a               [ 3] 	phy
                             
d33f : 18               [ 2] 	clc
d340 : 209fd4           [ 6] 	jsr cmd_parse_next_parm
d343 : b014             [ 3] 	bcs cmd_dumpmem_err
d345 : 2084d4           [ 6] 	jsr cmd_parse_word			; Get hi byte of word
d348 : b00f             [ 3] 	bcs cmd_dumpmem_err
d34a : 209fd4           [ 6] 	jsr cmd_parse_next_parm		; Should cause error, n
d34d : 9006             [ 3] 	bcc cmd_dumpmem_parm_err
d34f : 86e7             [ 3] 	stx cmd_lo
d351 : 85e8             [ 3] 	sta cmd_hi
d353 : 8009             [ 3] 	bra cmd_dumpmem_block		; Skip over error code to
d355 :                       cmd_dumpmem_parm_err
d355 : a902             [ 2] 	lda #CMD_ERR_PARM
d357 : 85a6             [ 3] 	sta errno
d359 :                       cmd_dumpmem_err
d359 : 7a               [ 4] 	ply
d35a : fa               [ 4] 	plx
d35b : 68               [ 4] 	pla
d35c : 38               [ 2] 	sec
d35d : 60               [ 6] 	rts
d35e :                       cmd_dumpmem_block
d35e : a5e8             [ 3] 	lda cmd_hi					; Show the address
d360 : 2022c7           [ 6] 	jsr str_a_to_x
d363 : 2049c4           [ 6] 	jsr io_put_ch
d366 : 8a               [ 2] 	txa
d367 : 2049c4           [ 6] 	jsr io_put_ch
d36a : a5e7             [ 3] 	lda cmd_lo
d36c : 2022c7           [ 6] 	jsr str_a_to_x
d36f : 2049c4           [ 6] 	jsr io_put_ch
d372 : 8a               [ 2] 	txa
d373 : 2049c4           [ 6] 	jsr io_put_ch
d376 : a920             [ 2] 	lda #' '
d378 : 2049c4           [ 6] 	jsr io_put_ch
                             	
d37b : a008             [ 2] 	ldy #8						; 8 Bytes per line
d37d :                       cmd_dumpmem_byte
d37d : 203cd4           [ 6] 	jsr cmd_peek
d380 : 2022c7           [ 6] 	jsr str_a_to_x
d383 : 2049c4           [ 6] 	jsr io_put_ch
d386 : 8a               [ 2] 	txa
d387 : 2049c4           [ 6] 	jsr io_put_ch
d38a : a920             [ 2] 	lda #' '
d38c : 2049c4           [ 6] 	jsr io_put_ch
d38f : 2035d4           [ 6] 	jsr cmd_incmem
d392 : 88               [ 2] 	dey
d393 : d0e8             [ 3] 	bne cmd_dumpmem_byte
d395 :                       cmd_dumpmemASCII
d395 : 38               [ 2] 	sec
d396 : a5e7             [ 3] 	lda cmd_lo
d398 : e908             [ 2] 	sbc #8
d39a : 85e7             [ 3] 	sta cmd_lo
d39c : a5e8             [ 3] 	lda cmd_hi
d39e : e900             [ 2] 	sbc #0
AS65 Assembler for R6502 [1.42].                                     Page   84
-------------------------------- bank\bank2.s --------------------------------

d3a0 : 85e8             [ 3] 	sta cmd_hi
                             	
d3a2 : a920             [ 2] 	lda #' '
d3a4 : 2049c4           [ 6] 	jsr io_put_ch
d3a7 : 2049c4           [ 6] 	jsr io_put_ch
d3aa : a008             [ 2] 	ldy #8						; 8 Bytes per line
d3ac :                       cmd_dumpmem_ascii
d3ac : 203cd4           [ 6] 	jsr cmd_peek
d3af : c920             [ 2] 	cmp #' '					; <32 is unprintable
d3b1 : b002             [ 3] 	bcs cmd_dump_skip_ctrl
d3b3 : a92e             [ 2] 	lda #'.'					; Replace with dot
d3b5 :                       cmd_dump_skip_ctrl
d3b5 : c97f             [ 2] 	cmp #UTF_DEL				; >= DEL is unprintable
d3b7 : 9002             [ 3] 	bcc cmd_dump_skip_del
d3b9 : a92e             [ 2] 	lda #'.'					; Replace with dot
d3bb :                       cmd_dump_skip_del	
d3bb : 2049c4           [ 6] 	jsr io_put_ch
d3be : 2035d4           [ 6] 	jsr cmd_incmem
d3c1 : 88               [ 2] 	dey
d3c2 : d0e8             [ 3] 	bne cmd_dumpmem_ascii
d3c4 : 38               [ 2] 	sec
d3c5 : 2046c4           [ 6] 	jsr io_get_ch
d3c8 : c90d             [ 2] 	cmp #UTF_CR
d3ca : d005             [ 3] 	bne cmd_dumpmemFin
d3cc : 2049c4           [ 6] 	jsr io_put_ch
d3cf : 808d             [ 3] 	bra cmd_dumpmem_block
d3d1 :                       cmd_dumpmemFin
d3d1 : a90d             [ 2] 	lda #UTF_CR
d3d3 : 2049c4           [ 6] 	jsr io_put_ch
d3d6 : 7a               [ 4] 	ply
d3d7 : fa               [ 4] 	plx
d3d8 : 68               [ 4] 	pla
d3d9 : 18               [ 2] 	clc
d3da : 60               [ 6] 	rts
                             	
                             
                             ;****************************************
                             ;* cmd_sector
                             ;* Load sector
                             ;* Input : buflo, bufhi
                             ;* Output : y = start of first parm byte
                             ;* Regs affected : A
                             ;****************************************
d3db :                       cmd_sector
d3db : 48               [ 3] 	pha
d3dc : da               [ 3] 	phx
d3dd : 5a               [ 3] 	phy
                             
d3de : 18               [ 2] 	clc
                             	
d3df : 2063d4           [ 6] 	jsr cmd_parse_byte			; Get read or write indicat
d3e2 : b044             [ 4] 	bcs cmd_sector_err
d3e4 : 48               [ 3] 	pha							; Save the indicator
                             	
d3e5 : 2084d4           [ 6] 	jsr cmd_parse_word			; Get hi byte of word
d3e8 : b03d             [ 4] 	bcs cmd_sector_errl
                             
d3ea : 8646             [ 3] 	stx sd_sect+0				; Initialise the sector
d3ec : 8547             [ 3] 	sta sd_sect+1
d3ee : 6448             [ 3] 	stz sd_sect+2
d3f0 : 6449             [ 3] 	stz sd_sect+3
                             
AS65 Assembler for R6502 [1.42].                                     Page   85
-------------------------------- bank\bank2.s --------------------------------

d3f2 : 209fd4           [ 6] 	jsr cmd_parse_next_parm		; Should cause error, n
d3f5 : 9030             [ 4] 	bcc cmd_sector_errl
                             
d3f7 : a902             [ 2] 	lda #hi(sd_buf)				; Save/Load from sd_buf
                             
d3f9 : fa               [ 4] 	plx							; Read or write?
d3fa : e000             [ 2] 	cpx #0x00
d3fc : d005             [ 4] 	bne cmd_sector_skip00
d3fe : 20b2cb           [ 6] 	jsr sd_sendcmd17
d401 : 801f             [ 3] 	bra cmd_sector_done
d403 :                       cmd_sector_skip00
d403 : e001             [ 2] 	cpx #0x01
d405 : d005             [ 3] 	bne cmd_sector_skip01
d407 : 2027cc           [ 6] 	jsr sd_sendcmd24
d40a : 8016             [ 3] 	bra cmd_sector_done
d40c :                       cmd_sector_skip01
d40c : e0ff             [ 2] 	cpx #0xff
d40e : d008             [ 3] 	bne cmd_sector_skipff
d410 : 20b2cb           [ 6] 	jsr sd_sendcmd17
d413 : 2027cc           [ 6] 	jsr sd_sendcmd24
d416 : 800a             [ 3] 	bra cmd_sector_done
d418 :                       cmd_sector_skipff
d418 : e0fe             [ 2] 	cpx #0xfe
d41a : d006             [ 3] 	bne cmd_sector_done
d41c : 2027cc           [ 6] 	jsr sd_sendcmd24
d41f : 20b2cb           [ 6] 	jsr sd_sendcmd17
                             	
d422 :                       cmd_sector_done	
d422 : 7a               [ 4] 	ply
d423 : fa               [ 4] 	plx
d424 : 68               [ 4] 	pla
d425 : 18               [ 2] 	clc
d426 : 60               [ 6] 	rts
d427 :                       cmd_sector_errl
d427 : 68               [ 4] 	pla
d428 :                       cmd_sector_err
d428 : 85a6             [ 3] 	sta errno
d42a : 7a               [ 4] 	ply
d42b : fa               [ 4] 	plx
d42c : 68               [ 4] 	pla
d42d : 38               [ 2] 	sec
d42e : 60               [ 6] 	rts
                             	
                             	
                             ;****************************************
                             ;* cmd_quit
                             ;* To quit set err=255 and C=1
                             ;****************************************
d42f :                       cmd_dflat
d42f : a9ff             [ 2] 	lda #0xff
d431 : 85a6             [ 3] 	sta errno
d433 : 38               [ 2] 	sec
d434 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* cmd_incmem
                             ;* Increment pointer
                             ;* Input : cmd_lo, cmd_hi
                             ;* Output : cmd_lo, cmd_hi
                             ;* Regs affected : 
                             ;****************************************
d435 :                       cmd_incmem
AS65 Assembler for R6502 [1.42].                                     Page   86
-------------------------------- bank\bank2.s --------------------------------

d435 : e6e7             [ 5] 	inc cmd_lo
d437 : d002             [ 3] 	bne cmd_skipincmemhi
d439 : e6e8             [ 5] 	inc cmd_hi
d43b :                       cmd_skipincmemhi
d43b : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* cmd_peek
                             ;* Read byte
                             ;* Input : cmd_lo, cmd_hi
                             ;* Output : A
                             ;* Regs affected : 
                             ;****************************************
d43c :                       cmd_peek
d43c : a5e9             [ 3] 	lda cmd_mem
d43e : d003             [ 3] 	bne cmd_peek_vram
d440 : b2e7             [ 5] 	lda (cmd_lo)
d442 : 60               [ 6] 	rts
d443 :                       cmd_peek_vram
d443 : da               [ 3] 	phx
d444 : a6e7             [ 3] 	ldx cmd_lo
d446 : a5e8             [ 3] 	lda cmd_hi
d448 : 20bec3           [ 6] 	jsr _vdp_peek
d44b : fa               [ 4] 	plx
d44c : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* cmd_poke
                             ;* Read byte
                             ;* Input : cmd_lo, cmd_hi, A
                             ;* Output : A
                             ;* Regs affected : 
                             ;****************************************
d44d :                       cmd_poke
d44d : 48               [ 3] 	pha
d44e : a5e9             [ 3] 	lda cmd_mem
d450 : d004             [ 3] 	bne cmd_poke_vram
d452 : 68               [ 4] 	pla
d453 : 92e7             [ 5] 	sta (cmd_lo)
d455 : 60               [ 6] 	rts
d456 :                       cmd_poke_vram
d456 : 68               [ 4] 	pla
d457 : da               [ 3] 	phx
d458 : 5a               [ 3] 	phy
d459 : a6e7             [ 3] 	ldx cmd_lo
d45b : a4e8             [ 3] 	ldy cmd_hi
d45d : 20d6c3           [ 6] 	jsr _vdp_poke
d460 : 7a               [ 4] 	ply
d461 : fa               [ 4] 	plx
d462 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* cmd_parse_byte
                             ;* Find 2 char hex byte
                             ;* Input : buflo, bufhi, y offset
                             ;* Output : y = char after hex byte, A = value
                             ;* Regs affected : A,Y
                             ;****************************************
d463 :                       cmd_parse_byte
d463 : da               [ 3] 	phx
d464 : 209fd4           [ 6] 	jsr cmd_parse_next_parm	; Find the next paramete
d467 : b014             [ 3] 	bcs cmd_parse_byte_err
AS65 Assembler for R6502 [1.42].                                     Page   87
-------------------------------- bank\bank2.s --------------------------------

d469 : b140             [ 5] 	lda (buf_lo),y			; Get hi nibble of high byte
d46b : 48               [ 3] 	pha						; Save on stack
d46c : c8               [ 2] 	iny
d46d : b140             [ 5] 	lda (buf_lo),y			; Get lo nibble of high byte
d46f : f00b             [ 3] 	beq cmd_parse_byte_errl	; If no char then error 
d471 : aa               [ 2] 	tax						; Lo nibble goes to X
d472 : 68               [ 4] 	pla						; Restore hi nibble
d473 : 203fc7           [ 6] 	jsr str_x_to_a			; Convert from hex to A
d476 : b005             [ 3] 	bcs cmd_parse_byte_err	; If error then stop
d478 : c8               [ 2] 	iny						; Point to next char
d479 : 18               [ 2] 	clc
d47a : fa               [ 4] 	plx
d47b : 60               [ 6] 	rts
d47c :                       cmd_parse_byte_errl
d47c : 68               [ 4] 	pla						; Pull low nibble off
d47d :                       cmd_parse_byte_err
d47d : a903             [ 2] 	lda #CMD_ERR_VAL		; Basic value error
d47f : 85a6             [ 3] 	sta errno
d481 : 38               [ 2] 	sec
d482 : fa               [ 4] 	plx
d483 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* cmd_parse_word
                             ;* Find 4 char hex word
                             ;* Input : buflo, bufhi, y offset
                             ;* Output : y = char after hex byte, A = hi, X = 
                             ;* Regs affected : A,X,Y
                             ;****************************************
d484 :                       cmd_parse_word
d484 : 209fd4           [ 6] 	jsr cmd_parse_next_parm		; Find the next paramet
d487 : b010             [ 3] 	bcs cmd_word_err
d489 : 2063d4           [ 6] 	jsr cmd_parse_byte			; Get hi byte of word
d48c : b00b             [ 3] 	bcs cmd_word_err
d48e : 48               [ 3] 	pha							; Save hi byte of word
d48f : 2063d4           [ 6] 	jsr cmd_parse_byte			; Get lo byte of word
d492 : b004             [ 3] 	bcs cmd_word_errl
d494 : aa               [ 2] 	tax							; Put in X
d495 : 68               [ 4] 	pla							; Get high byte back
d496 : 18               [ 2] 	clc
d497 : 60               [ 6] 	rts
d498 :                       cmd_word_errl
d498 : 68               [ 4] 	pla							; Pull off stack
d499 :                       cmd_word_err
d499 : a903             [ 2] 	lda #CMD_ERR_VAL
d49b : 85a6             [ 3] 	sta errno
d49d : 38               [ 2] 	sec
d49e : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* cmd_parse_next_parm
                             ;* Find next non-white space
                             ;* Input : buflo, bufhi, y offset
                             ;* Output : y = start of first parm byte
                             ;* Regs affected : A
                             ;****************************************
d49f :                       cmd_parse_next_parm
d49f : 48               [ 3] 	pha
d4a0 :                       cmd_find_parm
d4a0 : b140             [ 5] 	lda (buf_lo),y
d4a2 : c8               [ 2] 	iny
d4a3 : c900             [ 2] 	cmp #0					; End of command line?
AS65 Assembler for R6502 [1.42].                                     Page   88
-------------------------------- bank\bank2.s --------------------------------

d4a5 : f008             [ 3] 	beq cmd_next_parm_err	; ie no parms
d4a7 : c920             [ 2] 	cmp #' '				; Ignore space
d4a9 : f0f5             [ 3] 	beq cmd_find_parm
d4ab : 88               [ 2] 	dey						; Go back 1 to parm start
d4ac : 68               [ 4] 	pla
d4ad : 18               [ 2] 	clc
d4ae : 60               [ 6] 	rts
d4af :                       cmd_next_parm_err
d4af : 88               [ 2] 	dey						; Go back 1 to end of line
d4b0 : a902             [ 2] 	lda #CMD_ERR_PARM
d4b2 : 85a6             [ 3] 	sta errno
d4b4 : 68               [ 4] 	pla
d4b5 : 38               [ 2] 	sec
d4b6 : 60               [ 6] 	rts
                             
                             	
d4b7 :                       cmd_list
d4b7 : 6d656d74797065..      	db "memtype",	0x80,	lo(cmd_memtype), 	hi(cmd_mem
d4c1 : 64756d70803cd3        	db "dump", 		0x80, 	lo(cmd_dumpmem), 	hi(cmd_dum
d4c8 : 736574800ed3          	db "set", 		0x80,	lo(cmd_setmem), 	hi(cmd_setmem
d4ce : 736563746f7280..      	db "sector",	0x80,	lo(cmd_sector),		hi(cmd_secto
d4d7 : 71756974802fd4        	db "quit",		0x80,	lo(cmd_dflat),		hi(cmd_dflat)
d4de : 0000ff                	db 0x00,		0x00,	0xff
                             
                             
d4e1 :                       cmd_error_messages
d4e1 : f1d4                  	dw msg_errmsg_none
d4e3 : fcd4                  	dw msg_errmsg_notfound
d4e5 : 0ed5                  	dw msg_errmsg_parm
d4e7 : 1ed5                  	dw msg_errmsg_val
                             
d4e9 : 636d642d3e007830      msg_ready				db "cmd->\0x0"
d4f1 : 4e6f206572726f..      msg_errmsg_none			db "No error\0x0"
d4fc : 436f6d6d616e64..      msg_errmsg_notfound		db "Command not found\x0"
d50e : 506172616d6574..      msg_errmsg_parm			db "Parameter error\x0"
d51e : 496c6c6567616c..      msg_errmsg_val			db "Illegal value\x0"
                             	
                             
                             
                             	; End of Code
d52c :                       _code_end
                             
No errors in pass 2.
Wrote binary from address $c000 through $ffff.
Total size 16384 bytes.
