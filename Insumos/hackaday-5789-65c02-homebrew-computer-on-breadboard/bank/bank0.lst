AS65 Assembler for R6502 [1.42].                                     Page    1
-------------------------------- bank\bank0.s --------------------------------

6587 lines read, no errors in pass 1.
                             	include "kernel\kernel.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  KERNEL.S
                             ;*	The 'kernel' routine includes code and data wh
                             ;* 	be in every ROM bank.  In the auto-generated 
                             ;*  files, the kernel is added before the bank sp
                             ;*	code.  See bank0.s as an example.
                             ;*
                             ;************************************************
                             
                             ;* Include all definition and code files in the r
                             	include "inc\includes.i"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  INCLUDES.S
                             ;*  Main include file for key definitions and mac
                             ;*  Many of the settings here are exremely machin
                             ;*  Defines : IO block addresses, VIA port usage,
                             ;*  settings, useful macros, sound chip registers
                             ;*  VDP registers, ACIA registers.
                             ;*
                             ;************************************************
                             
                             ;* The IO block is at 0x04000 and decodes up to
                             ;* eight IO addresses, at 0x0080 intervals
                             ;* All eight are not used at the present time:
                             ;* - 0 : VIA 1 (Keyboard)
                             ;* - 1 : VIA 2 (Sound and SD card interface)
                             ;* - 2 : VDP (Video)
                             ;* - 3 : ACIA (Serial)
0400 =                       IO_0		= 0x0400
0480 =                       IO_1		= 0x0480
0500 =                       IO_2		= 0x0500
0580 =                       IO_3		= 0x0580
0600 =                       IO_4		= 0x0600
0680 =                       IO_5		= 0x0680
0700 =                       IO_6		= 0x0700
0780 =                       IO_7		= 0x0780
                             
                             ;* VDP is accessed through IO_2
0500 =                       VDP_MODE0		= IO_2
0501 =                       VDP_MODE1		= IO_2+1
0501 =                       VDP_STATUS		= IO_2+1
0501 =                       VDP_ADDR		= IO_2+1
0500 =                       VDP_VRAM		= IO_2
0001 =                       VDP_SHORTDELAY	= 1
0002 =                       VDP_LONGDELAY 	= 2
0010 =                       VDP_FLASH		= 0x10				;* Must be a power of 2 *
AS65 Assembler for R6502 [1.42].                                     Page    2
-------------------------------- bank\bank0.s --------------------------------

                             
                             ;* This structure defines the key information
                             ;* kept about the VDP current mode
0000 =                       	struct vdp_addr_struct
0000 =                       	dw vdp_addr_nme				;* Address of name table
0002 =                       	dw vdp_addr_col				;* Address of colour table
0004 =                       	dw vdp_addr_pat				;* Address of pattern table
0006 =                       	dw vdp_addr_spa				;* Address of sprite pattern 
0008 =                       	dw vdp_addr_spp				;* Address of sprite position
000a =                       	db vdp_bord_col				;* Value of border colour
                             	end struct
                             
                             ;* Standard definitions of 6522 registers
                             ;* As found in the datasheets
0000 =                       PRB			= 0x00
0001 =                       PRA			= 0x01
0002 =                       DDRB		= 0x02
0003 =                       DDRA		= 0x03
0004 =                       T1CL		= 0x04
0005 =                       T1CH		= 0x05
0006 =                       T1LL		= 0x06
0007 =                       T1LH		= 0x07
0008 =                       T2CL		= 0x08
0009 =                       T2CH		= 0x09
000a =                       SR			= 0x0a
000b =                       ACR			= 0x0b
000c =                       PCR			= 0x0c
000d =                       IFR			= 0x0d
000e =                       IER			= 0x0e
000f =                       PRAH		= 0x0f
                             
0001 =                       IFR_CA2		= 0x01
0002 =                       IFR_CA1		= 0x02
                             
                             ;* AY-3-8910 definitions
                             ;* The sound chip is accessed through VIA 2
0481 =                       SND_ADBUS	= IO_1+PRA
0480 =                       SND_MODE	= IO_1+PRB
                             
0040 =                       SND_SELREAD			= 0x40
0002 =                       SND_SELWRITE		= 0x02
0042 =                       SND_SELSETADDR		= (SND_SELREAD|SND_SELWRITE)
00bd =                       SND_DESELECT_MASK	= (0xff-SND_SELREAD-SND_SELWRIT
                             
0000 =                       SND_REG_CHAPL	= 0x00
0001 =                       SND_REG_CHAPH	= 0x01
0002 =                       SND_REG_CHBPL	= 0x02
0003 =                       SND_REG_CHBPH	= 0x03
0004 =                       SND_REG_CHCPL	= 0x04
0005 =                       SND_REG_CHCPH	= 0x05
0006 =                       SND_REG_CHNP	= 0x06
0007 =                       SND_REG_CTL		= 0x07
0008 =                       SND_REG_CHAVOL	= 0x08
0009 =                       SND_REG_CHBVOL	= 0x09
000a =                       SND_REG_CHBVOL	= 0x0a
000b =                       SND_REG_ENVPL	= 0x0b
000c =                       SND_REG_ENVPH	= 0x0c
000d =                       SND_REG_ENVCYC	= 0x0d
                             
000e =                       SND_REG_IOA	= 0x0e
000f =                       SND_REG_IOB	= 0x0f
                             
AS65 Assembler for R6502 [1.42].                                     Page    3
-------------------------------- bank\bank0.s --------------------------------

                             ;* 6551 ACIA definitions
                             ;* As found in the datasheets
0580 =                       SER_DATA	= (IO_3+0)
0581 =                       SER_STATUS	= (IO_3+1)
0581 =                       SER_RESET	= (IO_3+1)
0582 =                       SER_CMD		= (IO_3+2)
0583 =                       SER_CTL		= (IO_3+3)
                             
0080 =                       SER_IRQ		= 0x80
0040 =                       SER_DSRB	= 0x40
0020 =                       SER_DCDB	= 0x20
0010 =                       SER_TDRE	= 0x10
0008 =                       SER_RDRF	= 0x08
0004 =                       SER_OVRN	= 0x04
0002 =                       SER_FE		= 0x02
0001 =                       SER_PE		= 0x01
0080 =                       SER_SBN		= 0x80
0040 =                       SER_WL1		= 0x40
0020 =                       SER_WL0		= 0x20
0060 =                       SER_WL		= (SER_WL1|SER_WL0)
0010 =                       SER_RCS		= 0x10
0008 =                       SER_SBR3	= 0x08
0004 =                       SER_SBR2	= 0x04
0002 =                       SER_SBR1	= 0x02
0001 =                       SER_SBR0	= 0x01
000f =                       SER_SBR		= (SER_SBR3|SER_SBR2|SER_SBR1|SER_SBR0)
000f =                       SER_19200B	= (SER_SBR3|SER_SBR2|SER_SBR1|SER_SBR0
000e =                       SER_9600B	= (SER_SBR3|SER_SBR2|SER_SBR1)
0080 =                       SER_PMC1	= 0x80
0040 =                       SER_PMC0	= 0x40
00c0 =                       SER_PMC		= (SER_PMC1|SER_PMC0)
0020 =                       SER_PME		= 0x20
0010 =                       SER_REM		= 0x10
0008 =                       SER_TIC1	= 0x08
0004 =                       SER_TIC0	= 0x04
000c =                       SER_TIC		= (SER_TIC1|SER_TIC0)
0002 =                       SER_IRD		= 0x02
0001 =                       SER_DTR		= 0x01
                             
                             ;* BBC keyboard definitions
                             ;* The keyboard is accessed through VIA 1
                             ;* Port A - all output
0001 =                       KB_ROWA		= 0x01
0002 =                       KB_ROWB		= 0x02
0004 =                       KB_ROWC		= 0x04
0008 =                       KB_COLA		= 0x08
0010 =                       KB_COLB		= 0x10
0020 =                       KB_COLC		= 0x20
0040 =                       KB_COLD		= 0x40
0080 =                       KB_EN		= 0x80
                             ;* Port B
0001 =                       KB_W		= 0x01			; Input - BBC keyboard hardware se
0002 =                       KB_LED0		= 0x02			; Output - led 0
0004 =                       KB_LED1		= 0x04			; Output - led 1
0008 =                       KB_LED2		= 0x08			; Output - led 2
0001 =                       KB_CAPSLK	= 0x01			; Id of Caps Lock - maps to Le
0002 =                       KB_SHIFTLK	= 0x02			; Id of Shift lock - maps to 
                             
0005 =                       KB_REP_TIM	= 5				; Number of VB periods for the 
001e =                       KB_REP_DEL	= 30			; Number of VB periods before r
0003 =                       KB_DEBOUNCE	= 3				; Number of VB periods before 
                             
AS65 Assembler for R6502 [1.42].                                     Page    4
-------------------------------- bank\bank0.s --------------------------------

0003 =                       UTF_ETX		= 0x03			; Break character
0007 =                       UTF_BEL		= 0x07
0008 =                       CRSR_LEFT	= 0x08
0009 =                       CRSR_RIGHT	= 0x09
000a =                       CRSR_DOWN	= 0x0a
000b =                       CRSR_UP		= 0x0b
0006 =                       UTF_ACK		= 0x06			; Used for the copy key in this
000c =                       UTF_FF		= 0x0c
000d =                       UTF_CR		= 0x0d
001a =                       UTF_BRK		= 0x1a			; Debug - drop in to monitor
007f =                       UTF_DEL		= 0x7f
0020 =                       UTF_SPECIAL = 0x20
                             
                             ;* SD Card interface definitions
                             ;* The card is accessed through port B of VIA 2
0001 =                       SD_CLK		= 0x01			; Clock output to SD card
0004 =                       SD_CD		= 0x04			; Card detect input
0008 =                       SD_CS		= 0x08			; Card select output
0010 =                       SD_DI		= 0x10			; Data output from VIA to SD Card
0080 =                       SD_DO		= 0x80			; Data input to VIA from SD card
                             
0010 =                       SD_MOSI		= SD_DI
0080 =                       SD_MISO		= SD_DO
0480 =                       SD_REG		= IO_1+PRB
                             
0000 =                       CMD_ERR_NOERROR			= 0x00
0001 =                       CMD_ERR_NOTFOUND		= 0x01
0002 =                       CMD_ERR_PARM			= 0x02
0003 =                       CMD_ERR_VAL				= 0x03
                             
                             ;* Memory management definitions
                             ;* Y1,Y0 = ROM bank selection CIA1 PORTB
0080 =                       MM_Y1					= 0x80
0040 =                       MM_Y0					= 0x40
                             ;* X1,X0 = RAM bank selection CIA1 PORTB
0020 =                       MM_X1					= 0x20
0010 =                       MM_X0					= 0x10
                             ;* DIS = ROM disable *CIA2* PORTB
0020 =                       MM_DIS					= 0x20
                             
                             ;* Number formats for conversion routines
0000 =                       NUM_ANY		= 0x00
0001 =                       NUM_DEC		= 0x01
0002 =                       NUM_HEX		= 0x02
0003 =                       NUM_BIN		= 0x03
                             
                             	
                             ;* SD Card Master Boot Record (MBR) definitions
                             ;* The MBR contains the essential information
                             ;* needed to access the data on the card
                             ;* MBR is usually sector 0, but not always
                             ;* however the card I am using does work ok.
0000 =                       MBR_Code				=	0x0000
0003 =                       MBR_OEMName				=	0x0003
000b =                       MBR_BytesPerSect		=	0x000b
000d =                       MBR_SectPerClust		=	0x000d
000e =                       MBR_ResvSect			=	0x000e
0010 =                       MBR_FATCopies			=	0x0010
0011 =                       MBR_RootEntries			=	0x0011
0013 =                       MBR_SmlSect				=	0x0013
0015 =                       MBR_MediaDesc			=	0x0015
0016 =                       MBR_SectPerFAT			=	0x0016
AS65 Assembler for R6502 [1.42].                                     Page    5
-------------------------------- bank\bank0.s --------------------------------

0018 =                       MBR_SectPerTrk			=	0x0018
001a =                       MBR_NumHeads			=	0x001a
001c =                       MBR_NumHidSect			=	0x001c
0020 =                       MBR_NumSect				=	0x0020
0024 =                       MBR_DrvNum				=	0x0024
0026 =                       MBR_ExtSig				=	0x0026
0027 =                       MBR_SerNo				=	0x0027
002b =                       MBR_VolName				=	0x002b
0036 =                       MBR_FATName				=	0x0036
003e =                       MBR_ExeCode				=	0x003e
01c6 =                       MBR_BootPart1			=	(0x01be+0x08)
01fe =                       MBR_ExeMark				=	0x01fe
                             
                             ;* FAT16 definitions - these are offsets
                             ;* in to a FAT table entry which is
                             ;* 32 bytes in length.
0000 =                       FAT_Name				= 	0x00
0008 =                       FAT_Ext					=	0x08
000b =                       FAT_Attr				=	0x0b
000c =                       FAT_Resv				=	0x0c
000d =                       FAT_Createms			=	0x0d
000e =                       FAT_CreateTime			=	0x0e
0010 =                       FAT_CreateDate			=	0x10
0012 =                       FAT_AccessDate			=	0x12
0014 =                       FAT_EAIndex				=	0x14
0016 =                       FAT_ModTime				=	0x16
0018 =                       FAT_ModDate				=	0x18
001a =                       FAT_FirstClust			=	0x1a
001c =                       FAT_FileSize			=	0x1c
                             
                             ;* The FileHandle stucture is key to
                             ;* accessing the file system
0000 =                       	struct FileHandle
0000 =                       	ds FH_Name, 13			; 8 name, 3 extension, 1 separa
000d =                       	ds FH_Size, 4
0011 =                       	ds FH_Attr, 1
0012 =                       	ds FH_CurrClust, 2
0014 =                       	ds FH_SectCounter, 1
0015 =                       	ds FH_CurrSec, 4
0019 =                        	ds FH_Pointer, 4
001d =                       	ds FH_DirSect, 4
0021 =                       	ds FH_DirOffset, 2
0023 =                       	ds FH_FirstClust, 2
0025 =                       	ds FH_LastClust, 2
0027 =                       	ds FH_FileMode, 1
                             	end struct
                             
0001 =                       FS_BLK_FLG_LOAD		 	= 	0x01		; On next byte, load 
0002 =                       FS_BLK_FLG_FLUSH		=	0x02		; Block has changed, ne
                             	
0001 =                       FS_ERR_EOF				=	0x01
                             
                             
                             ;* USEFUL MACROS HERE
                             
                             ;* Software break to throw errors
                             ;* use like this : SWBRK XX
                             ;* Where XX is the error code
                             SWBRK macro sig
                             	brk
                             	db sig
                             	endm
AS65 Assembler for R6502 [1.42].                                     Page    6
-------------------------------- bank\bank0.s --------------------------------

                             
                             _pushAXY macro
                             	pha
                             	phx
                             	phy
                             	endm
                             
                             _pullAXY macro
                             	ply
                             	plx
                             	pla
                             	endm
                             
                             _println macro msg
                             	_pushAXY
                             	ldx #lo(msg)
                             	lda #hi(msg)
                             	jsr io_print_line
                             	_pullAXY
                             	endm
                             
                             _printmsgA macro msg
                             	phx
                             	phy
                             	pha
                             	ldx #lo(msg)
                             	lda #hi(msg)
                             	jsr io_print_line
                             	pla
                             	pha
                             	jsr str_a_to_x
                             	jsr _put_byte
                             	txa
                             	jsr _put_byte
                             	lda #UTF_CR
                             	jsr _put_byte
                             	pla
                             	ply
                             	plx
                             	endm
                             
                             _printA macro
                             	phx
                             	phy
                             	pha
                             	jsr str_a_to_x
                             	jsr _put_byte
                             	txa
                             	jsr _put_byte
                             	pla
                             	ply
                             	plx
                             	endm
                             
                             _printCRLF macro
                             	pha
                             	lda #UTF_CR
                             	jsr _put_byte
                             	pla
                             	endm
                             
                             _printC macro ch
AS65 Assembler for R6502 [1.42].                                     Page    7
-------------------------------- bank\bank0.s --------------------------------

                             	pha
                             	lda #ch
                             	jsr _put_byte
                             	pla
                             	endm
                             
                             _printCA macro
                             	pha
                             	jsr _put_byte
                             	pla
                             	endm
                             
                             _sendcmd macro cmd
                             	_pushAXY
                             	ldx #lo(cmd)
                             	lda #hi(cmd)
                             	jsr sd_sendcmd
                             	_pullAXY
                             	endm
                             
                             _incZPWord macro wordp
                             	inc wordp
                             	db	0xd0, 0x02
                             	inc wordp+1
                             	endm
                             
                             _decZPWord macro wordp
                             	pha
                             	sec
                             	lda wordp
                             	sbc #1
                             	sta wordp
                             	lda wordp+1
                             	sbc #0
                             	sta wordp+1
                             	pla
                             	endm
                             
                             _cpyZPWord macro worda,wordb
                             	lda worda
                             	sta wordb
                             	lda worda+1
                             	sta wordb+1
                             	endm
                             	
                             _addZPWord macro worda, wordb
                             	clc
                             	lda worda
                             	adc wordb
                             	sta worda
                             	lda worda+1
                             	adc wordb+1
                             	sta worda+1
                             	endm
                             
                             _subZPWord macro worda, wordb
                             	sec
                             	lda worda
                             	sbc wordb
                             	sta worda
                             	lda worda+1
                             	sbc wordb+1
AS65 Assembler for R6502 [1.42].                                     Page    8
-------------------------------- bank\bank0.s --------------------------------

                             	sta worda+1
                             	endm
                             	
                             _adcZPWord macro worda,const
                             	clc
                             	lda worda
                             	adc #const
                             	sta worda
                             	lda worda+1
                             	adc #0
                             	sta worda+1
                             	endm
                             
                             
                             	include "inc\graph.i"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  GRAPH.I
                             ;*  This is the definition file for graphics, spe
                             ;*  The graphics screen handling module.  It is j
                             ;*  structure definition - but this structure is 
                             ;*  record the important attributes of a text scr
                             ;*  Needed because there is both a 40 and 32 colu
                             ;*  supported by the VDP, and the screens are not
                             ;*  same location.
                             ;*
                             ;************************************************
                             
0000 =                       	struct gr_screen
0000 =                       	dw gr_screen_start			; Start of screen memory in
0002 =                       	dw gr_screen_size			; Number of bytes screen occ
0004 =                       	db gr_screen_w				; Number of columns
0005 =                       	db gr_screen_h				; Number of rows
0006 =                       	db gr_cur_off				; Y offset of cursor image from
0007 =                       	db gr_cur_x					; Current X position of cursor
0008 =                       	db gr_cur_y					; Current Y position of cursor
0009 =                       	dw gr_cur_ptr				; VDP address of cursor
000b =                       	db gr_pixmode				; Pixel plot mode (0=Erase, 1=P
000c =                       	db gr_pixmask				; Pixel plot mask
000d =                       	db gr_pixcol				; Pixel colour
000e =                       	dw gr_geom_tmp				; One word of temp storage for
                             	end struct
                             	include "io\io.i"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  IO.I
                             ;*  Definitions file for the IO module.  The key 
                             ;*  used by the IO system is defined here.
                             ;*
                             ;************************************************
AS65 Assembler for R6502 [1.42].                                     Page    9
-------------------------------- bank\bank0.s --------------------------------

                             
                             ;* General IO structure allows the system to swap
                             ;* different IO devices by using indirect calls t
                             ;* the appropriate routines.
0000 =                       	struct io_struct
0000 =                       	ds	io_get_byte,	2			;* Address of get byte
0002 =                       	ds	io_put_byte,	2			;* Address of put byte
0004 =                       	ds	io_open_r,		2			;* Address of open file for r
0006 =                       	ds	io_open_w,		2			;* Address of open file for w
0008 =                       	ds	io_close_f,		2			;* Address of close file
000a =                       	ds	io_del_f,		2			;* Address of delete file
000c =                       	ds	io_ext1,		2			;* Address of extended function
000e =                       	ds	io_ext2,		2			;* Address of extended function
                             	end struct
                             	include "dflat\dflat.i"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  DFLAT.I
                             ;*  This is the main definitions file for dflat. 
                             ;*  definitions are in here to access the data st
                             ;*  used by dflat.
                             ;*
                             ;************************************************
                             
                             ;* Start dflat program memory
0cbb =                       DF_PROGSTART=	mem_start
                             ;* This is the top of usable dflat memory plus 1
c000 =                       DF_MEMTOP	=	0xc000
                             
                             ;* Offset in to tokenised line of length and line
0000 =                       DFTK_LINLEN	=	0x00
0001 =                       DFTK_LINNUM	=	0x01
                             
                             ;* Flags for token, escape value for data types a
0080 =                       DFTK_TOKEN	=	0x80
0020 =                       DFTK_ESCVAL	=	0x20
0000 =                       DFTK_EOL	=	0x00
                             
                             ;* Numeric constants are encoded based on size an
                             ;* user representation.
                             ;* For example the decimal value 16 will be encod
                             ;* DFTK_INTDEC followed by the bytes 0 and 16 to 
                             ;* The same value in binary will be encoded as DF
                             ;* followed by the same 0 and 16 bytes.  This is 
                             ;* tokenised value to be displayed in original re
                             ;* So in the two examples, they will be shown as 
                             ;* '0x0010' respectively.
0000 =                       DFTK_CHR	=	0x00
0001 =                       DFTK_RESV1	=	0x01
0002 =                       DFTK_RESV2	=	0x02
0003 =                       DFTK_RESV3	=	0x03
0004 =                       DFTK_RESV4	=	0x04
0005 =                       DFTK_BYTDEC	=	0x05
0006 =                       DFTK_BYTHEX = 	0x06
0007 =                       DFTK_BYTBIN =	0x07
0008 =                       DFTK_RESV8	=	0x08
AS65 Assembler for R6502 [1.42].                                     Page   10
-------------------------------- bank\bank0.s --------------------------------

0009 =                       DFTK_INTDEC	=	0x09
000a =                       DFTK_INTHEX =	0x0a
000b =                       DFTK_INTBIN	=	0x0b
000c =                       DFTK_RESVC	=	0x0c
000d =                       DFTK_RESVD	=	0x0d
000e =                       DFTK_RESVE	=	0x0e
000f =                       DFTK_RESVF	=	0x0f
                             
                             ;* String constant, variable and procedure tokens
0010 =                       DFTK_STRLIT	=	0x10
0011 =                       DFTK_VAR	=	0x11
0012 =                       DFTK_PROC	=	0x12
001f =                       DFTK_STEND	=	0x1f
                             
                             ;* Qualifier for non-local parameters passed to a
0026 =                       DFTK_VARPARM=	'&'
                             
                             ;* Variable Value Table (VVT) definitions
                             ;* The VVT records the values of variables define
                             ;* the Variable Name Table (VNT).  When a variabl
                             ;* used, it is added to the VNT, and the position
                             ;* VNT is used as an index in to the VVT.
                             ;* Every VVT entry is 8 bytes - so the VNT index 
                             ;* shifted left 3 bits to get the VVT offset.
                             ;* The VNT grows from top of memory down, the VVT
                             ;* grows from start of VNT down.
                             
                             ;* Index in to each entry of the VVT
0000 =                       DFVVT_TYPE	=	0x00
0001 =                       DFVVT_LO	=	0x01
0002 =                       DFVVT_HI	=	0x02
0003 =                       DFVVT_DIM1	=	0x03
0004 =                       DFVVT_DIM2	=	0x04
0008 =                       DFVVT_SZ	=	0x08	;VVT is aligned to 8 byte blocks
                             
                             ;* The meaning of the DFVVT_TYPE entry
0001 =                       DFVVT_INT	=	0x01
0002 =                       DFVVT_BYT	=	0x02
0004 =                       DFVVT_STR	=	0x04
0008 =                       DFVVT_FLT	=	0x08
0040 =                       DFVVT_PROC	=	0x40
0080 =                       DFVVT_ARRY	=	0x80
                             
                             ;* Flags indicating the meaning of a token
                             ;* A token has the top bit set (0x80), then the
                             ;* remaining bits indicate what it represents.
0001 =                       DFTK_KW		=	0x01
0002 =                       DFTK_FN		=	0x02
0004 =                       DFTK_STROP	=	0x04
0008 =                       DFTK_OP		=	0x08
0010 =                       DFTK_INT	=	0x10
0020 =                       DFTK_BYT	=	0x20
0040 =                       DFTK_STR	=	0x40
0080 =                       DFTK_FLT	=	0x80
0007 =                       DFTK_OPMSK	=	0x07
00f8 =                       DFTK_RTMSK	= 	0xf8
                             
                             ;* Defines what type of value is on the parameter
                             ;* All numerics are stored as INT, all STR
                             ;* are pointers to the actual string, thus
                             ;* all entries in the parmeter stack are 3 bytes
0001 =                       DFST_INT	=	0x01
AS65 Assembler for R6502 [1.42].                                     Page   11
-------------------------------- bank\bank0.s --------------------------------

0080 =                       DFST_STR	=	0x80
                             
                             ;* Token values of specific commands, used during
                             ;* command processing.
                             ;* ANY CHANGE TO THE ORDER OF KEYWORDS NEEDS TO R
0086 =                       DFRT_DEF	=	0x86
0087 =                       DFRT_ENDDEF	=	0x87
0088 =                       DFRT_RETURN	=	0x88
0089 =                       DFRT_ABORT	=	0x89
008c =                       DFRT_REPEAT	=	0x8c
008e =                       DFRT_FOR	=	0x8e
008f =                       DFRT_NEXT	=	0x8f
0090 =                       DFRT_WHILE	=	0x90
0091 =                       DFRT_WEND	=	0x91
0092 =                       DFRT_IF		=	0x92
0093 =                       DFRT_ELSE	=	0x93
0094 =                       DFRT_ENDIF	=	0x94
0095 =                       DFRT_ELSEIF	=	0x95
0096 =                       DFRT_DATA	=	0x96
0097 =                       DFRT_ASM	=	0x97
                             
                             _PushTrueJmp macro
                             	ldx #0xff
                             	txa
                             	jmp df_st_pushInt
                             	endm
                             
                             _PushFalseJmp macro
                             	ldx #0x00
                             	txa
                             	jmp df_st_pushInt
                             	endm
                             
                             	include "kernel\zeropage.i"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  ZEROPAGE.I
                             ;*  This module name is misleading it is not only
                             ;*  allocations, but also page 2, 3, 4, 5, 6, 7 a
                             ;*  Basically, this module defines:
                             ;*  - All zero page variables for system and dfla
                             ;*  - Page 1 is stack so no need to worry about t
                             ;*  - Page 2 is the serial IO buffer for the 6551
                             ;*  - Page 3 and 4 is a 512 buffer for SD card se
                             ;*  - Page 5 onwards is mainly for dflat working 
                             ;*    but also non-zero page storage for general 
                             ;*    system and scratch usage.
                             ;*  memstart is a handy label that indicates the 
                             ;*  location that we can store dflat programs fro
                             ;*  Zero page is a valuable asset as the 6502 can
                             ;*  this page one cycle quicker than the rest of 
                             ;*  and infact some addressing modes can only use
                             ;*  Due to the value of zero page, a lot of syste
                             ;*  dflat variables are put here.  But we don't h
                             ;*  luxury for single use variables - so you will
                             ;*  see a lot of temporary sounding names which a
AS65 Assembler for R6502 [1.42].                                     Page   12
-------------------------------- bank\bank0.s --------------------------------

                             ;*  have multiple used across the code base.
                             ;*
                             ;************************************************
                             
                             	; Zero page declarations
                             	bss
0000 =                       	org 0x0000
                             
0000 =                       tmp_bank1	ds	1		; Temp storage ONLY FOR USE BY BA
0001 =                       tmp_bank2	ds	1		; Temp storage ONLY FOR USE BY BA
                             
                             ; Interrupt routine addresses
0002 =                       int_irq		 ds	2		; Master IRQ handler
0004 =                       int_brk		 ds	2		; Master BRK handler
0006 =                       int_uservdp	 ds	2		; Where to jump for VDP interr
0008 =                       int_usercia0 ds	2		; Where to jump for CIA0 inter
000a =                       int_usercia1 ds	2		; Where to jump for CIA1 inter
                             
                             ; VDP parameters
000c =                       vdp_cnt		ds	1		; VDP interrupt counter
000d =                       vdp_cnt_hi 	ds	1		; VDP counter high
000e =                       vdp_cnt_hi2	ds	1		; VDP counter high 2
000f =                       vdp_curoff	ds	1		; Cursor off (0 = On)
0010 =                       vdp_curstat	ds	1		; Cursor status
0011 =                       vdp_curval	ds	1		; Cursor value on screen
0012 =                       vdp_blank	ds	1		; Screen blank value normally 32
0013 =                       vdp_delay	ds	1		; Delay counter for VRAM access
                             
                             ; vdp settings
0014 =                       vdp_base	ds	vdp_addr_struct
                             
                             ; Screen geometry
001f =                       gr_scrngeom	ds	gr_screen
                             
                             ;Keyboard parameters
002f =                       kb_raw  	ds	1		; Raw keyboard code
0030 =                       kb_last		ds	1		; Raw code of last key
0031 =                       kb_code 	ds	1		; Converted keyboard code
0032 =                       kb_stat		ds	1		; Keyboard status for caps and shi
0033 =                       kb_deb		ds	1		; VB periods since last KB spike
0034 =                       kb_rep		ds	1		; Keyboard repeat timer
0035 =                       kb_rep_tim 	ds	1		; Default repeat speed
0036 =                       kb_rep_del 	ds	1		; Default repeat delay timing
0037 =                       kb_debounce ds	1		; Default repeat debounce
0038 =                       kb_pressed	ds	1		; Set by the interrupt handler i
                             
0039 =                       tmp_alo 	ds	1		; VDP addresses lo
003a =                       tmp_ahi 	ds	1		; VDP addresses hi
003b =                       tmp_blo 	ds	1		; Temp address lo
003c =                       tmp_bhi		ds	1		; Temp address hi
003d =                       tmp_clo		ds	1		; Temp address lo
003e =                       tmp_chi		ds	1		; Temp address hi
003f =                       tmp_a		ds	1		; Temp storage a
                             
                             ; Raw input/output parameters
0040 =                       buf_lo		ds	1		; Line buffer address low
0041 =                       buf_hi		ds	1		; Line buffer address high
0042 =                       buf_sz		ds	1		; Buffer size
0043 =                       buf_ef		ds	1		; End file / line marker
                             
                             ; SD card driver parameters
0044 =                       sd_slo		ds	1		; Sector pointer low
AS65 Assembler for R6502 [1.42].                                     Page   13
-------------------------------- bank\bank0.s --------------------------------

0045 =                       sd_shi		ds	1		; Sector pointer high
0046 =                       sd_sect		ds	4		; SD Card sector address
004a =                       sd_addr		ds	4		; SD Card byte address
                             
                             ; File system parameters
004e =                       fs_bootsect	ds	4		; Start of partition (usually 0
0052 =                       fs_fatsect	ds	4		; Start of FAT tables
0056 =                       fs_rootsect	ds	4		; Start of Root Directory
005a =                       fs_datasect	ds	4		; Start of Data Area
005e =                       fs_dirsect	ds	4		; Current directory
0062 =                       fh_temp		ds	4		; File handling temporary storage
0066 =                       fh_handle	ds	FileHandle ; File handle parameters
                             
                             
                             ; ** Integer function storage **
008e =                       ztmp_16					; Start of 16 byte scratch area (all 
008e =                       num_a		ds	4		; 4 byte primary accumulator
0092 =                       num_b		ds	4		; 4 byte secondary accumulator
0096 =                       num_x		ds	4		; 4 byte x register
009a =                       num_tmp		ds	4		; 4 byte temp space
009e =                       num_buf		ds	8		; 8 byte string buffer
                             
                             ;
                             ; **** INTERPRETER ZERO PAGE ****
                             ;
00a6 =                       errno		ds	1		; General error condition status
00a7 =                       df_immed	ds	1		; Immediate mode (0 = not immediat
00a8 =                       df_sp		ds	1		; Stack pointer after error to resto
00a9 =                       df_pc		ds	2		; PC after error to return to
00ab =                       df_brkpc	ds	2		; PC pushed on the stack for BRK
00ad =                       df_brkval	ds	1		; Byte after BRK instruction
00ae =                       df_prgstrt	ds	2		; Start of program code
00b0 =                       df_prgend	ds	2		; End of program code
00b2 =                       df_vntstrt	ds	2		; Variable name table start
00b4 =                       df_vntend	ds	2		; Variable name table end
00b6 =                       df_vvtstrt	ds	2		; Variable value table start
00b8 =                       df_vvtend	ds	2		; Variable value table end
00ba =                       df_varcnt	ds	1		; Variable counter
00bb =                       df_starstrt	ds	2		; String and array table start
00bd =                       df_starend	ds	2		; String and array table end
00bf =                       df_rtstop	ds	1		; Runtime stack pointer
00c0 =                       df_parmtop	ds	1		; Top of parameter stack (grows 
00c1 =                       df_strbuff	ds	1		; String expression buffer
00c2 =                       df_stridx	ds	1		; Top of string buffer (grows dow
00c3 =                       df_sevalptr	ds	2		; Pointer to next free char in 
                             
00c5 =                       df_linoff	ds	1		; Offset in to line buffer
00c6 =                       df_tokoff	ds	1		; Offset in to tokenised buffer
00c7 =                       df_eolidx	ds	1		; End of line index (i.e length)
00c8 =                       df_nxtstidx	ds	1		; Offset to the next statement 
00c9 =                       df_curstidx	ds	1		; Offset to the start of curren
00ca =                       df_symtab	ds	2		; Pointer to next free symtab ent
00cc =                       df_symoff	ds	1		; Offset in to token table
00cd =                       df_symini	ds	2		; Start of symtab
00cf =                       df_currlin	ds	2		; Execution current line pointer
00d1 =                       df_exeoff	ds	1		; Execution line buffer offset
00d2 =                       df_nextlin	ds	2		; Next line to execute
00d4 =                       df_tmpptra	ds	2		; Temp pointer a
00d6 =                       df_tmpptrb	ds	2		; Temp pointer b
00d8 =                       df_tmpptrc	ds	2		; Temp pointer c
00da =                       df_tmpptrd	ds	2		; Temp pointer d
00dc =                       df_tmpptre	ds	2		; Temp pointer e
AS65 Assembler for R6502 [1.42].                                     Page   14
-------------------------------- bank\bank0.s --------------------------------

00de =                       df_procmode	ds	1		; Only used during tokenisation
00df =                       df_procargs	ds	1		; Only used during tokenisation
00e0 =                       df_procloc	ds	1		; Counts the number of local par
00e1 =                       df_procptr	ds	2		; Pointer to proc vvt slot
00e3 =                       df_lineptr	ds	2		; Pointer to line during searche
00e5 =                       df_lineidx	ds	1		; Pointer to line index during s
00e6 =                       df_ifnest	ds	1		; Global nested if counter
00e7 =                       df_currdat	ds	2		; Data current line pointer
00e9 =                       df_datoff	ds	1		; Data line buffer offset
00ea =                       df_rnd		ds	2		; Random number seed
                             
00ec =                       df_asmpc	ds	2		; Assembler program counter
00ee =                       df_asmopt	ds	1		; Assembler current option
00ef =                       df_asmadmd	ds	1		; Addressing mode
00f0 =                       df_asmopcde	ds	1		; Current opcode
00f1 =                       df_asmoprnd	ds	2		; Current operand
00f3 =                       df_asmlen	ds	1		; Instruction length
                             
                             
                             
                             ;***** END OF ZERO PAGE *****
00f4 =                       _end_zero_page
                             
                             ;***** Page 1 is CPU stack ****
0100 =                       	org 0x0100
0100 =                       _cpu_stack
0100 =                       			ds	256		; All of page 1
                             
                             ;***** Page 2 and 3 is SD card buffer
0200 =                       	org 0x0200			; SD Card data buffer 512 bytes
0200 =                       sd_buf		ds	512
                             
                             ;***** Page 4,5,6,7 is IO space
0400 =                       	org 0x0400
0400 =                       			ds	1024	; 1 k area divided in to 8x128 byte de
                             
                             
                             ;***** Page 8 is serial buffer *****
0800 =                       	org 0x0800
0800 =                       ser_buf		ds	256		; Serial input / output line buf
                             
0900 =                       	org 0x0900			; Page 9 = dflat space
0900 =                       df_linbuff
0900 =                       df_raw		ds	128		; untokenised input line
0980 =                       df_tokbuff
0980 =                       df_tok		ds 	128		; tokenised output line
                             
0a00 =                       	org 0x0a00			; Page 10 = fixed space for runtime
0a00 =                       df_rtstck
0a00 =                       df_rtspace	ds	256
                             
0b00 =                       	org 0x0b00			; Page 11 = 1/2 page fixed space fo
0b00 =                       df_opstck
0b00 =                       df_opspace	ds	128
                             
                             ;***** NON-ZERO PAGE VARIABLES *****
                             
                             ; Acticve IO device settings
0b80 =                       io_default	ds	1		; The default device number
0b81 =                       io_block	ds	io_struct
                             
                             ; File entry current dir entry
AS65 Assembler for R6502 [1.42].                                     Page   15
-------------------------------- bank\bank0.s --------------------------------

0b91 =                       fh_dir		ds	FileHandle
                             
                             ; Dflat top of memory+1 - normally initialised to
0bb9 =                       df_memtop	ds	2
                             
                             ; Scratch area e.g. string and numeric expression
0bbb =                       scratch		ds	256
                             
                             ;***** THIS IS THE START OF FREE SPACE for DFLAT 
0cbb =                       mem_start
                             
                             
                             	include "dflat\dflat.i"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  DFLAT.I
                             ;*  This is the main definitions file for dflat. 
                             ;*  definitions are in here to access the data st
                             ;*  used by dflat.
                             ;*
                             ;************************************************
                             
                             ;* Start dflat program memory
0cbb =                       DF_PROGSTART=	mem_start
                             ;* This is the top of usable dflat memory plus 1
c000 =                       DF_MEMTOP	=	0xc000
                             
                             ;* Offset in to tokenised line of length and line
0000 =                       DFTK_LINLEN	=	0x00
0001 =                       DFTK_LINNUM	=	0x01
                             
                             ;* Flags for token, escape value for data types a
0080 =                       DFTK_TOKEN	=	0x80
0020 =                       DFTK_ESCVAL	=	0x20
0000 =                       DFTK_EOL	=	0x00
                             
                             ;* Numeric constants are encoded based on size an
                             ;* user representation.
                             ;* For example the decimal value 16 will be encod
                             ;* DFTK_INTDEC followed by the bytes 0 and 16 to 
                             ;* The same value in binary will be encoded as DF
                             ;* followed by the same 0 and 16 bytes.  This is 
                             ;* tokenised value to be displayed in original re
                             ;* So in the two examples, they will be shown as 
                             ;* '0x0010' respectively.
0000 =                       DFTK_CHR	=	0x00
0001 =                       DFTK_RESV1	=	0x01
0002 =                       DFTK_RESV2	=	0x02
0003 =                       DFTK_RESV3	=	0x03
0004 =                       DFTK_RESV4	=	0x04
0005 =                       DFTK_BYTDEC	=	0x05
0006 =                       DFTK_BYTHEX = 	0x06
0007 =                       DFTK_BYTBIN =	0x07
0008 =                       DFTK_RESV8	=	0x08
0009 =                       DFTK_INTDEC	=	0x09
000a =                       DFTK_INTHEX =	0x0a
AS65 Assembler for R6502 [1.42].                                     Page   16
-------------------------------- bank\bank0.s --------------------------------

000b =                       DFTK_INTBIN	=	0x0b
000c =                       DFTK_RESVC	=	0x0c
000d =                       DFTK_RESVD	=	0x0d
000e =                       DFTK_RESVE	=	0x0e
000f =                       DFTK_RESVF	=	0x0f
                             
                             ;* String constant, variable and procedure tokens
0010 =                       DFTK_STRLIT	=	0x10
0011 =                       DFTK_VAR	=	0x11
0012 =                       DFTK_PROC	=	0x12
001f =                       DFTK_STEND	=	0x1f
                             
                             ;* Qualifier for non-local parameters passed to a
0026 =                       DFTK_VARPARM=	'&'
                             
                             ;* Variable Value Table (VVT) definitions
                             ;* The VVT records the values of variables define
                             ;* the Variable Name Table (VNT).  When a variabl
                             ;* used, it is added to the VNT, and the position
                             ;* VNT is used as an index in to the VVT.
                             ;* Every VVT entry is 8 bytes - so the VNT index 
                             ;* shifted left 3 bits to get the VVT offset.
                             ;* The VNT grows from top of memory down, the VVT
                             ;* grows from start of VNT down.
                             
                             ;* Index in to each entry of the VVT
0000 =                       DFVVT_TYPE	=	0x00
0001 =                       DFVVT_LO	=	0x01
0002 =                       DFVVT_HI	=	0x02
0003 =                       DFVVT_DIM1	=	0x03
0004 =                       DFVVT_DIM2	=	0x04
0008 =                       DFVVT_SZ	=	0x08	;VVT is aligned to 8 byte blocks
                             
                             ;* The meaning of the DFVVT_TYPE entry
0001 =                       DFVVT_INT	=	0x01
0002 =                       DFVVT_BYT	=	0x02
0004 =                       DFVVT_STR	=	0x04
0008 =                       DFVVT_FLT	=	0x08
0040 =                       DFVVT_PROC	=	0x40
0080 =                       DFVVT_ARRY	=	0x80
                             
                             ;* Flags indicating the meaning of a token
                             ;* A token has the top bit set (0x80), then the
                             ;* remaining bits indicate what it represents.
0001 =                       DFTK_KW		=	0x01
0002 =                       DFTK_FN		=	0x02
0004 =                       DFTK_STROP	=	0x04
0008 =                       DFTK_OP		=	0x08
0010 =                       DFTK_INT	=	0x10
0020 =                       DFTK_BYT	=	0x20
0040 =                       DFTK_STR	=	0x40
0080 =                       DFTK_FLT	=	0x80
0007 =                       DFTK_OPMSK	=	0x07
00f8 =                       DFTK_RTMSK	= 	0xf8
                             
                             ;* Defines what type of value is on the parameter
                             ;* All numerics are stored as INT, all STR
                             ;* are pointers to the actual string, thus
                             ;* all entries in the parmeter stack are 3 bytes
0001 =                       DFST_INT	=	0x01
0080 =                       DFST_STR	=	0x80
                             
AS65 Assembler for R6502 [1.42].                                     Page   17
-------------------------------- bank\bank0.s --------------------------------

                             ;* Token values of specific commands, used during
                             ;* command processing.
                             ;* ANY CHANGE TO THE ORDER OF KEYWORDS NEEDS TO R
0086 =                       DFRT_DEF	=	0x86
0087 =                       DFRT_ENDDEF	=	0x87
0088 =                       DFRT_RETURN	=	0x88
0089 =                       DFRT_ABORT	=	0x89
008c =                       DFRT_REPEAT	=	0x8c
008e =                       DFRT_FOR	=	0x8e
008f =                       DFRT_NEXT	=	0x8f
0090 =                       DFRT_WHILE	=	0x90
0091 =                       DFRT_WEND	=	0x91
0092 =                       DFRT_IF		=	0x92
0093 =                       DFRT_ELSE	=	0x93
0094 =                       DFRT_ENDIF	=	0x94
0095 =                       DFRT_ELSEIF	=	0x95
0096 =                       DFRT_DATA	=	0x96
0097 =                       DFRT_ASM	=	0x97
                             
                             _PushTrueJmp macro
                             	ldx #0xff
                             	txa
                             	jmp df_st_pushInt
                             	endm
                             
                             _PushFalseJmp macro
                             	ldx #0x00
                             	txa
                             	jmp df_st_pushInt
                             	endm
                             
                             	include "dflat\error.i"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  ERROR.I
                             ;*  Error definitions file.
                             ;*  The macro to throw an error is elswhere, but 
                             ;*  it issues a 6502 BRK commmand with the next b
                             ;*  the error code.  The BRK handler then picks u
                             ;*  code and shows the appropriate message plus a
                             ;*  number if a program was running.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
                             ; Error message numbers
0000 =                       DFERR_OK		=	0
0001 =                       DFERR_ERROR		=	1
0002 =                       DFERR_SYNTAX	=	2
0003 =                       DFERR_RUNTIME	=	3
0004 =                       DFERR_TYPEMISM	=	4
0005 =                       DFERR_DIM		=	5
0006 =                       DFERR_UNTIL		=	6
0007 =                       DFERR_NOPROC	=	7
AS65 Assembler for R6502 [1.42].                                     Page   18
-------------------------------- bank\bank0.s --------------------------------

0008 =                       DFERR_PROCPARM	=	8
0009 =                       DFERR_IMMEDIATE	=	9
000a =                       DFERR_UNCLOSEDIF=	10
000b =                       DFERR_NOIF		=	11
000c =                       DFERR_NEXTFOR	=	12
000d =                       DFERR_FNAME		=	13
000e =                       DFERR_STRLONG	=	14
000f =                       DFERR_BREAK		=	15
0010 =                       DFERR_NODATA	=	16
0011 =                       DFERR_WEND		=	17
0012 =                       DFERR_NOLINE	=	18
0013 =                       DFERR_RETURN	=	19
0014 =                       DFERR_ABORT		=	20
0015 =                       DFERR_QUANTITY	=	21
0016 =                       DFERR_NOORG		=	22
0017 =                       DFERR_ADDRMODE	=	23
                             
                             
                             
                             	include "bank\bank.i"
c000 =                       bankjsr_nul_addr	=	0xc000
0000 =                       bankjsr_nul_bank	=	0x00
003f =                       ROM_ZMASK			=	0x3f
00cf =                       RAM_ZMASK			=	0xcf
                             
                             _bankjsr	macro	addr,bank
                             	; Save A
                             	sta tmp_bank1
                             	
                             	; Save current bank
                             	lda bank_num
                             	pha
                             	
                             	; Switch to new bank
                             	lda IO_0+PRB
                             	and #ROM_ZMASK
                             	ora #(bank^3) << 6			; Shift left 6 bits
                             	sta IO_0+PRB
                             
                             	; Restore A
                             	lda tmp_bank1
                             	; JSR to the routine
                             	jsr addr
                             	
                             	jmp _restore_bank
                             	; 62 clock cycles inc restore vs 6 for a near js
                             
                             	endm
                             	
                             _bankram macro bank
                             	pha
                             	lda IO_0+PRB
                             	and #RAM_ZMASK
                             	ora #bank << 4
                             	sta IO_0+PRB
                             	pla
                             	endm
                             	
                             _bankram_fast macro bank
                             	lda IO_0+PRB
                             	and #RAM_ZMASK
                             	ora #bank << 4
AS65 Assembler for R6502 [1.42].                                     Page   19
-------------------------------- bank\bank0.s --------------------------------

                             	sta IO_0+PRB
                             	endm
                             	
                             
                             
                             
                             ;****************************************
                             ;*	Set 6502 default vectors	*
                             ;****************************************
                             	data				; Set vectors
fffa =                       	org 0xfffa			; Vectors lie at addresses
fffa : f7c9                  	fcw nmi				; 0xfffa : NMI Vector
fffc : 98c9                  	fcw init			; 0xfffc : Reset Vector
fffe : 20c6                  	fcw call_irq_master	; 0xfffe : IRQ Vector
                             	
                             	; ROM code
                             	code				;  
c000 =                       	org 0xc000			; Start of ROM
                             
                             	; The bank number is hardwired and aligned to PB
c000 :                       bank_num
                             	if BANK0
c000 : c0                    	  db 192
                             	endif
                             	if BANK1
                             	  db 128
                             	endif
                             	if BANK2
                             	  db 64
                             	endif
                             	if BANK3
                             	  db 0
                             	endif
                             
c001 :                       _code_start
                             	; Restore current bank always at address c001
c001 :                       _OSVectors
                             	include "kernel\osvec.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  OSVEC.S
                             ;*  Simply this is a bunch of JMP XXXX the order 
                             ;*  will always be maintained.  This is to allow 
                             ;*  code programs to be able to rely on fixed loc
                             ;*  some key low-level functions.
                             ;*  Only low level functions are needed, the idea
                             ;*  as the assembler is part of the BASIC, one ca
                             ;*  level slow stuff using BASIC then switch to M
                             ;*  speed up.
                             ;*  This code goes straight after the bank number
                             ;*  Each JMP is at 0xc001+3*(vector #)
                             ;*
                             ;************************************************
                             
c001 : 4c49c4           [ 3] 	jmp	io_put_ch			; Vec 0
c004 : 4c46c4           [ 3] 	jmp io_get_ch			; Vec 1
AS65 Assembler for R6502 [1.42].                                     Page   20
-------------------------------- bank\bank0.s --------------------------------

c007 : 4cd6c4           [ 3] 	jmp vdp_wr_reg			; Vec 2
c00a : 4c0ec5           [ 3] 	jmp vdp_poke			; Vec 3
c00d : 4c1ac5           [ 3] 	jmp vdp_peek			; Vec 4
c010 : 4c7bc5           [ 3] 	jmp snd_get_joy0		; Vec 5
c013 : 4c23c5           [ 3] 	jmp snd_set				; Vec 6
c016 : 4ce3c4           [ 3] 	jmp vdp_wr_addr			; Vec 7
c019 : 4cfac4           [ 3] 	jmp	vdp_rd_addr			; Vec 8
c01c :                       _restore_bank
                             	; Save A
c01c : 8500             [ 3] 	sta tmp_bank1
                             	; Get old bank from stack
c01e : 68               [ 4] 	pla
c01f : 8501             [ 3] 	sta tmp_bank2
c021 : ad0004           [ 4] 	lda IO_0+PRB
c024 : 293f             [ 2] 	and #ROM_ZMASK
c026 : 0501             [ 3] 	ora tmp_bank2
c028 : 8d0004           [ 4] 	sta IO_0+PRB
                             	
                             	; Restore A
c02b : a500             [ 3] 	lda tmp_bank1
                             
c02d : 60               [ 6] 	rts
                             
                             	; include cross-bank functions (see extern.mak)
                             	include "bank\autogen.s"	
                             ; 
c02e :                       mod_sz_autogen_s 
c02e :                       _df_init 
                               _bankjsr $ef9a, 1 
                             
c046 :                       _df_pg_dflat 
                               _bankjsr $d677, 1 
                             
c05e :                       _fs_chdir 
                               _bankjsr $d1e3, 2 
                             
c076 :                       _fs_delete 
                               _bankjsr $d1a9, 2 
                             
c08e :                       _fs_close 
                               _bankjsr $d188, 2 
                             
c0a6 :                       _fs_get_next_byte 
                               _bankjsr $cf13, 2 
                             
c0be :                       _fs_open_read 
                               _bankjsr $d126, 2 
                             
c0d6 :                       _fs_open_write 
                               _bankjsr $d14f, 2 
                             
c0ee :                       _fs_put_byte 
                               _bankjsr $d044, 2 
                             
c106 :                       _get_byte 
                               _bankjsr $ca78, 0 
                             
c11e :                       _put_byte 
                               _bankjsr $ca88, 0 
                             
c136 :                       _gr_get_key 
                               _bankjsr $d996, 0 
AS65 Assembler for R6502 [1.42].                                     Page   21
-------------------------------- bank\bank0.s --------------------------------

                             
c14e :                       _gr_put_byte 
                               _bankjsr $d9a3, 0 
                             
c166 :                       _gr_init_screen 
                               _bankjsr $d455, 0 
                             
c17e :                       _init_acia 
                               _bankjsr $ca95, 0 
                             
c196 :                       _init_cia0 
                               _bankjsr $ca25, 0 
                             
c1ae :                       _init_cia1 
                               _bankjsr $ca56, 0 
                             
c1c6 :                       _init_fs 
                               _bankjsr $ccc3, 2 
                             
c1de :                       _init_sdcard 
                               _bankjsr $c9f8, 2 
                             
c1f6 :                       _init_snd 
                               _bankjsr $cc6c, 0 
                             
c20e :                       _init_keyboard 
                               _bankjsr $caa3, 0 
                             
c226 :                       _kb_read_raw 
                               _bankjsr $cab2, 0 
                             
c23e :                       _command_line 
                               _bankjsr $d23e, 2 
                             
c256 :                       _fs_dir_find_entry 
                               _bankjsr $cdc4, 2 
                             
c26e :                       _fs_dir_root_start 
                               _bankjsr $cdab, 2 
                             
c286 :                       _gr_cls 
                               _bankjsr $d45f, 0 
                             
c29e :                       _gr_init_hires 
                               _bankjsr $d412, 0 
                             
c2b6 :                       _gr_line 
                               _bankjsr $d7d0, 0 
                             
c2ce :                       _gr_box 
                               _bankjsr $d610, 0 
                             
c2e6 :                       _gr_circle 
                               _bankjsr $d71b, 0 
                             
c2fe :                       _gr_plot 
                               _bankjsr $d4ca, 0 
                             
c316 :                       _gr_hchar 
                               _bankjsr $d504, 0 
                             
c32e :                       _gr_point 
AS65 Assembler for R6502 [1.42].                                     Page   22
-------------------------------- bank\bank0.s --------------------------------

                               _bankjsr $d5c5, 0 
                             
c346 :                       _gr_get 
                               _bankjsr $d4e1, 0 
                             
c35e :                       _gr_set_cur 
                               _bankjsr $d4e9, 0 
                             
c376 :                       _snd_get_note 
                               _bankjsr $cc65, 0 
                             
c38e :                       _snd_get_joy0 
                               _bankjsr $c57b, 0 
                             
c3a6 :                       _snd_set 
                               _bankjsr $c523, 0 
                             
c3be :                       _vdp_peek 
                               _bankjsr $c51a, 0 
                             
c3d6 :                       _vdp_poke 
                               _bankjsr $c50e, 0 
                             
c3ee :                       _vdp_init 
                               _bankjsr $d200, 0 
                             
c406 :                       mod_sz_autogen_e 
                             
                             	
c406 :                       mod_sz_kernel_s
                             
                             ;* Include all common code in the right order
                             	include "io\io.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  IO.S
                             ;*  General IO module.  Allows different IO devic
                             ;*  utilised transparently by the rest of the cod
                             ;*  Other code should use "io_" commands so that 
                             ;*  do not need to know what specific device is p
                             ;*  input and output capabilities.  On startup, t
                             ;*  examines the BBC DIP switch to decide whether
                             ;*  initialise the IO to serial through the ACIA 
                             ;*  the BBC keyboard for input with the VDP for o
                             ;*  Loading and saving files from the SD card is 
                             ;*  achieved by pointing to SD card get and put b
                             ;*  routines.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             
c406 :                       mod_sz_io_s
                             
                             ;****************************************
AS65 Assembler for R6502 [1.42].                                     Page   23
-------------------------------- bank\bank0.s --------------------------------

                             ;* io_init
                             ;* Initialise the default device and make active
                             ;* No keys pressed = serial (default)
                             ;* F0 pressed = KB/VDP
                             ;* F1 pressed = Serial
                             ;* Keyboard and screen or serial port
                             ;* Output : None
                             ;* Regs affected : P, A
                             ;****************************************
c406 :                       io_init
c406 : 2026c2           [ 6] 	jsr _kb_read_raw	; Check pressed key
c409 : a900             [ 2] 	lda #0				; Default = Serial
c40b : e080             [ 2] 	cpx #0x80			; f0 key pressed?
c40d : d004             [ 3] 	bne io_init_skip_f0
c40f : a901             [ 2] 	lda #1				; Default = KB/VDP
c411 : 8006             [ 3] 	bra io_init_done
c413 :                       io_init_skip_f0
c413 : e081             [ 2] 	cpx #0x81			; f1 key pressed?
c415 : d002             [ 3] 	bne io_init_done
c417 : a900             [ 2] 	lda #0				; f1 pressed = serial
c419 :                       io_init_done
c419 : 8d800b           [ 4] 	sta io_default
c41c : 4c22c4           [ 3] 	jmp io_active_device; Activate the device
                             
                             
                             ;****************************************
                             ;* io_set_default, io_active_device
                             ;* Activate device based on default or A
                             ;* Input : A = Device number
                             ;* Output : None
                             ;* Regs affected : P, A
                             ;****************************************
c41f :                       io_set_default			; Entry point for default
c41f : ad800b           [ 4] 	lda io_default
c422 :                       io_active_device		; Entry point for A set
c422 : 0a               [ 2] 	asl	a				; x16 the Block number
c423 : 0a               [ 2] 	asl a
c424 : 0a               [ 2] 	asl a
c425 : 0a               [ 2] 	asl a
c426 : a8               [ 2] 	tay
c427 : a200             [ 2] 	ldx #0
                             	; Copy device settings to io block
c429 :                       io_copy_data
c429 : b9a6c4           [ 4] 	lda io_devices,y
c42c : 9d810b           [ 5] 	sta io_block,x
c42f : c8               [ 2] 	iny
c430 : e8               [ 2] 	inx
c431 : e010             [ 2] 	cpx #16
c433 : d0f4             [ 3] 	bne io_copy_data
                             	
c435 : a900             [ 2] 	lda #lo(ser_buf)	; Initialise buffer and size
c437 : 8540             [ 3] 	sta buf_lo
c439 : a908             [ 2] 	lda #hi(ser_buf)
c43b : 8541             [ 3] 	sta buf_hi
c43d : a9ff             [ 2] 	lda #255
c43f : 8542             [ 3] 	sta buf_sz
c441 : a90d             [ 2] 	lda #UTF_CR		; Line terminator is CR
c443 : 8543             [ 3] 	sta buf_ef
c445 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* io_get_ch
AS65 Assembler for R6502 [1.42].                                     Page   24
-------------------------------- bank\bank0.s --------------------------------

                             ;* Get a char (wait forever or just check)
                             ;* Input : C = 1 for synchronous, 0 for async
                             ;* Output : A = Byte code, C = 0 means A is inval
                             ;* Regs affected : P, A
                             ;****************************************
c446 :                       io_get_ch
c446 : 6c810b           [ 6] 	jmp (io_block+io_get_byte)
                             	
                             
                             ;****************************************
                             ;* io_put_ch
                             ;* Put a char
                             ;* Input : A = char
                             ;* Regs affected : P, A
                             ;****************************************
c449 :                       io_put_ch
c449 : 6c830b           [ 6] 	jmp (io_block+io_put_byte)
                             	
                             ;****************************************
                             ;* io_open_read
                             ;* Open for reading
                             ;* Input : X,A = pointer to filename (zero termin
                             ;* Output : C=0 success
                             ;* Regs affected : All
                             ;****************************************
c44c :                       io_open_read
c44c : 6c850b           [ 6] 	jmp (io_block+io_open_r)
                             	
                             ;****************************************
                             ;* io_open_write
                             ;* Open for reading
                             ;* Input : X,A = pointer to filename (zero termin
                             ;* Output : C=0 success
                             ;* Regs affected : All
                             ;****************************************
c44f :                       io_open_write
c44f : 6c870b           [ 6] 	jmp (io_block+io_open_w)
                             
                             ;****************************************
                             ;* io_close
                             ;* Close a file
                             ;* Input : 
                             ;* Output : C=0 success
                             ;* Regs affected : All
                             ;****************************************
c452 :                       io_close
c452 : 6c890b           [ 6] 	jmp (io_block+io_close_f)
                             	
                             ;****************************************
                             ;* io_delete
                             ;* Delete a file
                             ;* Input : 
                             ;* Output : C=0 success
                             ;* Regs affected : All
                             ;****************************************
c455 :                       io_delete
c455 : 6c8b0b           [ 6] 	jmp (io_block+io_del_f)
                             	
                             ;****************************************
                             ;* io_read_line
                             ;* Read a line, terminated by terminating char or
                             ;* Input : buf_(lo/hi/sz/ef) : Address, Max size,
AS65 Assembler for R6502 [1.42].                                     Page   25
-------------------------------- bank\bank0.s --------------------------------

                             ;* Output : Y = Line length C = Buffer limit reac
                             ;* Regs affected : None
                             ;****************************************
c458 :                       io_read_line
c458 : 48               [ 3] 	pha
                             
c459 : 08               [ 3] 	php					; Save echo state
                             	
c45a : a000             [ 2] 	ldy #0x00			; Starting at first byte
c45c :                       io_get_line_byte
c45c : 38               [ 2] 	sec					; Getting bytes synchronously
c45d : 2046c4           [ 6] 	jsr io_get_ch		; Get a byte
c460 : b027             [ 3] 	bcs io_get_line_done; Got nothing then finish
c462 : 28               [ 4] 	plp					; Get echo state
c463 : 08               [ 3] 	php					; Instantly save it back
c464 : 900c             [ 3] 	bcc io_skip_echo	; Carry not set = don't echo
c466 : c97f             [ 2] 	cmp #UTF_DEL		; Delete?
c468 : d005             [ 3] 	bne io_do_echo
c46a : c000             [ 2] 	cpy #0				; Already at beginning?
c46c : f004             [ 3] 	beq io_skip_echo	; Don't echo delete
c46e : 88               [ 2] 	dey					; Else decrement length
c46f :                       io_do_echo
c46f : 2049c4           [ 6] 	jsr io_put_ch		; Echo it
c472 :                       io_skip_echo
c472 : c920             [ 2] 	cmp #UTF_SPECIAL	; Special character?
c474 : 9007             [ 3] 	bcc io_skip_special	; Skip if so (don't add to b
c476 : c97f             [ 2] 	cmp #UTF_DEL		; Don't proces DEL either
c478 : f003             [ 3] 	beq io_skip_special
c47a : 9140             [ 5] 	sta (buf_lo),y		; Save it
c47c : c8               [ 2] 	iny					; Increase length
c47d :                       io_skip_special
c47d : c543             [ 3] 	cmp buf_ef			; Is it the terminating char?
c47f : f008             [ 3] 	beq io_get_line_done	; If yes then done
c481 : c442             [ 3] 	cpy buf_sz			; Reached the buffer max size?
c483 : d0d7             [ 3] 	bne io_get_line_byte	; No, get another byte
c485 : 28               [ 4] 	plp					; Remember to pull echo state off stack
c486 : 38               [ 2] 	sec					; Yes, set carry flag
c487 : 68               [ 4] 	pla
c488 : 60               [ 6] 	rts					; And done
c489 :                       io_get_line_done
c489 : a900             [ 2] 	lda #0
c48b : 9140             [ 5] 	sta (buf_lo),y		; Terminate with 0
c48d : 28               [ 4] 	plp					; Remember to pull echo state off stack
c48e : 18               [ 2] 	clc					; Clear carry flag
c48f : 68               [ 4] 	pla
c490 : 60               [ 6] 	rts					; Fin
                             
                             ;****************************************
                             ;* io_print_line
                             ;* Print a line (when data is not already in seri
                             ;* Input : X = Address Lo, A = Address Hi
                             ;* Output : Y=number chars output
                             ;* Regs affected : All
                             ;****************************************
c491 :                       io_print_line
c491 : 48               [ 3] 	pha
                             
c492 : 863d             [ 3] 	stx tmp_clo					; Store the string pointer
c494 : 853e             [ 3] 	sta tmp_chi					; lo and hi
c496 : a000             [ 2] 	ldy #0						; Start at the beginning!
c498 :                       io_print_line_byte
c498 : b13d             [ 5] 	lda (tmp_clo),y				; Copy byte to
AS65 Assembler for R6502 [1.42].                                     Page   26
-------------------------------- bank\bank0.s --------------------------------

c49a : f006             [ 3] 	beq io_print_done			; If zero then done - print
c49c : 2049c4           [ 6] 	jsr io_put_ch				; Transmit
c49f : c8               [ 2] 	iny
c4a0 : d0f6             [ 3] 	bne io_print_line_byte		; Carry on until zero fo
c4a2 :                       io_print_done
c4a2 : 68               [ 4] 	pla
c4a3 : 60               [ 6] 	rts
                             
                             
                             ;*** Null operation just clc and return ***
c4a4 :                       io_null_op
c4a4 : 18               [ 2] 	clc
c4a5 : 60               [ 6] 	rts
                             	
                             ;* IO devices defined here
c4a6 :                       io_devices
                             ;* Device zero is the serial port
                             ;* only offers get and put
c4a6 :                       io_device0					; Serial device, input = Ser, outp
c4a6 : 06c1                  	dw	_get_byte			; io_get_ch
c4a8 : 1ec1                  	dw	_put_byte			; io_put_ch
c4aa : a4c4                  	dw	io_null_op			; io_open_r
c4ac : a4c4                  	dw	io_null_op			; io_open_w
c4ae : a4c4                  	dw	io_null_op			; io_close_f
c4b0 : a4c4                  	dw	io_null_op			; io_del_f
c4b2 : a4c4                  	dw	io_null_op			; io_ext1
c4b4 : a4c4                  	dw	io_null_op			; io_ext2
                             ;* Device one is keyboard / screen
                             ;* only offers get and put
c4b6 :                       io_device1					; Default device, input = screen e
c4b6 : 36c1                  	dw	_gr_get_key			; io_get_ch
c4b8 : 4ec1                  	dw	_gr_put_byte		; io_put_ch
c4ba : a4c4                  	dw	io_null_op			; io_open_r
c4bc : a4c4                  	dw	io_null_op			; io_open_w
c4be : a4c4                  	dw	io_null_op			; io_close_f
c4c0 : a4c4                  	dw	io_null_op			; io_del_f
c4c2 : a4c4                  	dw	io_null_op			; io_ext1
c4c4 : a4c4                  	dw	io_null_op			; io_ext2
                             ;* Device two is the file system on SD card
                             ;* Offers all IO functions
c4c6 :                       io_device2					; SD device, input = SD, output = 
c4c6 : a6c0                  	dw	_fs_get_next_byte	; io_get_ch
c4c8 : eec0                  	dw	_fs_put_byte		; io_put_ch
c4ca : bec0                  	dw	_fs_open_read		; io_open_r
c4cc : d6c0                  	dw	_fs_open_write		; io_open_w
c4ce : 8ec0                  	dw	_fs_close			; io_close_f
c4d0 : 76c0                  	dw	_fs_delete			; io_del_f
c4d2 : a4c4                  	dw	io_null_op			; io_ext1
c4d4 : a4c4                  	dw	io_null_op			; io_ext2
                             
c4d6 :                       mod_sz_io_e
                             
                             
                             	include "kernel\vdp-low.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
AS65 Assembler for R6502 [1.42].                                     Page   27
-------------------------------- bank\bank0.s --------------------------------

                             ;*  VDP-LOW.S
                             ;*  Low level VDP routines which will always be p
                             ;*  every ROM bank.  This is to ensure if IRQ nee
                             ;*  no slow bank switching is needed, but also to
                             ;*	OS vectored access to VDP routines for M/C fro
                             ;*
                             ;************************************************
                             
                             ;****************************************
                             ;* vdp_wr_reg
                             ;* Write to Register A the value X
                             ;* Input : A - Register Number, X - Data
                             ;* Output : None
                             ;* Regs affected : P
                             ;****************************************
c4d6 :                       vdp_wr_reg
c4d6 : 8e0105           [ 4] 	stx VDP_MODE1
                             ; Extra nop for fast CPU
c4d9 : ea               [ 2] 	nop
c4da : ea               [ 2] 	nop
c4db : 0980             [ 2] 	ora #0x80
c4dd : 8d0105           [ 4] 	sta VDP_MODE1
c4e0 : 4980             [ 2] 	eor #0x80
c4e2 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* vdp_wr_addr
                             ;* Write to address in X (low) and A (high) - for
                             ;* Input : A - Address high byte, X - Address low
                             ;* Output : None
                             ;* Regs affected : P
                             ;****************************************
c4e3 :                       vdp_wr_addr
c4e3 : 8e0105           [ 4] 	stx VDP_MODE1
                             ; Extra nop for fast CPU
c4e6 : ea               [ 2] 	nop
c4e7 : ea               [ 2] 	nop
c4e8 : 0940             [ 2] 	ora #0x40		; Required by VDP
c4ea : 8d0105           [ 4] 	sta VDP_MODE1
c4ed : 4940             [ 2] 	eor #0x40		; Undo that bit
c4ef : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* vdp_mem_wait
                             ;* Delay some time before a memory access,
                             ;* taking in to account mode 9918 needs up
                             ;* to 3.1uS for text mode, 8uS for graphics
                             ;* I and II
                             ;* @ 5.35Mhz	= 16 cycles for 3.1uS
                             ;*				= 43 cycles for 8uS
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
c4f0 :                       vdp_mem_wait
c4f0 : da               [ 3] 	phx								; 3
c4f1 : a613             [ 3] 	ldx vdp_delay					; 3
c4f3 : f003             [ 3] 	beq vdp_mem_wait_end			; 3
c4f5 :                       vdp_mem_wait_loop
c4f5 : ca               [ 2] 	dex								; 2
c4f6 : d0fd             [ 3] 	bne	vdp_mem_wait_loop			; 3
AS65 Assembler for R6502 [1.42].                                     Page   28
-------------------------------- bank\bank0.s --------------------------------

c4f8 :                       vdp_mem_wait_end
c4f8 : fa               [ 4] 	plx								; 3
c4f9 : 60               [ 6] 	rts								; 6
                             	
                             ;****************************************
                             ;* vdp_rd_addr
                             ;* Set read address 
                             ;* Input : A - high, X - low 
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
c4fa :                       vdp_rd_addr
c4fa : 8e0105           [ 4] 	stx VDP_MODE1
                             ; These nops are needed for fast CPU
c4fd : ea               [ 2] 	nop
c4fe : ea               [ 2] 	nop
c4ff : 8d0105           [ 4] 	sta VDP_MODE1
c502 : 80ec             [ 4] 	bra vdp_mem_wait
                             	
                             ;****************************************
                             ;* vdp_rd_vram
                             ;* Read VRAM byte, result in A
                             ;* Input : None
                             ;* Output : A - Byte from VRAM
                             ;* Regs affected : P
                             ;****************************************
c504 :                       vdp_rd_vram
c504 : ad0005           [ 4] 	lda VDP_VRAM
c507 : 80e7             [ 4] 	bra vdp_mem_wait
                             	
                             ;****************************************
                             ;* vdp_wr_vram
                             ;* Write VRAM byte in A
                             ;* Input : A - Byte to write
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
c509 :                       vdp_wr_vram
c509 : 8d0005           [ 4] 	sta VDP_VRAM
c50c : 80e2             [ 4] 	bra vdp_mem_wait
                             	
                             ;****************************************
                             ;* vdp_poke
                             ;* Write VRAM byte in A, (YX)
                             ;* Input : A - Byte to write
                             ;*		   X = Low Address
                             ;*		   Y = High Address
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
c50e :                       vdp_poke
c50e : 48               [ 3] 	pha
c50f : 98               [ 2] 	tya
c510 : 78               [ 2] 	sei
c511 : 20e3c4           [ 6] 	jsr vdp_wr_addr
c514 : 68               [ 4] 	pla
c515 : 2009c5           [ 6] 	jsr vdp_wr_vram
c518 : 58               [ 2] 	cli
c519 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* vdp_peek
AS65 Assembler for R6502 [1.42].                                     Page   29
-------------------------------- bank\bank0.s --------------------------------

                             ;* Get VRAM byte in (AX)
                             ;*		   X = Low Address
                             ;*		   A = High Address
                             ;* Output : A = byte read
                             ;* Regs affected : None
                             ;****************************************
c51a :                       vdp_peek
c51a : 78               [ 2] 	sei
c51b : 20fac4           [ 6] 	jsr vdp_rd_addr
c51e : 2004c5           [ 6] 	jsr vdp_rd_vram
c521 : 58               [ 2] 	cli
c522 : 60               [ 6] 	rts
                             
                             	include "kernel\snd-low.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  SND-LOW.S
                             ;*  Low level sound routines which will always be
                             ;*  in every ROM bank.  Mainly to provide fast OS
                             ;*	access to VDP routines for M/C from BASIC
                             ;*
                             ;************************************************
                             
                             ;****************************************
                             ;* snd_set
                             ;* Set AY register X to value Y
                             ;* Input : X = Reg no, Y = Value
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
c523 :                       snd_set
c523 : 48               [ 3] 	pha
                             
c524 : a9ff             [ 2] 	lda #0xff				; Set Port A to output
c526 : 8d8304           [ 4] 	sta IO_1 + DDRA
                             
c529 : 8e8104           [ 4] 	stx SND_ADBUS			; Put X on the sound bus (X = re
                             
c52c : ad8004           [ 4] 	lda SND_MODE			; Need to preserve contents of ot
c52f : 29bd             [ 2] 	and #SND_DESELECT_MASK	; Mask off mode bits
c531 : 0942             [ 2] 	ora #SND_SELSETADDR		; Select AY mode to latch a
c533 : 8d8004           [ 4] 	sta SND_MODE			; This write will process the dat
                             
c536 : 29bd             [ 2] 	and #SND_DESELECT_MASK	; Mask off mode bits
c538 : 8d8004           [ 4] 	sta SND_MODE			; This write will deselect the AY
                             	
c53b : 8c8104           [ 4] 	sty SND_ADBUS			; Put Y on the sound bus (Y = va
c53e : 0902             [ 2] 	ora #SND_SELWRITE		; Select mode for writing dat
c540 : 8d8004           [ 4] 	sta SND_MODE			; This write will process the dat
                             	
c543 : 29bd             [ 2] 	and #SND_DESELECT_MASK	; Mask off mode bits
c545 : 8d8004           [ 4] 	sta SND_MODE			; This write will deselect the AY
                             
c548 : 68               [ 4] 	pla
                             	
c549 : 60               [ 6] 	rts
AS65 Assembler for R6502 [1.42].                                     Page   30
-------------------------------- bank\bank0.s --------------------------------

                             
                             ;****************************************
                             ;* snd_get
                             ;* Get AY register X to Y
                             ;* Input : X = Reg no
                             ;* Output : Y = Value
                             ;* Regs affected : None
                             ;****************************************
c54a :                       snd_get
c54a : 48               [ 3] 	pha
                             
c54b : a9ff             [ 2] 	lda #0xff				; Set Port A to output
c54d : 8d8304           [ 4] 	sta IO_1 + DDRA
                             
c550 : 8e8104           [ 4] 	stx SND_ADBUS			; Put X on the sound bus (X = re
                             
c553 : ad8004           [ 4] 	lda SND_MODE			; Need to preserve contents of ot
c556 : 29bd             [ 2] 	and #SND_DESELECT_MASK	; Mask off mode bits
c558 : 0942             [ 2] 	ora #SND_SELSETADDR		; Select AY mode to latch a
c55a : 8d8004           [ 4] 	sta SND_MODE			; This write will process the dat
                             
c55d : 29bd             [ 2] 	and #SND_DESELECT_MASK	; Mask off mode bits
c55f : 8d8004           [ 4] 	sta SND_MODE			; This write will deselect the AY
                             
c562 : a900             [ 2] 	lda #0x00				; Set Port A to input
c564 : 8d8304           [ 4] 	sta IO_1 + DDRA
                             
c567 : ad8004           [ 4] 	lda SND_MODE			; Need to preserve contents of ot
c56a : 29bd             [ 2] 	and #SND_DESELECT_MASK	; Mask off mode bits
c56c : 0940             [ 2] 	ora #SND_SELREAD		; Select mode for reading data
c56e : 8d8004           [ 4] 	sta SND_MODE			; This write will process the dat
                             
c571 : ac8104           [ 4] 	ldy SND_ADBUS			; Get value in to Y
                             	
c574 : 29bd             [ 2] 	and #SND_DESELECT_MASK	; Mask off mode bits
c576 : 8d8004           [ 4] 	sta SND_MODE			; This write will deselect the AY
                             
c579 : 68               [ 4] 	pla
                             	
c57a : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* snd_get_joy0
                             ;* Return value of joystick 0
                             ;* Input : None
                             ;* Output : Y = Value
                             ;* Regs affected : X
                             ;****************************************
c57b :                       snd_get_joy0
c57b : a20f             [ 2] 	ldx #SND_REG_IOB		; Joystick is plugged in to IO
c57d : 204ac5           [ 6] 	jsr snd_get				; Get IOB, result in Y
c580 : 60               [ 6] 	rts
                             
                             	include "kernel\main.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
AS65 Assembler for R6502 [1.42].                                     Page   31
-------------------------------- bank\bank0.s --------------------------------

                             ;*  MAIN.S
                             ;*  This is where the main user program is execut
                             ;*  the 'kernel' once the system is initialised a
                             ;*  Today, main does very little - first shows th
                             ;*  boot up message, and then passes control to d
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
c581 :                       main
                             	_println msg_hello_world
                             
                             
c58e :                       infinity
c58e : 2046c0           [ 6] 	jsr _df_pg_dflat
c591 : 4c8ec5           [ 3] 	jmp infinity
                             
c594 :                       msg_hello_world
                             	;* build.s is generate by the assemble.bat file
                             	;* all it does is echo an assembler line to
                             	;* including the build date in the message.
                             	include "kernel\build.s"
c594 : 4275696c64203a..       db "Build : 25/10/2020\r" 
c5a7 : 424243202d2031..       db "BBC - 128K Breadboard Computer\r" 
c5c6 : 42792040363530..       db "By @6502Nerd (Dolo Miah)\r" 
c5df : 436f7079726967..       db "Copyright (c) 2015-20\r\r",0 
                             
                             
                             	include "kernel\irq.s"
                             	
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  IRQ.S
                             ;*	This is the IRQ handler - handles both the ver
                             ;*  blank interrupt from the VDP as well as softw
                             ;*  
                             ;*  As the handler has to be in every bank and it
                             ;*  accesses the VDP, then low level VDP routines
                             ;*  bundled in this file to ensure they are alway
                             ;*  without a bank switch being needed (which is 
                             ;************************************************
                             
                             ;* Obviously this can only be done with
                             ;* interrupts disabled!
c5f7 :                       init_irq
                             	; Core IRQ handler
c5f7 : a931             [ 2] 	lda #lo(irq)
c5f9 : 8502             [ 3] 	sta int_irq
c5fb : a9c6             [ 2] 	lda #hi(irq)
c5fd : 8503             [ 3] 	sta int_irq+1
                             	
                             	; Core BRK handler
c5ff : a95f             [ 2] 	lda #lo(irq_brk)
c601 : 8504             [ 3] 	sta int_brk
AS65 Assembler for R6502 [1.42].                                     Page   32
-------------------------------- bank\bank0.s --------------------------------

c603 : a9c6             [ 2] 	lda #hi(irq_brk)
c605 : 8505             [ 3] 	sta int_brk+1
                             
                             	; User handlers for VDP, PIA0, PIA1 interrupts
c607 : a930             [ 2] 	lda #lo(null_handler)
c609 : 8506             [ 3] 	sta int_uservdp
c60b : a9c6             [ 2] 	lda #hi(null_handler)
c60d : 8507             [ 3] 	sta int_uservdp+1
                             
c60f : a930             [ 2] 	lda #lo(null_handler)
c611 : 8508             [ 3] 	sta int_usercia0
c613 : a9c6             [ 2] 	lda #hi(null_handler)
c615 : 8509             [ 3] 	sta int_usercia0+1
                             
c617 : a930             [ 2] 	lda #lo(null_handler)
c619 : 850a             [ 3] 	sta int_usercia1
c61b : a9c6             [ 2] 	lda #hi(null_handler)
c61d : 850b             [ 3] 	sta int_usercia1+1
                             
c61f : 60               [ 6] 	rts
                             
                             ;* Calls the master IRQ handler
c620 :                       call_irq_master
c620 : 6c0200           [ 6] 	jmp (int_irq)
                             	
                             ;* Calls the BRK handler
c623 :                       call_irq_brk
c623 : 6c0400           [ 6] 	jmp (int_brk)
                             
                             ;* Call the userVDP handler
c626 :                       call_irq_uservdp
c626 : 6c0600           [ 6] 	jmp (int_uservdp)
                             	
                             ;* Call the user CIA0 handler
c629 :                       call_irq_usercia0
c629 : 6c0800           [ 6] 	jmp (int_usercia0)
                             
                             ;* Call the user CIA1 handler
c62c :                       call_irq_usercia1
c62c : 6c0a00           [ 6] 	jmp (int_usercia1)
                             	
                             ;* null interrupt
c62f :                       null_irq
c62f : 40               [ 6] 	rti
                             
                             ;* null handler
c630 :                       null_handler
c630 : 60               [ 6] 	rts
                             	
                             
                             ;* Master IRQ handler
c631 :                       irq
                             	_pushAXY
                             
                             
                             	; Check if IRQ or BRK
                             	; load P from stack in to A
c634 : ba               [ 2] 	tsx
c635 : bd0401           [ 4] 	lda 0x104,x
                             	; BRK bit set?
c638 : 2910             [ 2] 	and #0x10
c63a : d0e7             [ 3] 	bne call_irq_brk
AS65 Assembler for R6502 [1.42].                                     Page   33
-------------------------------- bank\bank0.s --------------------------------

                             	
c63c : 18               [ 2] 	clc						; Standard behaviour
                             	
                             	;* Try PIA1 first for rapid Timer handling
c63d : ad8d04           [ 4] 	lda IO_1 + IFR
c640 : 1003             [ 3] 	bpl irq_check_vdp
c642 : 202cc6           [ 6] 	jsr call_irq_usercia1	; Call user cia1 handler
                             
                             	;* Try VDP next
c645 :                       irq_check_vdp	
c645 : ad0105           [ 4] 	lda VDP_STATUS			; Read status register
c648 : 1009             [ 3] 	bpl	irq_check_cia0		; Skip if not VBLANK
c64a : 2026c6           [ 6] 	jsr call_irq_uservdp	; Call use VDP handler
c64d : 20acc6           [ 6] 	jsr int_vdp_handler		; Call  OS VDP handler
c650 : 208ac6           [ 6] 	jsr int_kb_handler		; Call OS cia0 handler (keyb
                             
                             	;* Try VIA0 last as it's keyboard (low speed)
c653 :                       irq_check_cia0
c653 : ad0d04           [ 4] 	lda IO_0 + IFR
c656 : 1003             [ 3] 	bpl irq_fin
c658 : 2029c6           [ 6] 	jsr call_irq_usercia0	; Call user cia0 handler
                             
c65b :                       irq_fin
                             	_pullAXY
                             
c65e : 40               [ 6] 	rti
                             	
                             ;* Handle BRK
c65f :                       irq_brk
                             	; Handle BRK
                             	; Get PCL,H minus 2 gives the BRK instruction ad
c65f : 38               [ 2] 	sec
c660 : bd0501           [ 4] 	lda 0x0105,x
c663 : e902             [ 2] 	sbc #2
c665 : 85ab             [ 3] 	sta df_brkpc
c667 : bd0601           [ 4] 	lda 0x0106,x
c66a : e900             [ 2] 	sbc #0
c66c : 85ac             [ 3] 	sta df_brkpc+1
                             	; Get the byte pointed to by old PC
                             	; which is 1 on from the BRK
c66e : a001             [ 2] 	ldy #1
c670 : b1ab             [ 5] 	lda (df_brkpc),y
c672 : 85ad             [ 3] 	sta df_brkval
c674 : 85a6             [ 3] 	sta errno
                             	; now update the return address
c676 : a5a9             [ 3] 	lda df_pc
c678 : 9d0501           [ 5] 	sta 0x105,x
c67b : a5aa             [ 3] 	lda df_pc+1
c67d : 9d0601           [ 5] 	sta 0x106,x
                             	
                             	_pullAXY
                             
                             	; Save the registers in temp area
c683 : 858e             [ 3] 	sta num_a
c685 : 868f             [ 3] 	stx num_a+1
c687 : 8490             [ 3] 	sty num_a+2
                             	; when RTI occurs:
                             	;  will return to error handler
                             	;  df_brkval will contain signature
c689 : 40               [ 6] 	rti
                             	
                             ;****************************************
AS65 Assembler for R6502 [1.42].                                     Page   34
-------------------------------- bank\bank0.s --------------------------------

                             ;* int_kb_handler
                             ;* Keyboard interrupt handler
                             ;****************************************
c68a :                       int_kb_handler	
c68a : a533             [ 3] 	lda kb_deb				; If keyboard pressed is debounce 
c68c : d00d             [ 3] 	bne int_skip_scan		; If not zero, then don't che
c68e : ad0d04           [ 4] 	lda IO_0 + IFR			; Check status register CIA0
c691 : 2901             [ 2] 	and #IFR_CA2			; Keyboard pressed?
c693 : f00c             [ 3] 	beq int_keys_up
c695 :                       int_do_read
c695 : 8538             [ 3] 	sta kb_pressed			; Put non-zero in to this flag
c697 : a537             [ 3] 	lda kb_debounce			; Set debounce
c699 : 8533             [ 3] 	sta kb_deb
c69b :                       int_skip_scan
c69b : a901             [ 2] 	lda #IFR_CA2			; Clear CA2
c69d : 8d0d04           [ 4] 	sta IO_0 + IFR
c6a0 : 60               [ 6] 	rts
c6a1 :                       int_keys_up					; No key pressed
c6a1 : 642f             [ 3] 	stz kb_raw				; Using 65c02 stz opcode
c6a3 : 6430             [ 3] 	stz kb_last
c6a5 : 6431             [ 3] 	stz kb_code
c6a7 : 6433             [ 3] 	stz kb_deb
c6a9 : 6434             [ 3] 	stz kb_rep
c6ab : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* int_vdp_handler
                             ;* VDP interrupt handler
                             ;****************************************
c6ac :                       int_vdp_handler
c6ac : 20d7c6           [ 6] 	jsr update_timers	; If it is then update system 
c6af : a50f             [ 3] 	lda vdp_curoff		; Is cursor enabled?
c6b1 : d023             [ 3] 	bne int_vdp_fin		; Skip if so
c6b3 : a910             [ 2] 	lda #VDP_FLASH		; Check bit 5 of low timer
c6b5 : 250c             [ 3] 	and vdp_cnt
c6b7 : c510             [ 3] 	cmp vdp_curstat		; Same as curent state?
c6b9 : f01b             [ 3] 	beq int_vdp_fin		; If so no change required
c6bb : 8510             [ 3] 	sta vdp_curstat		; Save new state
                             
c6bd : 18               [ 2] 	clc					; Add offset for cursor address in vram
c6be : a528             [ 3] 	lda gr_scrngeom+gr_cur_ptr
c6c0 : 6525             [ 3] 	adc gr_scrngeom+gr_cur_off
c6c2 : aa               [ 2] 	tax
c6c3 : a529             [ 3] 	lda gr_scrngeom+gr_cur_ptr+1
c6c5 : 6900             [ 2] 	adc #0
                             
c6c7 : 20e3c4           [ 6] 	jsr vdp_wr_addr
                             	
c6ca : a50c             [ 3] 	lda vdp_cnt			; Use counter to determine normal/
c6cc : 0a               [ 2] 	asl a				; Move bit 4 to bit 7 to create inverse
c6cd : 0a               [ 2] 	asl a
c6ce : 0a               [ 2] 	asl a
c6cf : 2980             [ 2] 	and #0x80			; Only top bit is what we want
c6d1 : 4511             [ 3] 	eor vdp_curval		; EOR top bit with what is under
c6d3 : 2009c5           [ 6] 	jsr vdp_wr_vram
c6d6 :                       int_vdp_fin	
c6d6 : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* update_timers
                             ;* Update 24 bit timer and debounce counters
AS65 Assembler for R6502 [1.42].                                     Page   35
-------------------------------- bank\bank0.s --------------------------------

                             ;****************************************
c6d7 :                       update_timers
c6d7 : e60c             [ 5] 	inc vdp_cnt
c6d9 : d006             [ 3] 	bne inc_kb_timers
c6db : e60d             [ 5] 	inc vdp_cnt_hi
c6dd : d002             [ 3] 	bne inc_kb_timers
c6df : e60e             [ 5] 	inc vdp_cnt_hi2
c6e1 :                       inc_kb_timers
c6e1 : a633             [ 3] 	ldx kb_deb			; Is debounce 0?
c6e3 : f002             [ 3] 	beq skip_kb_deb
c6e5 : c633             [ 5] 	dec kb_deb
c6e7 :                       skip_kb_deb
c6e7 : a634             [ 3] 	ldx kb_rep			; Is repeat timer 0?
c6e9 : f002             [ 3] 	beq skip_kb_rep
c6eb : c634             [ 5] 	dec kb_rep
c6ed :                       skip_kb_rep
c6ed : 60               [ 6] 	rts
                             	
                             
                             	include "utils\misc.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  MISC.S
                             ;*  Miscellaneous module for commmon utility func
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             
                             ;****************************************
                             ;* long_delay
                             ;* Long delay (X decremented every 0.125ms)
                             ;* Input : X = number of 0.125ms ticks to wait (m
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
c6ee :                       long_delay
c6ee : 08               [ 3] 	php
                             	_pushAXY
                             
                             	
c6f2 : a000             [ 2] 	ldy #0x00
c6f4 :                       long_delay_1
c6f4 : ea               [ 2] 	nop
c6f5 : ea               [ 2] 	nop
c6f6 : ea               [ 2] 	nop
c6f7 : ea               [ 2] 	nop
c6f8 : 88               [ 2] 	dey
c6f9 : d0f9             [ 3] 	bne long_delay_1
c6fb : ca               [ 2] 	dex
c6fc : d0f6             [ 3] 	bne long_delay_1
                             
                             	_pullAXY
                             
c701 : 28               [ 4] 	plp
AS65 Assembler for R6502 [1.42].                                     Page   36
-------------------------------- bank\bank0.s --------------------------------

                             	
c702 : 60               [ 6] 	rts
                             
                             
                             	include "utils\utils.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  UTILS.S
                             ;*  This module implements various utility functi
                             ;*  converting from ASCII to binary form for numb
                             ;*  vice-versa to allow humans to actually be abl
                             ;*  and read numbers in their prefered form!
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             
c703 :                       jsrPrintA
c703 : 48               [ 3] 	pha
c704 : da               [ 3] 	phx
c705 : 2022c7           [ 6] 	jsr str_a_to_x
c708 : 2049c4           [ 6] 	jsr io_put_ch
c70b : 8a               [ 2] 	txa
c70c : 2049c4           [ 6] 	jsr io_put_ch
c70f : fa               [ 4] 	plx
c710 : 68               [ 4] 	pla
c711 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* util_clr_mem
                             ;* Clear a block of main ram
                             ;* Input : X, A = Block start, Y = Block size
                             ;* Regs affected : P
                             ;****************************************
c712 :                       util_clr_mem
c712 : 48               [ 3] 	pha
c713 : 5a               [ 3] 	phy
c714 : 8639             [ 3] 	stx tmp_alo
c716 : 853a             [ 3] 	sta tmp_ahi
c718 : a900             [ 2] 	lda #0
c71a :                       mem_clr_byte
c71a : 88               [ 2] 	dey
c71b : 9139             [ 5] 	sta (tmp_alo),y
c71d : d0fb             [ 3] 	bne mem_clr_byte
c71f : 7a               [ 4] 	ply
c720 : 68               [ 4] 	pla
c721 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* str_a_to_x
                             ;* Convert accumulator to hex string
                             ;* Input : A = Byte to convert
                             ;* Output : A = High Char, X = Low Char
                             ;* Regs affected : P
                             ;****************************************
AS65 Assembler for R6502 [1.42].                                     Page   37
-------------------------------- bank\bank0.s --------------------------------

c722 :                       str_a_to_x
c722 : 48               [ 3] 	pha					; Save the byte using later on
c723 : 290f             [ 2] 	and #0x0f			; Mask low nibble
c725 : 18               [ 2] 	clc
c726 : 6930             [ 2] 	adc #'0'			; Convert to UTF
c728 : c93a             [ 2] 	cmp #('9'+1)		; If A greater than '9' then
c72a : 9002             [ 3] 	bcc skip_a_f_1		; skip a-f adjustment
c72c : 6926             [ 2] 	adc #0x26			; Add 27 (6+C) to get in to A-F rang
c72e :                       skip_a_f_1
c72e : aa               [ 2] 	tax					; Low char is in X
c72f : 68               [ 4] 	pla					; Get byte back
c730 : 4a               [ 2] 	lsr a				; Make high nibble low
c731 : 4a               [ 2] 	lsr a
c732 : 4a               [ 2] 	lsr a
c733 : 4a               [ 2] 	lsr a
c734 : 18               [ 2] 	clc
c735 : 6930             [ 2] 	adc #'0'			; Convert to UTF
c737 : c93a             [ 2] 	cmp #('9'+1)		; If A greater than '9' then
c739 : 9002             [ 3] 	bcc skip_a_f_2		; skip a-f adjustment
c73b : 6926             [ 2] 	adc #0x26			; Add 27 (6+C) to get in to A-F rang
c73d :                       skip_a_f_2
                             
c73d : 18               [ 2] 	clc					; No error
c73e : 60               [ 6] 	rts					; A high nibble
                             
                             ;****************************************
                             ;* str_x_to_a
                             ;* Convert hex string to accumulator
                             ;* Input : A = High Char, X = Low Char
                             ;* Output : A = Value
                             ;* Regs affected : P
                             ;****************************************
c73f :                       str_x_to_a
c73f : 0920             [ 2] 	ora #0x20			; Make alpha in to lower case
c741 : 38               [ 2] 	sec					; Process high char in A
c742 : e930             [ 2] 	sbc #'0'			; Convert to hex nibble
c744 : c90a             [ 2] 	cmp #10				; If A < 10 then
c746 : 9002             [ 3] 	bcc skip_x_f_1		; skip a-f adjustment
c748 : e927             [ 2] 	sbc #0x27			; Sub 7 to get in to A-F range
c74a :                       skip_x_f_1
c74a : c910             [ 2] 	cmp #0x10			; Nibble should be <= 0x0f
c74c : b01d             [ 3] 	bcs	str_x_to_a_err	; Error if not
                             
c74e : 0a               [ 2] 	asl a				; This is the high nibble
c74f : 0a               [ 2] 	asl a
c750 : 0a               [ 2] 	asl a
c751 : 0a               [ 2] 	asl a
c752 : 48               [ 3] 	pha					; Save the high nibble
c753 : 8a               [ 2] 	txa					; Now process the low char in X
c754 : 0920             [ 2] 	ora #0x20			; Make alpha in to lower case
c756 : 38               [ 2] 	sec
c757 : e930             [ 2] 	sbc #'0'			; Convert to hex nibble
c759 : c90a             [ 2] 	cmp #10				; If A < 10 then
c75b : 9002             [ 3] 	bcc skip_x_f_2		; skip a-f adjustment
c75d : e927             [ 2] 	sbc #0x27			; Sub 7 to get in to A-F range
c75f :                       skip_x_f_2
c75f : c910             [ 2] 	cmp #0x10			; Nibble should be <= 0x0f
c761 : b007             [ 3] 	bcs	str_x_to_a_errl	; Error if not
                             
c763 : 858e             [ 3] 	sta num_a			; Store low nibble in temp
c765 : 68               [ 4] 	pla					; Get high nibble
c766 : 058e             [ 3] 	ora num_a			; OR with low nibble
AS65 Assembler for R6502 [1.42].                                     Page   38
-------------------------------- bank\bank0.s --------------------------------

                             
c768 : 18               [ 2] 	clc					; No error
c769 : 60               [ 6] 	rts					; A contains value
                             
c76a :                       str_x_to_a_errl
c76a : 68               [ 4] 	pla
c76b :                       str_x_to_a_err
                             	SWBRK CMD_ERR_VAL
                             
                             
                             ;****************************************
                             ;* con_n_to_a
                             ;* Convert numeric string to accumulator (unsigne
                             ;* Input : Pointer to string (X=L, A=H), Y = Sour
                             ;* Output : num_a, num_a+1 contains word, X=numbe
                             ;* A = Source type detected
                             ;* Regs affected : CS = Error
                             ;****************************************
c76d :                       con_n_to_a
c76d : 869a             [ 3] 	stx num_tmp
c76f : 859b             [ 3] 	sta num_tmp+1
c771 : 648e             [ 3] 	stz num_a
c773 : 648f             [ 3] 	stz num_a+1
c775 : c000             [ 2] 	cpy #NUM_ANY
c777 : f014             [ 3] 	beq con_n_to_a_detect
c779 : 88               [ 2] 	dey
c77a : d003             [ 3] 	bne con_n_not_dec
c77c :                       con_dec_jmp
c77c : 4c10c8           [ 3] 	jmp con_dec_to_a_int
c77f :                       con_n_not_dec
c77f : 88               [ 2] 	dey
c780 : d003             [ 3] 	bne con_n_not_hex
c782 :                       con_hex_jmp
c782 : 4ca7c7           [ 3] 	jmp con_hex_to_a_int
c785 :                       con_n_not_hex
c785 : 88               [ 2] 	dey
c786 : d003             [ 3] 	bne con_n_err
c788 :                       con_bin_jmp
c788 : 4ce6c7           [ 3] 	jmp con_bin_to_a_int
c78b :                       con_n_err
c78b : 38               [ 2] 	sec
c78c : 60               [ 6] 	rts
c78d :                       con_n_to_a_detect
c78d : b29a             [ 5] 	lda (num_tmp)
c78f : c930             [ 2] 	cmp #'0'
c791 : d0e9             [ 3] 	bne con_dec_jmp
c793 : a001             [ 2] 	ldy #1
c795 : b19a             [ 5] 	lda (num_tmp),y
c797 : 0920             [ 2] 	ora #0x20
c799 : c978             [ 2] 	cmp #'x'
c79b : f0e5             [ 3] 	beq con_hex_jmp
c79d : c962             [ 2] 	cmp #'b'
c79f : f0e7             [ 3] 	beq con_bin_jmp
c7a1 : 80d9             [ 3] 	bra con_dec_jmp
                             
                             ;****************************************
                             ;* con_hex_to_a
                             ;* Convert hex string to accumulator (unsigned)
                             ;* Input : Pointer to string (X=L, A=H)
                             ;* Output : num_a, num_a+1 contains word, X=numbe
                             ;* Regs affected : CS = Error
                             ;****************************************
AS65 Assembler for R6502 [1.42].                                     Page   39
-------------------------------- bank\bank0.s --------------------------------

c7a3 :                       con_hex_to_a
c7a3 : 869a             [ 3] 	stx num_tmp
c7a5 : 859b             [ 3] 	sta num_tmp+1
c7a7 :                       con_hex_to_a_int
c7a7 : a205             [ 2] 	ldx #5			; > 4 digits will cause error
c7a9 : a002             [ 2] 	ldy #2			; start at first digit
c7ab :                       con_hex_digit
c7ab : b19a             [ 5] 	lda (num_tmp),y
c7ad : 0920             [ 2] 	ora #0x20					; Make alpha in to lower case
c7af : 38               [ 2] 	sec							; Process high char in A
c7b0 : e930             [ 2] 	sbc #'0'					; Convert to hex nibble
c7b2 : c90a             [ 2] 	cmp #10						; If A < 10 then
c7b4 : 9002             [ 3] 	bcc con_hex_skip_x_f_1		; skip a-f adjustment
c7b6 : e927             [ 2] 	sbc #0x27					; Sub 7 to get in to A-F range
c7b8 :                       con_hex_skip_x_f_1
c7b8 : c910             [ 2] 	cmp #0x10					; Nibble should be <= 0x0f
c7ba : b01c             [ 3] 	bcs	con_hex_done			; Potentially done if not
c7bc : 48               [ 3] 	pha
                             	; make room for lo nibble
c7bd : 068e             [ 5] 	asl num_a
c7bf : 268f             [ 5] 	rol num_a+1
c7c1 : 068e             [ 5] 	asl num_a
c7c3 : 268f             [ 5] 	rol num_a+1
c7c5 : 068e             [ 5] 	asl num_a
c7c7 : 268f             [ 5] 	rol num_a+1
c7c9 : 068e             [ 5] 	asl num_a
c7cb : 268f             [ 5] 	rol num_a+1
                             	; save in low nibble
c7cd : 68               [ 4] 	pla
c7ce : 058e             [ 3] 	ora num_a
c7d0 : 858e             [ 3] 	sta num_a
c7d2 : c8               [ 2] 	iny
c7d3 : ca               [ 2] 	dex
c7d4 : d0d5             [ 3] 	bne con_hex_digit
                             	; if got to a 5th digit then error
c7d6 :                       con_hex_err
c7d6 : 38               [ 2] 	sec
c7d7 : 60               [ 6] 	rts
                             	; found a non-hex digit
c7d8 :                       con_hex_done
                             	; if no digits processed then error
c7d8 : c002             [ 2] 	cpy #2
c7da : f0fa             [ 3] 	beq con_hex_err
                             	; move y to x for digits processed
c7dc : 98               [ 2] 	tya
c7dd : aa               [ 2] 	tax
c7de : a902             [ 2] 	lda #NUM_HEX
c7e0 : 18               [ 2] 	clc
c7e1 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* con_bin_to_a
                             ;* Convert hex string to accumulator (unsigned)
                             ;* Input : Pointer to string (X=L, A=H)
                             ;* Output : num_a, num_a+1 contains word, X=numbe
                             ;* Regs affected : CS = Error
                             ;****************************************
c7e2 :                       con_bin_to_a
c7e2 : 869a             [ 3] 	stx num_tmp
c7e4 : 859b             [ 3] 	sta num_tmp+1
c7e6 :                       con_bin_to_a_int
c7e6 : a002             [ 2] 	ldy #2
AS65 Assembler for R6502 [1.42].                                     Page   40
-------------------------------- bank\bank0.s --------------------------------

c7e8 : a211             [ 2] 	ldx #17						; Max 16 binary digits allowed
c7ea :                       con_bin_digit
c7ea : b19a             [ 5] 	lda (num_tmp),y
c7ec : c930             [ 2] 	cmp #'0'
c7ee : 9010             [ 4] 	bcc con_bin_done
c7f0 : c932             [ 2] 	cmp #'1'+1
c7f2 : b00c             [ 4] 	bcs con_bin_done
                             	; sets C if '1' else resets C
c7f4 : 69cf             [ 2] 	adc #0xff-'0'
                             	; shift in digit
c7f6 : 268e             [ 5] 	rol num_a
c7f8 : 268f             [ 5] 	rol num_a+1
c7fa : c8               [ 2] 	iny
c7fb : ca               [ 2] 	dex
c7fc : d0ec             [ 3] 	bne con_bin_digit
                             	; on the 17th digit is too much, error
c7fe : 800a             [ 4] 	bra con_bin_err
c800 :                       con_bin_done
                             	; didn't process any digit = error
c800 : c002             [ 2] 	cpy #2
c802 : f006             [ 3] 	beq con_bin_err
                             	; put digits processed in to X
c804 : 98               [ 2] 	tya
c805 : aa               [ 2] 	tax
c806 : a903             [ 2] 	lda #NUM_BIN
c808 : 18               [ 2] 	clc
c809 : 60               [ 6] 	rts
c80a :                       con_bin_err
c80a : 38               [ 2] 	sec
c80b : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* con_d_to_a
                             ;* Convert decimal string to accumulator (SIGNED)
                             ;* Input : Pointer to string (X=L, A=H)
                             ;* Output : num_a, num_a+1 contains word, X=numbe
                             ;* Regs affected : CS = Error
                             ;****************************************
c80c :                       con_dec_to_a
c80c : 869a             [ 3] 	stx num_tmp
c80e : 859b             [ 3] 	sta num_tmp+1
c810 :                       con_dec_to_a_int
c810 : a000             [ 2] 	ldy #0
                             	; Detect if leading minus sign
c812 : b29a             [ 5] 	lda (num_tmp)
c814 : c92d             [ 2] 	cmp #'-'
c816 : d001             [ 3] 	bne str_d_find_end
                             	; skip over minus if found
c818 : c8               [ 2] 	iny
c819 :                       str_d_find_end
c819 : b19a             [ 5] 	lda (num_tmp),y
c81b : c930             [ 2] 	cmp #'0'
c81d : 9007             [ 3] 	bcc str_d_found_end
c81f : c93a             [ 2] 	cmp #'9'+1
c821 : b003             [ 3] 	bcs str_d_found_end
c823 : c8               [ 2] 	iny
c824 : 80f3             [ 3] 	bra str_d_find_end
c826 :                       str_d_found_end
c826 : c006             [ 2] 	cpy #6				; Biggest int is 6 chars
c828 : b04e             [ 3] 	bcs str_d_error		; e.g. -32767
c82a : 849d             [ 3] 	sty num_tmp+3
c82c : 649c             [ 3] 	stz num_tmp+2
AS65 Assembler for R6502 [1.42].                                     Page   41
-------------------------------- bank\bank0.s --------------------------------

c82e : 648e             [ 3] 	stz num_a
c830 : 648f             [ 3] 	stz num_a+1
c832 :                       str_d_process_digit
c832 : 88               [ 2] 	dey
c833 : 3026             [ 3] 	bmi str_d_digits_done
                             
c835 : b19a             [ 5] 	lda (num_tmp),y
                             
c837 : c92d             [ 2] 	cmp #'-'			; Got to minus sign?
c839 : f020             [ 3] 	beq str_d_digits_done ; also done
                             
c83b : 38               [ 2] 	sec
c83c : e930             [ 2] 	sbc #'0'
                             	; Convert digit to number
                             	; and then offset in to
                             	; look up table of powers
c83e : 18               [ 2] 	clc
c83f : 0a               [ 2] 	asl a
c840 : 659c             [ 3] 	adc num_tmp+2
                             	; X contains index to powers
c842 : aa               [ 2] 	tax
c843 : a58e             [ 3] 	lda num_a
c845 : 7d7ac8           [ 4] 	adc str_d_powers,x
c848 : 858e             [ 3] 	sta num_a
c84a : a58f             [ 3] 	lda num_a+1
c84c : 7d7bc8           [ 4] 	adc str_d_powers+1,x
c84f : 858f             [ 3] 	sta num_a+1
c851 : b025             [ 3] 	bcs str_d_error
                             	; Move to next power of 10 index
c853 : a59c             [ 3] 	lda num_tmp+2
c855 : 6914             [ 2] 	adc #20
c857 : 859c             [ 3] 	sta num_tmp+2
c859 : 80d7             [ 3] 	bra str_d_process_digit
c85b :                       str_d_digits_done
                             	; check if minus
c85b : b29a             [ 5] 	lda (num_tmp)
c85d : c92d             [ 2] 	cmp #'-'
c85f : d011             [ 3] 	bne str_d_skip_neg
c861 : a69d             [ 3] 	ldx num_tmp+3		; Must have >= 2 chars
c863 : e002             [ 2] 	cpx #2				; else it's an error
c865 : 9011             [ 3] 	bcc str_d_error
c867 : a68e             [ 3] 	ldx num_a
c869 : a58f             [ 3] 	lda num_a+1
c86b : 20dec8           [ 6] 	jsr twos_complement
c86e : 868e             [ 3] 	stx num_a
c870 : 858f             [ 3] 	sta num_a+1
c872 :                       str_d_skip_neg
c872 : a69d             [ 3] 	ldx num_tmp+3
c874 : a901             [ 2] 	lda #NUM_DEC
c876 : 18               [ 2] 	clc
c877 : 60               [ 6] 	rts
c878 :                       str_d_error
c878 : 38               [ 2] 	sec
c879 : 60               [ 6] 	rts
                             
c87a :                       str_d_powers
c87a : 00000100020003..      	dw	0, 1, 2, 3, 4, 5, 6, 7, 8, 9
c88e : 00000a0014001e..      	dw	0, 10, 20, 30, 40, 50, 60, 70, 80, 90
c8a2 : 00006400c8002c..      	dw	0, 100, 200, 300, 400, 500, 600, 700, 800, 90
c8b6 : 0000e803d007b8..      	dw	0, 1000, 2000, 3000, 4000, 5000, 6000, 7000, 
c8ca : 00001027204e30..      	dw	0, 10000, 20000, 30000, 40000, 50000, 60000, 
                             	
AS65 Assembler for R6502 [1.42].                                     Page   42
-------------------------------- bank\bank0.s --------------------------------

                             
                             ;****************************************
                             ;* twos_complement
                             ;* Twos complement of X,A (X=low)
                             ;* Input : X = Low byte, A = High Byte to convert
                             ;* Output : X,A in 2's complement
                             ;* Regs affected : P
                             ;****************************************
c8de :                       twos_complement
c8de : 49ff             [ 2] 	eor #0xff
c8e0 : 48               [ 3] 	pha
c8e1 : 8a               [ 2] 	txa
c8e2 : 49ff             [ 2] 	eor #0xff
c8e4 : aa               [ 2] 	tax
c8e5 : 68               [ 4] 	pla
c8e6 : e8               [ 2] 	inx
c8e7 : d001             [ 3] 	bne twos_complement_skip_X
c8e9 : 1a               [ 2] 	inc a
c8ea :                       twos_complement_skip_X
c8ea : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* hex_to_bcd
                             ;* Convert accumulator,X to BCD
                             ;* Input : X = Low byte, A = High Byte to convert
                             ;* Output : 3 bytes of num_a is updated
                             ;* Regs affected : P
                             ;****************************************
c8eb :                       hex_to_bcd
c8eb : 08               [ 3] 	php
c8ec : 48               [ 3] 	pha
c8ed : da               [ 3] 	phx
                             
c8ee : 869a             [ 3] 	stx num_tmp
c8f0 : 859b             [ 3] 	sta num_tmp+1
c8f2 : c980             [ 2] 	cmp #0x80			; Negative?
c8f4 : 9003             [ 3] 	bcc hex_to_bcd_skip_neg
c8f6 : 20dec8           [ 6] 	jsr twos_complement
c8f9 :                       hex_to_bcd_skip_neg
c8f9 : 648e             [ 3] 	stz num_a
c8fb : 648f             [ 3] 	stz num_a+1
c8fd : 6490             [ 3] 	stz num_a+2
c8ff : 6491             [ 3] 	stz num_a+3
c901 : a210             [ 2] 	ldx #16
c903 : f8               [ 2] 	sed
c904 :                       bin_to_bcd_bit
c904 : 069a             [ 5] 	asl num_tmp
c906 : 269b             [ 5] 	rol num_tmp+1
c908 : a58e             [ 3] 	lda num_a
c90a : 658e             [ 3] 	adc num_a
c90c : 858e             [ 3] 	sta num_a
c90e : a58f             [ 3] 	lda num_a+1
c910 : 658f             [ 3] 	adc num_a+1
c912 : 858f             [ 3] 	sta num_a+1
c914 : a590             [ 3] 	lda num_a+2
c916 : 6590             [ 3] 	adc num_a+2
c918 : 8590             [ 3] 	sta num_a+2
c91a : ca               [ 2] 	dex
c91b : d0e7             [ 3] 	bne bin_to_bcd_bit
                             	
c91d : fa               [ 4] 	plx
AS65 Assembler for R6502 [1.42].                                     Page   43
-------------------------------- bank\bank0.s --------------------------------

c91e : 68               [ 4] 	pla
c91f : 28               [ 4] 	plp
c920 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* bcd_to_str
                             ;* Convert num_buf to chars
                             ;* Input : num_a in BCD format
                             ;* Output : num_buf in ASCII 6 digits
                             ;* Output is big endian, input is not
                             ;* Regs affected : P
                             ;****************************************
c921 :                       bcd_to_str
c921 : 48               [ 3] 	pha
c922 : da               [ 3] 	phx
c923 : 5a               [ 3] 	phy
                             
c924 : a205             [ 2] 	ldx #5						; Index in to string
c926 : a000             [ 2] 	ldy #0						; Current BCD digit
c928 :                       bcd_str
c928 : b98e00           [ 4] 	lda num_a,y
                             	; Convert 1s digit of byte
c92b : 48               [ 3] 	pha
c92c : 290f             [ 2] 	and #0xf
c92e : 18               [ 2] 	clc
c92f : 6930             [ 2] 	adc #0x30
c931 : 959e             [ 4] 	sta num_buf,x
                             	; Convert 10s digit of byte
c933 : 68               [ 4] 	pla
c934 : 4a               [ 2] 	lsr a
c935 : 4a               [ 2] 	lsr a
c936 : 4a               [ 2] 	lsr a
c937 : 4a               [ 2] 	lsr a
c938 : 18               [ 2] 	clc
c939 : 6930             [ 2] 	adc #0x30					; Convert to ASCII
c93b : 959d             [ 4] 	sta num_buf-1,x
c93d : ca               [ 2] 	dex
c93e : ca               [ 2] 	dex
c93f : c8               [ 2] 	iny
c940 : c003             [ 2] 	cpy #3						; 3 BCD digits max
c942 : d0e4             [ 3] 	bne bcd_str
                             
c944 : 7a               [ 4] 	ply
c945 : fa               [ 4] 	plx
c946 : 68               [ 4] 	pla
c947 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* out_bcd
                             ;* Output a bcd string in num_buf
                             ;* Input : num_buf has the ASCII
                             ;* Input : C=1 print leading zeros else not
                             ;* Output : num_buf in ASCII 6 digits
                             ;* Output is big endian, input is not, Y=digits p
                             ;* Regs affected : P
                             ;****************************************
c948 :                       out_bcd
c948 : 48               [ 3] 	pha
c949 : da               [ 3] 	phx
c94a : 08               [ 3] 	php
c94b : a000             [ 2] 	ldy #0						; How many digits printed
c94d : a200             [ 2] 	ldx #0						; Index in to string
AS65 Assembler for R6502 [1.42].                                     Page   44
-------------------------------- bank\bank0.s --------------------------------

c94f :                       out_bcd_digit
c94f : b59e             [ 4] 	lda num_buf,x
c951 : c000             [ 2] 	cpy #0						; If not in leading zero mode
c953 : d008             [ 3] 	bne out_bcd_print			; No then go print
                             
c955 : c930             [ 2] 	cmp #'0'					; else check if zero
c957 : d004             [ 3] 	bne out_bcd_print			; No then go print
                             
c959 : 28               [ 4] 	plp
c95a : 08               [ 3] 	php
c95b : 9004             [ 3] 	bcc out_bcd_next			; If C=0 go to next digit, el
c95d :                       out_bcd_print
c95d : c8               [ 2] 	iny
c95e : 2049c4           [ 6] 	jsr io_put_ch
c961 :                       out_bcd_next
c961 : e8               [ 2] 	inx
c962 : e006             [ 2] 	cpx #6
c964 : d0e9             [ 3] 	bne out_bcd_digit
c966 : c000             [ 2] 	cpy #0						; If nothing printed
c968 : d006             [ 3] 	bne out_bcd_fin
c96a : a930             [ 2] 	lda #'0'					; Need to put out 1 zero
c96c : 2049c4           [ 6] 	jsr io_put_ch
c96f : c8               [ 2] 	iny
c970 :                       out_bcd_fin
c970 : 28               [ 4] 	plp
c971 : fa               [ 4] 	plx
c972 : 68               [ 4] 	pla
c973 : 18               [ 2] 	clc
c974 : 60               [ 6] 	rts
                             	
                             	
                             ;****************************************
                             ;* print_a_to_d
                             ;* Convert X,A to decimal string
                             ;* Input : X,A = number Low,High
                             ;* Input : C=1 print leading zeros else not
                             ;* Output : num_buf in ASCII max 6 digits
                             ;*          Y=digits printed including sign
                             ;* Output is big endian, input is not
                             ;* Regs affected : P
                             ;****************************************
c975 :                       print_a_to_d
c975 : 08               [ 3] 	php
c976 : 8980             [ 2] 	bit #0x80					; Check if sign bit is set
c978 : 1014             [ 3] 	bpl print_a_to_d_skip_neg	; Skip if not (postive
c97a : 20dec8           [ 6] 	jsr twos_complement			; Flip from 2s complement
c97d : a92d             [ 2] 	lda #'-'
c97f : 2049c4           [ 6] 	jsr io_put_ch
c982 : 20ebc8           [ 6] 	jsr hex_to_bcd				; Convert to BCD
c985 : 2021c9           [ 6] 	jsr bcd_to_str				; Convert BCD to string
c988 : 28               [ 4] 	plp							; Leading zeros preference
c989 : 2048c9           [ 6] 	jsr out_bcd
c98c : c8               [ 2] 	iny							; Account for sign
c98d : 60               [ 6] 	rts
c98e :                       print_a_to_d_skip_neg
c98e : 20ebc8           [ 6] 	jsr hex_to_bcd				; Convert to BCD
c991 : 2021c9           [ 6] 	jsr bcd_to_str				; Convert BCD to string
c994 : 28               [ 4] 	plp							; Leading zeros preference
c995 : 4c48c9           [ 3] 	jmp out_bcd					; Print +ve string
                             
                             
                             ;* Reset vector points here - 6502 starts here
AS65 Assembler for R6502 [1.42].                                     Page   45
-------------------------------- bank\bank0.s --------------------------------

c998 :                       init
                             ;	jmp init_test
                             	; First clear ram
                             ;	sei					; No need as disabled on startup
c998 : 4ccec9           [ 3] 	jmp init_ram		; jmp not jsr to ram initialiser
c99b :                       init_2					; init_ram will jump back to here
c99b : a2ff             [ 2] 	ldx #0xff			; Initialise stack pointer
c99d : 9a               [ 2] 	txs
                             ;	cld					; No need as disabled on startup
                             	
c99e : 20a4c9           [ 6] 	jsr kernel_init
                             
c9a1 : 4c81c5           [ 3] 	jmp main
                             
c9a4 :                       kernel_init
c9a4 : 20f7c5           [ 6] 	jsr init_irq		; Initialise IRQ handling
c9a7 : 207ec1           [ 6] 	jsr _init_acia		; initialise the serial chip
                             	
c9aa : 2096c1           [ 6] 	jsr _init_cia0		; initialise cia 0
c9ad : 20aec1           [ 6] 	jsr _init_cia1		; initialise cia 1
                             
c9b0 :                       kernel_test
c9b0 : 20f6c1           [ 6] 	jsr _init_snd		; initialise the sound chip
c9b3 : 200ec2           [ 6] 	jsr _init_keyboard	; initialise keyboard timer s
c9b6 : 20eec3           [ 6] 	jsr _vdp_init		; initialise vdp
c9b9 : a900             [ 2] 	lda #0				; Default = 40 column mode
c9bb : 2066c1           [ 6] 	jsr _gr_init_screen
c9be : 2006c4           [ 6] 	jsr io_init			; Set default input/output device
c9c1 : 20dec1           [ 6] 	jsr _init_sdcard	; initialise the sd card interf
c9c4 : 20c6c1           [ 6] 	jsr _init_fs		; initialise the filesystem
c9c7 : 640c             [ 3] 	stz vdp_cnt
c9c9 : 202ec0           [ 6] 	jsr _df_init		; Initialise interpreter
                             
c9cc : 58               [ 2] 	cli					; irq interrupts enable
                             
c9cd : 60               [ 6] 	rts
                             
                             	
                             ;* Initialises RAM, skipping pages 4-8 which are 
                             ;* Zeroes all addressable RAM in the default bank
c9ce :                       init_ram
c9ce : 6400             [ 3] 	stz 0x00			; Start at page 0
c9d0 : 6401             [ 3] 	stz 0x01
c9d2 : a002             [ 2] 	ldy #0x02			; But Y initially at 2 to not overwr
c9d4 : a200             [ 2] 	ldx #0x00			; Page counter starts at zero
c9d6 :                       init_ram_1
c9d6 : e004             [ 2] 	cpx	#4				; Page <4 is ok
c9d8 : 9006             [ 3] 	bcc init_ram_fill
c9da : e008             [ 2] 	cpx #8				; Page >=8 is ok
c9dc : b002             [ 3] 	bcs init_ram_fill
c9de : 800a             [ 3] 	bra init_ram_skip
c9e0 :                       init_ram_fill
c9e0 : a900             [ 2] 	lda #0				; Normal RAM filled with zero
c9e2 : e0c0             [ 2] 	cpx #0xc0			; but page 0xC0-0xFF copied from ROM
c9e4 : 9002             [ 3] 	bcc init_ram_zero
c9e6 : b100             [ 5] 	lda (0x00),y		; Read from ROM area
c9e8 :                       init_ram_zero
c9e8 : 9100             [ 5] 	sta (0x00),y		; Write byte to RAM (zero or copy 
c9ea :                       init_ram_skip
c9ea : c8               [ 2] 	iny
c9eb : d0e9             [ 3] 	bne init_ram_1		; Do a whole page
c9ed : e601             [ 5] 	inc 0x01			; Increase page pointer
AS65 Assembler for R6502 [1.42].                                     Page   46
-------------------------------- bank\bank0.s --------------------------------

c9ef : e8               [ 2] 	inx					; Reduce page count
c9f0 : e000             [ 2] 	cpx #0x00			; Do all pages until page 0xff done 
c9f2 : d0e2             [ 3] 	bne init_ram_1
                             	
c9f4 : 4c9bc9           [ 3] 	jmp init_2			; Carry on initialisation
                             
                             ; 6502 Non-maskable interrupt come here
c9f7 :                       nmi
c9f7 : 40               [ 6] 	rti
                             
c9f8 :                       mod_sz_kernel_e
                             
                             
                             	
                             ; Bank specific code goes here
                             	include "cia\cia.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  CIA.S
                             ;*  Code to initialise and utilise the two WDC65c
                             ;*
                             ;*  VIA1 is for keyboard, LEDs and RAM memory ban
                             ;*		Port A
                             ;*			PA0 to PA7 	- All output to keyboard
                             ;*		Port B
                             ;*			PB0			- Input from BBC keboard to sense matr
                             ;*			PB1			- Output - Led 0 (cassette motor Led)
                             ;*			PB2			- Output - Led 1 (caps lock Led)
                             ;*			PB3			- Output - Led 2 (shift lock Led)
                             ;*			PB4			- Output bit X0 RAM bank selector
                             ;*			PB5			- Output bit X1 RAM bank selector
                             ;*			PB6			- Output bit Y0 ROM bank selector
                             ;*			PB7			- Output bit Y1 ROM bank selector
                             ;*
                             ;*  VIA2 is for AY-3-8910 sound chip, SD Card int
                             ;*		Port A
                             ;*			PA0 to PA7	- Connected to 8910 data bus for 
                             ;*		Port B
                             ;*			PB0			- Output to SD card clock
                             ;*			PB1			- Output - Sound write select
                             ;*			PB2			- Input - SD Card detect
                             ;*			PB3			- Output - SD Card chip select
                             ;*			PB4			- Output - Data out from VIA to SD Car
                             ;*			PB5			- Output - ROM Disable (active low)
                             ;*			PB6			- Output - Sound read select
                             ;*			PB7			- Input - Data in to VIA from SD Card
                             ;*
                             ;*  This file is called cia.s because the origina
                             ;*  used a MOS 6526 from a CMB64.  However I upda
                             ;*  design to use two 6522 chips, but never got a
                             ;*  renaming the file ;-)
                             ;*
                             ;************************************************
                             
                             
                             	; ROM code
AS65 Assembler for R6502 [1.42].                                     Page   47
-------------------------------- bank\bank0.s --------------------------------

                             	code
                             
c9f8 :                       mod_sz_cia_s
                             	
                             ;********************************
                             ;* set_led0
                             ;* Set the LED0 (cassette motor)
                             ;* Input : C = status (1 = on, 0 = off)
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
c9f8 :                       set_led0
c9f8 : 48               [ 3] 	pha							; Save A
c9f9 : ad0004           [ 4] 	lda IO_0 + PRB				; Get current led status
c9fc : 0902             [ 2] 	ora #KB_LED0					; Initially assume off
c9fe : 9002             [ 4] 	bcc skip_led0_on
ca00 : 4902             [ 2] 	eor #KB_LED0					; Switch on if C=1
ca02 :                       skip_led0_on
ca02 : 8d0004           [ 4] 	sta IO_0 + PRB				; Set the leds
ca05 : 68               [ 4] 	pla							; Restore A
ca06 : 60               [ 6] 	rts
                             
                             ;********************************
                             ;* set_led1
                             ;* Set the LED1 (caps lock)
                             ;* Input : C = status (1 = on, 0 = off)
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
ca07 :                       set_led1
ca07 : 48               [ 3] 	pha							; Save A
ca08 : ad0004           [ 4] 	lda IO_0 + PRB				; Get current led status
ca0b : 0904             [ 2] 	ora #KB_LED1				; Initially assume off
ca0d : 9002             [ 3] 	bcc skip_led1_on
ca0f : 4904             [ 2] 	eor #KB_LED1				; Switch on if C=1
ca11 :                       skip_led1_on
ca11 : 8d0004           [ 4] 	sta IO_0 + PRB				; Set the leds
ca14 : 68               [ 4] 	pla							; Restore A
ca15 : 60               [ 6] 	rts
                             
                             ;********************************
                             ;* set_led2
                             ;* Set the LED2 (shift lock)
                             ;* Input : C = status (1 = on, 0 = off)
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
ca16 :                       set_led2
ca16 : 48               [ 3] 	pha							; Save A
ca17 : ad0004           [ 4] 	lda IO_0 + PRB				; Get current led status
ca1a : 0908             [ 2] 	ora #KB_LED2				; Initially assume off
ca1c : 9002             [ 3] 	bcc skip_led2_on
ca1e : 4908             [ 2] 	eor #KB_LED2				; Switch on if C=1
ca20 :                       skip_led2_on
ca20 : 8d0004           [ 4] 	sta IO_0 + PRB				; Set the leds
ca23 : 68               [ 4] 	pla							; Restore A
ca24 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* init_cia0
                             ;* Initialise cia 0, controls the BBC keyboard
                             ;* Input : None
AS65 Assembler for R6502 [1.42].                                     Page   48
-------------------------------- bank\bank0.s --------------------------------

                             ;* Output : None
                             ;* Regs affected : A
                             ;****************************************
ca25 :                       init_cia0
ca25 : a97f             [ 2] 	lda #0x7f					; Disable all interrupts
ca27 : 8d0e04           [ 4] 	sta IO_0 + IER
ca2a : a9ff             [ 2] 	lda #0xff					; Clear IFR
ca2c : 8d0d04           [ 4] 	sta IO_0 + IFR				; Set IFR to clear flags
                             	
                             
ca2f : a9ff             [ 2] 	lda #0xff			
ca31 : 8d0304           [ 4] 	sta IO_0 + DDRA				; Port A all output
                             
ca34 : a9fe             [ 2] 	lda #0xfe					; Make sure all outputs are high!
ca36 : 8d0004           [ 4] 	sta IO_0 + PRB
                             	
ca39 : 8d0204           [ 4] 	sta IO_0 + DDRB				; Port B output for leds and 
                             
ca3c : a900             [ 2] 	lda #0x00					; Init control register - nothing 
ca3e : 8d0b04           [ 4] 	sta IO_0 + ACR
ca41 : a902             [ 2] 	lda #0x02					; CA2 independent interrupt
ca43 : 8d0c04           [ 4] 	sta IO_0 + PCR
                             
ca46 : a980             [ 2] 	lda #KB_EN 					; Set KB_EN bit to allow h/w str
ca48 : 8d0104           [ 4] 	sta IO_0 + PRA
                             	
                             	; LEDS off
ca4b : 38               [ 2] 	sec
ca4c : 20f8c9           [ 6] 	jsr set_led0
ca4f : 2007ca           [ 6] 	jsr set_led1
ca52 : 2016ca           [ 6] 	jsr set_led2
                             
ca55 : 60               [ 6] 	rts							; return from sub
                             	
                             ;****************************************
                             ;* init_cia1
                             ;* Initialise cia 1, controls the sound chip
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : A
                             ;****************************************
ca56 :                       init_cia1
ca56 : a97f             [ 2] 	lda #0x7f					; Disable all interrupts
ca58 : 8d8e04           [ 4] 	sta IO_1 + IER
                             	
ca5b : a9ff             [ 2] 	lda #0xff					; Port A all output (AY-3 data bus
ca5d : 8d8304           [ 4] 	sta IO_1 + DDRA
                             	
ca60 : a920             [ 2] 	lda #MM_DIS					; Make sure ROM is enabled in po
ca62 : 8d8004           [ 4] 	sta IO_1+PRB				; setting the data direction reg
                             	
ca65 : a97b             [ 2] 	lda #0b01111011				; Set Port B input/output SD,
ca67 : 8d8204           [ 4] 	sta IO_1+DDRB
                             	
ca6a : a900             [ 2] 	lda #0x00					; Init control register - nothing 
ca6c : 8d8b04           [ 4] 	sta IO_1 + ACR
ca6f : 8d8c04           [ 4] 	sta IO_1 + PCR
                             
ca72 : a9ff             [ 2] 	lda #0xff					; Clear IFR
ca74 : 8d8d04           [ 4] 	sta IO_1 + IFR				; Read ICR to clear flags
                             	
ca77 : 60               [ 6] 	rts							; return from sub
AS65 Assembler for R6502 [1.42].                                     Page   49
-------------------------------- bank\bank0.s --------------------------------

                             
ca78 :                       mod_sz_cia_e
                             
                             	include "serial\serial.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  SERIAL.S
                             ;*  Serial input/output handler - driving a 6551 
                             ;*  To handle WDC65c51 bug on transmit, use a del
                             ;*  to ensure byte is transmitted before the next
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             
                             
                             ;****************************************
                             ;* get_byte
                             ;* Get a byte (wait forever or just check)
                             ;* Input : C = 1 for synchronous, 0 for async
                             ;* Output : A = Byte code, C = 1 means A is inval
                             ;* Regs affected : P, A
                             ;****************************************
ca78 :                       get_byte
ca78 : ad8105           [ 4] 	lda SER_STATUS			; Check status register
ca7b : 2908             [ 2] 	and #SER_RDRF			; Is Receive Data Register Full 
ca7d : d004             [ 3] 	bne got_byte
ca7f : b0f7             [ 3] 	bcs get_byte			; If C then keep waiting
ca81 : 38               [ 2] 	sec						; Indicate byte was not got
ca82 : 60               [ 6] 	rts						; If not C then return immediately
ca83 :                       got_byte
ca83 : 18               [ 2] 	clc						; Indicate byte was got
ca84 : ad8005           [ 4] 	lda SER_DATA			; Read data
ca87 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* put_byte
                             ;* Put a byte out
                             ;* Input : A = Byte to put
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
ca88 :                       put_byte
ca88 : 48               [ 3] 	pha						; Save A
                             ;	phx
                             ;	ldx #112				; Loop 112 times
ca89 :                       put_byte_wait				; Delay 2512 cycles (19200bps, 1
                             ;	nop						; For 5.36Mhz clock
                             ;	nop						; ~25 cycles per loop (10xnop+dex+bne)
                             ;	nop						; 
                             ;	nop						; 
                             ;	nop						; 
                             ;	nop						; 
                             ;	nop						; 
                             ;	nop						; 
AS65 Assembler for R6502 [1.42].                                     Page   50
-------------------------------- bank\bank0.s --------------------------------

                             ;	nop						; 
                             ;	nop						; 
                             ;	dex						;
ca89 : ad8105           [ 4] 	lda SER_STATUS			; Check status register
ca8c : 2910             [ 2] 	and #SER_TDRE			; Is transmit reg empty?
ca8e : f0f9             [ 3] 	beq put_byte_wait		; Keep waiting if not
                             ;	plx						; restore X
ca90 : 68               [ 4] 	pla						; Get A back
ca91 : 8d8005           [ 4] 	sta SER_DATA			; Write the data
ca94 : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* init_acia
                             ;* ACIA initialisation (this is IO_2)
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : X
                             ;****************************************
ca95 :                       init_acia
ca95 : a21f             [ 2] 	ldx #0b00011111			; 19200 baud, 8 bits, 1 stop b
ca97 : 8e8305           [ 4] 	stx SER_CTL
ca9a : a20b             [ 2] 	ldx #0b00001011			; No parity, no TX int plus RT
ca9c : 8e8205           [ 4] 	stx SER_CMD
ca9f : ae8105           [ 4] 	ldx SER_STATUS			; Read status reg to clear stuf
                             
caa2 : 60               [ 6] 	rts
                             
                             	include "keyboard\keyboard.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  KEYBOARD.S
                             ;*  This is the keyboard module to enable interfa
                             ;*  BBC keyboard using a 65c22.  The BBC keyboard
                             ;*  in that it provides a signal to know if somet
                             ;*  pressed in hardware, so the more cycle heavy 
                             ;*  actually check which key etc can be done only
                             ;*  necessary.  Debouncing is necessary to not sc
                             ;*  often, with the timing for this happening dur
                             ;*  interrupt cycle.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             
                             ;****************************************
                             ;* init_keyboard
                             ;* Initialise the keyboard settings
                             ;****************************************
caa3 :                       init_keyboard
caa3 : a91e             [ 2] 	lda #KB_REP_DEL
caa5 : 8536             [ 3] 	sta kb_rep_del
caa7 : a905             [ 2] 	lda #KB_REP_TIM
caa9 : 8535             [ 3] 	sta kb_rep_tim
caab : a903             [ 2] 	lda #KB_DEBOUNCE
AS65 Assembler for R6502 [1.42].                                     Page   51
-------------------------------- bank\bank0.s --------------------------------

caad : 8537             [ 3] 	sta kb_debounce
caaf : 6432             [ 3] 	stz kb_stat
cab1 : 60               [ 6] 	rts
                             	
                             
                             ;****************************************
                             ;* kb_read_raw
                             ;* Read keyboard (not shift+ctrl)
                             ;* X = Keyboard code
                             ;* Carry = 1 means key found, 0 = no keys found
                             ;****************************************
cab2 :                       kb_read_raw
cab2 : 48               [ 3] 	pha
cab3 : 5a               [ 3] 	phy
                             
cab4 : a901             [ 2] 	lda #KB_W				; This is the mask to look for
cab6 : a000             [ 2] 	ldy #0					; Start at row 1, column 0, KB_EN is 
cab8 :                       kb_check_w_col
cab8 : a207             [ 2] 	ldx #7					; Only 7 rows as row zero is skipped
caba : c8               [ 2] 	iny						; Increment past row 0
cabb :                       kb_check_w_key
cabb : 8c0104           [ 4] 	sty IO_0 + PRA			; Set the row and column with K
cabe : ea               [ 2] 	nop						; Short delay for fast CPU
cabf : ea               [ 2] 	nop						; Short delay for fast CPU
cac0 : 2c0004           [ 4] 	bit IO_0 + PRB			; Bit test for the W status
cac3 : d00b             [ 3] 	bne got_key				; Found key
cac5 : c8               [ 2] 	iny						; Advance row
cac6 : ca               [ 2] 	dex						; Do each row
cac7 : d0f2             [ 3] 	bne kb_check_w_key
cac9 : c050             [ 2] 	cpy #0b01010000			; If not got to column 10 then
cacb : d0eb             [ 3] 	bne kb_check_w_col
                             
cacd :                       kb_no_key
                             	; no key found
cacd : 18               [ 2] 	clc						; Clear carry flag = no keys found
cace : 8045             [ 4] 	bra kb_raw_done			; Exit nicely
                             
cad0 :                       got_key
cad0 : 842f             [ 3] 	sty kb_raw				; Save the raw key code
cad2 : beb3cb           [ 4] 	ldx kb_table_std,y		; Load up standard key code 
cad5 : a900             [ 2] 	lda #0b00000000			; Check shift pressed (row=0, 
cad7 : 8d0104           [ 4] 	sta IO_0 + PRA
cada : ea               [ 2] 	nop						; Short delay for fast CPU
cadb : ea               [ 2] 	nop						; Short delay for fast CPU
cadc : ad0004           [ 4] 	lda IO_0 + PRB			; Read w
cadf : 2901             [ 2] 	and #KB_W
cae1 : d006             [ 3] 	bne do_shifted_key
cae3 : a532             [ 3] 	lda kb_stat
cae5 : 2902             [ 2] 	and #KB_SHIFTLK			; Check shift lock
cae7 : f003             [ 3] 	beq skip_shifted_key	
cae9 :                       do_shifted_key
cae9 : be04cc           [ 4] 	ldx kb_table_shift,y	; Overwrite X with shifted 
caec :                       skip_shifted_key
caec : a908             [ 2] 	lda #0b00001000			; Check ctrl pressed (row=0, c
caee : 8d0104           [ 4] 	sta IO_0 + PRA
caf1 : ea               [ 2] 	nop						; Short delay for fast CPU
caf2 : ea               [ 2] 	nop						; Short delay for fast CPU
caf3 : ad0004           [ 4] 	lda IO_0 + PRB			; Read w
caf6 : 2901             [ 2] 	and #KB_W
caf8 : f006             [ 4] 	beq skip_ctrl_key
cafa : 8a               [ 2] 	txa						; If ctrl pressed then only take bottom
cafb : 291f             [ 2] 	and #0x1f				; Which will result in codes 0 to 3
AS65 Assembler for R6502 [1.42].                                     Page   52
-------------------------------- bank\bank0.s --------------------------------

cafd : aa               [ 2] 	tax
cafe : 8012             [ 4] 	bra skip_caps_lock		; no point in checking caps 
cb00 :                       skip_ctrl_key
cb00 : a532             [ 3] 	lda kb_stat				; Check caps lock
cb02 : 2901             [ 2] 	and #KB_CAPSLK
cb04 : f00c             [ 3] 	beq skip_caps_lock
cb06 : 8a               [ 2] 	txa						; Easier to modify in A
cb07 : c961             [ 2] 	cmp #'a'				; If < 'a' then skip
cb09 : 9007             [ 3] 	bcc skip_caps_lock
cb0b : c97b             [ 2] 	cmp #'z'+1				; If > 'z' then skip
cb0d : b003             [ 3] 	bcs skip_caps_lock
cb0f : 4920             [ 2] 	eor #0x20				; Switch off bit 0x20
cb11 : aa               [ 2] 	tax						; to make upper case
cb12 :                       skip_caps_lock
cb12 : 8631             [ 3] 	stx kb_code				; Store mapped key code
cb14 : 38               [ 2] 	sec						; Set carry flag = key found
                             	
cb15 :                       kb_raw_done
cb15 : a080             [ 2] 	ldy #KB_EN				; Re-enable h/w strobe
cb17 : 8c0104           [ 4] 	sty IO_0 + PRA
cb1a : 7a               [ 4] 	ply
cb1b : 68               [ 4] 	pla
cb1c : 60               [ 6] 	rts
                             
                             	
                             ;****************************************
                             ;* kb_read_dip
                             ;* Scans options dip switch
                             ;* A = Options code for all 8 bits
                             ;****************************************
cb1d :                       kb_read_dip
cb1d : 5a               [ 3] 	phy
                             
cb1e : a000             [ 2] 	ldy #0
cb20 : 643f             [ 3] 	stz tmp_a
cb22 :                       kb_check_dip
cb22 : b955cc           [ 4] 	lda kb_dip_code, y		; Binary dip code, row = 0, 
cb25 : 8d0104           [ 4] 	sta IO_0 + PRA
cb28 : ea               [ 2] 	nop						; Short delay for fast CPU
cb29 : ea               [ 2] 	nop						; Short delay for fast CPU
cb2a : ad0004           [ 4] 	lda IO_0 + PRB			; Read w
cb2d : 2901             [ 2] 	and #KB_W
cb2f : f007             [ 3] 	beq kb_skip_dip
cb31 : a53f             [ 3] 	lda tmp_a
cb33 : 195dcc           [ 4] 	ora kb_dip_bit, y		; Set the bit if option on
cb36 : 853f             [ 3] 	sta tmp_a
cb38 :                       kb_skip_dip
cb38 : c8               [ 2] 	iny
cb39 : c008             [ 2] 	cpy #8
cb3b : d0e5             [ 3] 	bne kb_check_dip
cb3d : a53f             [ 3] 	lda tmp_a
                             
cb3f : a080             [ 2] 	ldy #KB_EN				; Re-enable h/w strobe
cb41 : 8c0104           [ 4] 	sty IO_0 + PRA
                             
cb44 : 7a               [ 4] 	ply
cb45 : 60               [ 6] 	rts
                             	
                             	
                             ;****************************************
                             ;* kb_scan_key
                             ;* Scans for a key, returns zero for no key found
AS65 Assembler for R6502 [1.42].                                     Page   53
-------------------------------- bank\bank0.s --------------------------------

                             ;* Processes caps and shift lock but these don't 
                             ;* A = Key code
                             ;****************************************
cb46 :                       kb_scan_key
cb46 : a538             [ 3] 	lda kb_pressed			; or if interrupt handler didn'
cb48 : f01d             [ 3] 	beq kb_scan_zero			
cb4a : 6438             [ 3] 	stz kb_pressed			; Zero the flag to indicate a s
cb4c : 5a               [ 3] 	phy
cb4d : da               [ 3] 	phx
                             	
cb4e : a436             [ 3] 	ldy kb_rep_del			; Initially, assuming normal re
cb50 : 20b2ca           [ 6] 	jsr kb_read_raw			; H/W scan of keyboard
cb53 : 9010             [ 3] 	bcc kb_scan_nothing		; C clear means nothing fou
cb55 : e080             [ 2] 	cpx #0x80				; Was it a special key (caps/shift 
cb57 : b01a             [ 3] 	bcs kb_special			; If so process
cb59 : a52f             [ 3] 	lda kb_raw
cb5b : c530             [ 3] 	cmp kb_last
cb5d : d00b             [ 3] 	bne kb_return_code		; This key different from la
cb5f : a435             [ 3] 	ldy kb_rep_tim
cb61 : a634             [ 3] 	ldx kb_rep				; If repeat timer is zero then emi
cb63 : f005             [ 3] 	beq kb_return_code
                             
cb65 :                       kb_scan_nothing
cb65 : fa               [ 4] 	plx
cb66 : 7a               [ 4] 	ply
cb67 :                       kb_scan_zero
cb67 : a900             [ 2] 	lda #0					; 0 = no key	
cb69 : 60               [ 6] 	rts
cb6a :                       kb_return_code				; Return a key because raw != l
cb6a : 8434             [ 3] 	sty kb_rep				; Delay before the same key is emi
cb6c : 8530             [ 3] 	sta kb_last				; Now make last = raw
                             	
cb6e : fa               [ 4] 	plx
cb6f : 7a               [ 4] 	ply
                             	
cb70 : a531             [ 3] 	lda kb_code				; Get the actual code
                             	
cb72 : 60               [ 6] 	rts
                             
cb73 :                       kb_special					; Process special keys
cb73 : e430             [ 3] 	cpx kb_last				; If last is not zero then don't 
cb75 : f0ee             [ 3] 	beq kb_scan_nothing		; special keys don't obey r
cb77 : 8630             [ 3] 	stx kb_last				; Update last
cb79 : e08a             [ 2] 	cpx #0x8a				; CAPS?
cb7b : f015             [ 3] 	beq kb_caps_lock		; Yes
cb7d : e08b             [ 2] 	cpx #0x8b				; Shift Lock?
cb7f : d0e4             [ 3] 	bne kb_scan_nothing		; No, then found nothing (F
                             	;Process shift lock
cb81 : a532             [ 3] 	lda kb_stat
cb83 : 4902             [ 2] 	eor #KB_SHIFTLK
cb85 : 8532             [ 3] 	sta kb_stat
cb87 : 18               [ 2] 	clc
cb88 : 2902             [ 2] 	and #KB_SHIFTLK
cb8a : f001             [ 3] 	beq kb_skip_shiftlk
cb8c : 38               [ 2] 	sec
cb8d :                       kb_skip_shiftlk
cb8d : 2016ca           [ 6] 	jsr set_led2
cb90 : 80d3             [ 3] 	bra kb_scan_nothing
                             	;Process caps lock
cb92 :                       kb_caps_lock
cb92 : a532             [ 3] 	lda kb_stat
cb94 : 4901             [ 2] 	eor #KB_CAPSLK
AS65 Assembler for R6502 [1.42].                                     Page   54
-------------------------------- bank\bank0.s --------------------------------

cb96 : 8532             [ 3] 	sta kb_stat
cb98 : 18               [ 2] 	clc
cb99 : 2901             [ 2] 	and #KB_CAPSLK
cb9b : f001             [ 3] 	beq kb_skip_capslk
cb9d : 38               [ 2] 	sec
cb9e :                       kb_skip_capslk
cb9e : 2007ca           [ 6] 	jsr set_led1
cba1 : 80c2             [ 3] 	bra kb_scan_nothing
                             
                             ;****************************************
                             ;* kb_get_key
                             ;* Waits for a key press, C=1 synchronous
                             ;* A = Key code
                             ;****************************************
cba3 :                       kb_get_key
cba3 : 08               [ 3] 	php
cba4 : 2046cb           [ 6] 	jsr kb_scan_key
cba7 : c900             [ 2] 	cmp #0
cba9 : d005             [ 3] 	bne kb_scan_got_key
cbab : 28               [ 4] 	plp						; No key, so check C
cbac : b0f5             [ 3] 	bcs kb_get_key			; Keep looking if C
cbae : 38               [ 2] 	sec						; Indicate key not got
cbaf : 60               [ 6] 	rts
cbb0 :                       kb_scan_got_key
cbb0 : 28               [ 4] 	plp						; Pull stack
cbb1 : 18               [ 2] 	clc						; Indicate key valid
cbb2 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* kb_table_std (no shift)
                             ;* Keyboard table - zero indicates nothing
                             ;****************************************
cbb3 :                       kb_table_std
cbb3 : 00                    	db 0x00								; Zero entry means nothing
cbb4 : 7180318a8b091b        	db 'q',0x80, '1',0x8a,0x8b,   9, 27	; Q, F0, 1, 
cbbb : 00                    	db 0x00								; Skip row 0
cbbc : 33773261737a81        	db '3', 'w', '2', 'a', 's', 'z',0x81; 3, W, 2, A
cbc3 : 00                    	db 0x00								; Skip row 0
cbc4 : 34656478632082        	db '4', 'e', 'd', 'x', 'c', ' ',0x82; 4, E, D, X
cbcb : 00                    	db 0x00								; Skip row 0
cbcc : 35747266677683        	db '5', 't', 'r', 'f', 'g', 'v',0x83; 5, T, R, F
cbd3 : 00                    	db 0x00								; Skip row 0
cbd4 : 84373679686285        	db 0x84,'7', '6', 'y', 'h', 'b',0x85; F4, 7, 6, 
cbdb : 00                    	db 0x00								; Skip row 0
cbdc : 3869756a6e6d86        	db '8', 'i', 'u', 'j', 'n', 'm',0x86; 8, I, U, J
cbe3 : 00                    	db 0x00								; Skip row 0
cbe4 : 87396f6b6c2c88        	db 0x87,'9', 'o', 'k', 'l', ',',0x88; F7, 9, O, 
cbeb : 00                    	db 0x00								; Skip row 0
cbec : 2d3070403b2e89        	db '-', '0', 'p', '@', ';', '.',0x89; -, 0, P, @
cbf3 : 00                    	db 0x00								; Skip row 0
cbf4 : 5e5f5b3a5d2f5c        	db '^', '_', '[', ':', ']', '/', 92	; ^, _, [, :
cbfb : 00                    	db 0x00								; Skip row 0
cbfc : 080a0b0d7f0609        	db   8,  10,  11,  13, 127,   6,  9	; Left, Down
cc03 : 00                    	db 0x00								; Skip row 0
                             
                             ;****************************************
                             ;* kb_table_shift (with shift)
                             ;* Keyboard table - zero indicates nothing
                             ;****************************************
cc04 :                       kb_table_shift
cc04 : 00                    	db 0x00								; Zero entry means nothing
cc05 : 51c0218a8b091b        	db 'Q',0xc0, '!',0x8a,0x8b,   9, 27	; Q, F0, 1, 
AS65 Assembler for R6502 [1.42].                                     Page   55
-------------------------------- bank\bank0.s --------------------------------

cc0c : 00                    	db 0x00								; Skip row 0
cc0d : 23572241535ac1        	db '#', 'W', '"', 'A', 'S', 'Z',0xc1; 3, W, 2, A
cc14 : 00                    	db 0x00								; Skip row 0
cc15 : 244544584320c2        	db '$', 'E', 'D', 'X', 'C', ' ',0xc2; 4, E, D, X
cc1c : 00                    	db 0x00								; Skip row 0
cc1d : 255452464756c3        	db '%', 'T', 'R', 'F', 'G', 'V',0xc3; 5, T, R, F
cc24 : 00                    	db 0x00								; Skip row 0
cc25 : 842726594842c5        	db 0x84, 39, '&', 'Y', 'H', 'B',0xc5; F4, 7, 6, 
cc2c : 00                    	db 0x00								; Skip row 0
cc2d : 2849554a4e4dc6        	db '(', 'I', 'U', 'J', 'N', 'M',0xc6; 8, I, U, J
cc34 : 00                    	db 0x00								; Skip row 0
cc35 : 87294f4b4c3cc8        	db 0x87,')', 'O', 'K', 'L', '<',0xc8; F7, 9, O, 
cc3c : 00                    	db 0x00								; Skip row 0
cc3d : 3d3050402b3ec9        	db '=', '0', 'P', '@', '+', '>',0xc9; -, 0, P, @
cc44 : 00                    	db 0x00								; Skip row 0
cc45 : 7e607b2a7d3f7c        	db '~', 96, '{', '*', '}', '?', '|'	; ^, _, [, :
cc4c : 00                    	db 0x00								; Skip row 0
cc4d : 080a0b0d7f0609        	db   8,  10,  11,  13, 127,   6,  9	; Left, Down
cc54 : 00                    	db 0x00								; Skip row 0
                             
                             ; Option switches
cc55 :                       kb_dip_code
cc55 : 10                    	db 0b00010000
cc56 : 18                    	db 0b00011000
cc57 : 20                    	db 0b00100000
cc58 : 28                    	db 0b00101000
cc59 : 30                    	db 0b00110000
cc5a : 38                    	db 0b00111000
cc5b : 40                    	db 0b01000000
cc5c : 48                    	db 0b01001000
cc5d :                       kb_dip_bit
cc5d : 8040201008040201      	db 0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01
                             	
                             
                             	include "sound\sound.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  SOUND.S
                             ;*  Sound driver module - routines to access the 
                             ;*  This sound chip was found in a number of popu
                             ;*  in the early to mid 80s, including my first c
                             ;*  the Oric-1, as well as the MSX range.  Interf
                             ;*  chip is through port A of VIA 2 because it ca
                             ;*  connected directly to the 6502 bus.  This mea
                             ;*  is a bit clunky to drive, but this is how the
                             ;*  did it, so even though I came up with this in
                             ;*  I guess I can't be too wrong with this approa
                             ;*  The AY doesn't only produce sound, it also ha
                             ;*  of 8 bit IO port - one of them I am using for
                             ;*
                             ;*  NOTE:	As part of the ROM banking strategy, th
                             ;*			lowest level routines have been factored out
                             ;*			to the 'kernel' which means they are present
                             ;*			in every code bank.
                             ;*
                             ;************************************************
AS65 Assembler for R6502 [1.42].                                     Page   56
-------------------------------- bank\bank0.s --------------------------------

                             
                             
                             	; ROM code
                             	code
                             
cc65 :                       mod_sz_sound_s
                             
                             
                             ;****************************************
                             ;* snd_get_note
                             ;* Get a note from the music scale table
                             ;* Input : Y
                             ;* Output : A,X = Value hi,lo
                             ;* Regs affected : X
                             ;****************************************
cc65 :                       snd_get_note
cc65 : be8acc           [ 4] 	ldx snd_music_tab,y
cc68 : b98bcc           [ 4] 	lda snd_music_tab+1,y
cc6b : 60               [ 6] 	rts
                             
                             	
                             ;****************************************
                             ;* init_snd
                             ;* Initialise sound - after cia 1 has been initia
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : All
                             ;****************************************
cc6c :                       init_snd
cc6c : a200             [ 2] 	ldx #0x00
cc6e :                       init_snd_regs
cc6e : bc7acc           [ 4] 	ldy snd_init_tab,x
cc71 : 2023c5           [ 6] 	jsr snd_set				; Set X to Y
cc74 : e8               [ 2] 	inx
cc75 : e010             [ 2] 	cpx #16					; Done 16?
cc77 : d0f5             [ 3] 	bne init_snd_regs		; Nope	
                             	
cc79 : 60               [ 6] 	rts						; return from sub
                             
                             	; Register array initialisation values
                             	; Assuming 1.34Mhz input clock
cc7a :                       snd_init_tab
cc7a : 80                    	db 0x80				; R0 = Channel A Tone Low
cc7b : 00                    	db 0x00				; R1 = Channel A Tone High
cc7c : 00                    	db 0x00				; R2 = Channel B Tone Low
cc7d : 01                    	db 0x01				; R3 = Channel B Tone High
cc7e : 00                    	db 0x00				; R4 = Channel C Tone Low
cc7f : 02                    	db 0x02				; R5 = Channel C Tone High
cc80 : 00                    	db 0x00				; R6 = Noise period
cc81 : 3e                    	db 0b00111110		; R7 = Control : IOB input, IOA i
cc82 : 1f                    	db 0x1f				; R8 = Channel A Vol
cc83 : 1f                    	db 0x1f				; R9 = Channel B Vol
cc84 : 1f                    	db 0x1f				; R10 = Channel C Vol
cc85 : 00                    	db 0x00				; R11 = Envelope Period Low
cc86 : 09                    	db 0x09				; R12 = Envelope Period High
cc87 : 00                    	db 0b00000000		; R13 = Envelope Shape : 0000
cc88 : 00                    	db 0x00				; R14 = IO Port A
cc89 : 00                    	db 0x00				; R15 = IO Port B ; Initialise to 0
                             
cc8a :                       snd_music_tab
cc8a : 050a                  	dw 2565				; C		0
cc8c : 7509                  	dw 2421				; C#	1
AS65 Assembler for R6502 [1.42].                                     Page   57
-------------------------------- bank\bank0.s --------------------------------

cc8e : ee08                  	dw 2286				; D		2
cc90 : 6d08                  	dw 2157				; D#	3
cc92 : f407                  	dw 2036				; E		4
cc94 : 8207                  	dw 1922				; F		5
cc96 : 1607                  	dw 1814				; F#	6
cc98 : b006                  	dw 1712				; G		7
cc9a : 5006                  	dw 1616				; G#	8
cc9c : f505                  	dw 1525				; A		9
cc9e : a005                  	dw 1440				; A#	10
cca0 : 4f05                  	dw 1359				; B		11
                             	
cca2 : 0305                  	dw 1283				; C
cca4 : bb04                  	dw 1211				; C#
cca6 : 7704                  	dw 1143				; D
cca8 : 3704                  	dw 1079				; D#
ccaa : fa03                  	dw 1018				; E
ccac : c103                  	dw 961 				; F
ccae : 8b03                  	dw 907 				; F#
ccb0 : 5803                  	dw 856 				; G
ccb2 : 2803                  	dw 808 				; G#
ccb4 : fb02                  	dw 763 				; A
ccb6 : d002                  	dw 720 				; A#
ccb8 : a702                  	dw 679 				; B
                             
ccba : 8102                  	dw 641				; C
ccbc : 5d02                  	dw 605				; C#
ccbe : 3b02                  	dw 571				; D
ccc0 : 1b02                  	dw 539				; D#
ccc2 : fd01                  	dw 509				; E
ccc4 : e001                  	dw 480				; F
ccc6 : c501                  	dw 453				; F#
ccc8 : ac01                  	dw 428				; G
ccca : 9401                  	dw 404				; G#
cccc : 7d01                  	dw 381				; A
ccce : 6801                  	dw 360				; A#
ccd0 : 5401                  	dw 340				; B
                             
ccd2 : 4101                  	dw 321				; C
ccd4 : 2f01                  	dw 303				; C#
ccd6 : 1e01                  	dw 286				; D
ccd8 : 0e01                  	dw 270				; D#
ccda : fe00                  	dw 254				; E
ccdc : f000                  	dw 240				; F
ccde : e300                  	dw 227				; F#
cce0 : d600                  	dw 214				; G
cce2 : ca00                  	dw 202				; G#
cce4 : bf00                  	dw 191				; A
cce6 : b400                  	dw 180				; A#
cce8 : aa00                  	dw 170				; B
                             
ccea : a000                  	dw 160				; C
ccec : 9700                  	dw 151				; C#
ccee : 8f00                  	dw 143				; D
ccf0 : 8700                  	dw 135				; D#
ccf2 : 7f00                  	dw 127				; E
ccf4 : 7800                  	dw 120				; F
ccf6 : 7100                  	dw 113				; F#
ccf8 : 6b00                  	dw 107				; G
ccfa : 6500                  	dw 101				; G#
ccfc : 5f00                  	dw 95 				; A
ccfe : 5a00                  	dw 90 				; A#
cd00 : 5500                  	dw 85 				; B
AS65 Assembler for R6502 [1.42].                                     Page   58
-------------------------------- bank\bank0.s --------------------------------

                             
cd02 : 5000                  	dw 80				; C
cd04 : 4c00                  	dw 76				; C#
cd06 : 4700                  	dw 71				; D
cd08 : 4300                  	dw 67				; D#
cd0a : 4000                  	dw 64				; E
cd0c : 3c00                  	dw 60				; F
cd0e : 3900                  	dw 57				; F#
cd10 : 3600                  	dw 54				; G
cd12 : 3300                  	dw 51				; G#
cd14 : 3000                  	dw 48				; A
cd16 : 2d00                  	dw 45				; A#
cd18 : 2a00                  	dw 42				; B
                             
cd1a : 2800                  	dw 40				; C
cd1c : 2600                  	dw 38				; C#
cd1e : 2400                  	dw 36				; D
cd20 : 2200                  	dw 34				; D#
cd22 : 2000                  	dw 32				; E
cd24 : 1e00                  	dw 30				; F
cd26 : 1c00                  	dw 28				; F#
cd28 : 1b00                  	dw 27				; G
cd2a : 1900                  	dw 25				; G#
cd2c : 1800                  	dw 24				; A
cd2e : 1600                  	dw 22				; A#
cd30 : 1500                  	dw 21				; B
                             
cd32 :                       mod_sz_sound_e
                             
                             	include "vdp\vdp.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  VDP.S
                             ;*  This module implements the drivers of the VDP
                             ;*  a TMS9918a.  The VDP is interfaced to the 650
                             ;*  through a memory mapped IO (that's how the 65
                             ;*  There are only two bytes in the IO space that
                             ;*  and the 6502 needs to poke or read from these
                             ;*  delay to allow the VDP to detect and respond 
                             ;*  request.  It's interesting that delays are ne
                             ;*  MSX computer also used a TMS9918a but with Z8
                             ;*  CPU, which actually didn't need delays.  The 
                             ;*  a simple processor but a write instruction on
                             ;*  4 cycles, hence needing delays.
                             ;*  Considering it came out in the late 70s, the 
                             ;*  series of VDP are pretty impressive - 2 text 
                             ;*  a hires mode too ('a' variant).  Plus 32 hard
                             ;*  sprites and 15 colours - very good indeed. Al
                             ;*  uses its own memory so doesn't eat 6502 space
                             ;*  Downside to having its own memory is that it 
                             ;*  slow to do large updates e.g. scrolling.  Ok 
                             ;*  column screen can be scrolled and it looks ok
                             ;*  no way would I try to scroll a hires screen. 
                             ;*  why many games on the MSX didn't do smooth sc
                             ;*
                             ;*  NOTE:	As part of the ROM banking strategy, th
AS65 Assembler for R6502 [1.42].                                     Page   59
-------------------------------- bank\bank0.s --------------------------------

                             ;*			lowest level routines have been factored out
                             ;*			to the 'kernel' which means they are present
                             ;*			in every code bank.
                             ;*
                             ;************************************************
                             
                             
                             	; ROM code
                             	code
                             
cd32 :                       mod_sz_vdp_s
                             
                             	include "vdp\font.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  FONT.S
                             ;*  This is the font definition, used to initiali
                             ;*  character set.  The normal char 1 is either a
                             ;*  but I have set the default to be a little spa
                             ;*  This character set is a combination of the MS
                             ;*  special characters outside of the normal ASCI
                             ;*  and Oric-1 for letters, numbers, punctuation 
                             ;*  Oric was my first computer hence the nostalgi
                             ;*
                             ;************************************************
                             
cd32 : 00000000000000..      	align 256
                             	
ce00 :                       vdp_font
                             ; char 0
ce00 : 00                    	db %00000000
ce01 : 00                    	db %00000000
ce02 : 00                    	db %00000000
ce03 : 00                    	db %00000000
ce04 : 00                    	db %00000000
ce05 : 00                    	db %00000000
ce06 : 00                    	db %00000000
ce07 : 00                    	db %00000000
                             ; char 1 standard
                             ;	db %00000000
                             ;	db %00100000
                             ;	db %01110000
                             ;	db %11111000
                             ;	db %01110000
                             ;	db %00100000
                             ;	db %00000000
                             ;	db %00000000
                             ; char 1 space invader
ce08 : 18                    	db %00011000
ce09 : 3c                    	db %00111100
ce0a : 7e                    	db %01111110
ce0b : db                    	db %11011011
ce0c : ff                    	db %11111111
ce0d : 24                    	db %00100100
ce0e : 5a                    	db %01011010
ce0f : a5                    	db %10100101
AS65 Assembler for R6502 [1.42].                                     Page   60
-------------------------------- bank\bank0.s --------------------------------

                             ; char 2
ce10 : a8                    	db %10101000
ce11 : 54                    	db %01010100
ce12 : a8                    	db %10101000
ce13 : 54                    	db %01010100
ce14 : a8                    	db %10101000
ce15 : 54                    	db %01010100
ce16 : a8                    	db %10101000
ce17 : 54                    	db %01010100
                             ; char 3
ce18 : 20                    	db %00100000
ce19 : 70                    	db %01110000
ce1a : a8                    	db %10101000
ce1b : 20                    	db %00100000
ce1c : 20                    	db %00100000
ce1d : 20                    	db %00100000
ce1e : 20                    	db %00100000
ce1f : 00                    	db %00000000
                             ; char 4
ce20 : 20                    	db %00100000
ce21 : 20                    	db %00100000
ce22 : 20                    	db %00100000
ce23 : 20                    	db %00100000
ce24 : a8                    	db %10101000
ce25 : 70                    	db %01110000
ce26 : 20                    	db %00100000
ce27 : 00                    	db %00000000
                             ; char 5
ce28 : 00                    	db %00000000
ce29 : 20                    	db %00100000
ce2a : 40                    	db %01000000
ce2b : f8                    	db %11111000
ce2c : 40                    	db %01000000
ce2d : 20                    	db %00100000
ce2e : 00                    	db %00000000
ce2f : 00                    	db %00000000
                             ; char 6
ce30 : 00                    	db %00000000
ce31 : 20                    	db %00100000
ce32 : 10                    	db %00010000
ce33 : f8                    	db %11111000
ce34 : 10                    	db %00010000
ce35 : 20                    	db %00100000
ce36 : 00                    	db %00000000
ce37 : 00                    	db %00000000
                             ; char 7
ce38 : 60                    	db %01100000
ce39 : 90                    	db %10010000
ce3a : 90                    	db %10010000
ce3b : 60                    	db %01100000
ce3c : 00                    	db %00000000
ce3d : 00                    	db %00000000
ce3e : 00                    	db %00000000
ce3f : 00                    	db %00000000
                             ; char 8
ce40 : 20                    	db %00100000
ce41 : 20                    	db %00100000
ce42 : f8                    	db %11111000
ce43 : 20                    	db %00100000
ce44 : 20                    	db %00100000
ce45 : 00                    	db %00000000
ce46 : f8                    	db %11111000
AS65 Assembler for R6502 [1.42].                                     Page   61
-------------------------------- bank\bank0.s --------------------------------

ce47 : 00                    	db %00000000
                             ; char 9
ce48 : 00                    	db %00000000
ce49 : 00                    	db %00000000
ce4a : 00                    	db %00000000
ce4b : 00                    	db %00000000
ce4c : 00                    	db %00000000
ce4d : 00                    	db %00000000
ce4e : a8                    	db %10101000
ce4f : 00                    	db %00000000
                             ; char 10
ce50 : 00                    	db %00000000
ce51 : 00                    	db %00000000
ce52 : 08                    	db %00001000
ce53 : 10                    	db %00010000
ce54 : a0                    	db %10100000
ce55 : 40                    	db %01000000
ce56 : 00                    	db %00000000
ce57 : 00                    	db %00000000
                             ; char 11
ce58 : 30                    	db %00110000
ce59 : 30                    	db %00110000
ce5a : 30                    	db %00110000
ce5b : f0                    	db %11110000
ce5c : f0                    	db %11110000
ce5d : 00                    	db %00000000
ce5e : 00                    	db %00000000
ce5f : 00                    	db %00000000
                             ; char 12
ce60 : 00                    	db %00000000
ce61 : 00                    	db %00000000
ce62 : 00                    	db %00000000
ce63 : f0                    	db %11110000
ce64 : f0                    	db %11110000
ce65 : 30                    	db %00110000
ce66 : 30                    	db %00110000
ce67 : 30                    	db %00110000
                             ; char 13
ce68 : 00                    	db %00000000
ce69 : 00                    	db %00000000
ce6a : 00                    	db %00000000
ce6b : 3c                    	db %00111100
ce6c : 3c                    	db %00111100
ce6d : 30                    	db %00110000
ce6e : 30                    	db %00110000
ce6f : 30                    	db %00110000
                             ; char 14
ce70 : 30                    	db %00110000
ce71 : 30                    	db %00110000
ce72 : 30                    	db %00110000
ce73 : 3c                    	db %00111100
ce74 : 3c                    	db %00111100
ce75 : 00                    	db %00000000
ce76 : 00                    	db %00000000
ce77 : 00                    	db %00000000
                             ; char 15
ce78 : 30                    	db %00110000
ce79 : 30                    	db %00110000
ce7a : 30                    	db %00110000
ce7b : fc                    	db %11111100
ce7c : fc                    	db %11111100
ce7d : 30                    	db %00110000
AS65 Assembler for R6502 [1.42].                                     Page   62
-------------------------------- bank\bank0.s --------------------------------

ce7e : 30                    	db %00110000
ce7f : 30                    	db %00110000
                             ; char 16
ce80 : fc                    	db %11111100
ce81 : fc                    	db %11111100
ce82 : 00                    	db %00000000
ce83 : 00                    	db %00000000
ce84 : 00                    	db %00000000
ce85 : 00                    	db %00000000
ce86 : 00                    	db %00000000
ce87 : 00                    	db %00000000
                             ; char 17
ce88 : 00                    	db %00000000
ce89 : 00                    	db %00000000
ce8a : fc                    	db %11111100
ce8b : fc                    	db %11111100
ce8c : 00                    	db %00000000
ce8d : 00                    	db %00000000
ce8e : 00                    	db %00000000
ce8f : 00                    	db %00000000
                             ; char 18
ce90 : 00                    	db %00000000
ce91 : 00                    	db %00000000
ce92 : 00                    	db %00000000
ce93 : fc                    	db %11111100
ce94 : fc                    	db %11111100
ce95 : 00                    	db %00000000
ce96 : 00                    	db %00000000
ce97 : 00                    	db %00000000
                             ; char 19
ce98 : 00                    	db %00000000
ce99 : 00                    	db %00000000
ce9a : 00                    	db %00000000
ce9b : 00                    	db %00000000
ce9c : fc                    	db %11111100
ce9d : fc                    	db %11111100
ce9e : 00                    	db %00000000
ce9f : 00                    	db %00000000
                             ; char 20
cea0 : 00                    	db %00000000
cea1 : 00                    	db %00000000
cea2 : 00                    	db %00000000
cea3 : 00                    	db %00000000
cea4 : 00                    	db %00000000
cea5 : 00                    	db %00000000
cea6 : fc                    	db %11111100
cea7 : fc                    	db %11111100
                             ; char 21
cea8 : 30                    	db %00110000
cea9 : 30                    	db %00110000
ceaa : 30                    	db %00110000
ceab : 3c                    	db %00111100
ceac : 3c                    	db %00111100
cead : 30                    	db %00110000
ceae : 30                    	db %00110000
ceaf : 30                    	db %00110000
                             ; char 22
ceb0 : 30                    	db %00110000
ceb1 : 30                    	db %00110000
ceb2 : 30                    	db %00110000
ceb3 : f0                    	db %11110000
ceb4 : f0                    	db %11110000
AS65 Assembler for R6502 [1.42].                                     Page   63
-------------------------------- bank\bank0.s --------------------------------

ceb5 : 30                    	db %00110000
ceb6 : 30                    	db %00110000
ceb7 : 30                    	db %00110000
                             ; char 23
ceb8 : 30                    	db %00110000
ceb9 : 30                    	db %00110000
ceba : 30                    	db %00110000
cebb : fc                    	db %11111100
cebc : fc                    	db %11111100
cebd : 00                    	db %00000000
cebe : 00                    	db %00000000
cebf : 00                    	db %00000000
                             ; char 24
cec0 : 00                    	db %00000000
cec1 : 00                    	db %00000000
cec2 : 00                    	db %00000000
cec3 : fc                    	db %11111100
cec4 : fc                    	db %11111100
cec5 : 30                    	db %00110000
cec6 : 30                    	db %00110000
cec7 : 30                    	db %00110000
                             ; char 25
cec8 : 30                    	db %00110000
cec9 : 30                    	db %00110000
ceca : 30                    	db %00110000
cecb : 30                    	db %00110000
cecc : 30                    	db %00110000
cecd : 30                    	db %00110000
cece : 30                    	db %00110000
cecf : 30                    	db %00110000
                             ; char 26
ced0 : 08                    	db %00001000
ced1 : 30                    	db %00110000
ced2 : c0                    	db %11000000
ced3 : 30                    	db %00110000
ced4 : 08                    	db %00001000
ced5 : 00                    	db %00000000
ced6 : f8                    	db %11111000
ced7 : 00                    	db %00000000
                             ; char 27
ced8 : 80                    	db %10000000
ced9 : 60                    	db %01100000
ceda : 18                    	db %00011000
cedb : 60                    	db %01100000
cedc : 80                    	db %10000000
cedd : 00                    	db %00000000
cede : f8                    	db %11111000
cedf : 00                    	db %00000000
                             ; char 28
cee0 : 00                    	db %00000000
cee1 : 00                    	db %00000000
cee2 : f8                    	db %11111000
cee3 : 50                    	db %01010000
cee4 : 50                    	db %01010000
cee5 : 50                    	db %01010000
cee6 : 98                    	db %10011000
cee7 : 00                    	db %00000000
                             ; char 29
cee8 : 10                    	db %00010000
cee9 : 10                    	db %00010000
ceea : f8                    	db %11111000
ceeb : 20                    	db %00100000
AS65 Assembler for R6502 [1.42].                                     Page   64
-------------------------------- bank\bank0.s --------------------------------

ceec : f8                    	db %11111000
ceed : 40                    	db %01000000
ceee : 40                    	db %01000000
ceef : 00                    	db %00000000
                             ; char 30
cef0 : 30                    	db %00110000
cef1 : 48                    	db %01001000
cef2 : 40                    	db %01000000
cef3 : e0                    	db %11100000
cef4 : 40                    	db %01000000
cef5 : 48                    	db %01001000
cef6 : b0                    	db %10110000
cef7 : 00                    	db %00000000
                             ; char 31
cef8 : 00                    	db %00000000
cef9 : 00                    	db %00000000
cefa : 00                    	db %00000000
cefb : 20                    	db %00100000
cefc : 00                    	db %00000000
cefd : 00                    	db %00000000
cefe : 00                    	db %00000000
ceff : 00                    	db %00000000
                             ; char 32
cf00 : 00                    	db %00000000
cf01 : 00                    	db %00000000
cf02 : 00                    	db %00000000
cf03 : 00                    	db %00000000
cf04 : 00                    	db %00000000
cf05 : 00                    	db %00000000
cf06 : 00                    	db %00000000
cf07 : 00                    	db %00000000
                             ; char 33
cf08 : 20                    	db %00100000
cf09 : 20                    	db %00100000
cf0a : 20                    	db %00100000
cf0b : 20                    	db %00100000
cf0c : 20                    	db %00100000
cf0d : 00                    	db %00000000
cf0e : 20                    	db %00100000
cf0f : 00                    	db %00000000
                             ; char 34
cf10 : 50                    	db %01010000
cf11 : 50                    	db %01010000
cf12 : 50                    	db %01010000
cf13 : 00                    	db %00000000
cf14 : 00                    	db %00000000
cf15 : 00                    	db %00000000
cf16 : 00                    	db %00000000
cf17 : 00                    	db %00000000
                             ; char 35
cf18 : 50                    	db %01010000
cf19 : 50                    	db %01010000
cf1a : f8                    	db %11111000
cf1b : 50                    	db %01010000
cf1c : f8                    	db %11111000
cf1d : 50                    	db %01010000
cf1e : 50                    	db %01010000
cf1f : 00                    	db %00000000
                             ; char 36
cf20 : 20                    	db %00100000
cf21 : 78                    	db %01111000
cf22 : a0                    	db %10100000
AS65 Assembler for R6502 [1.42].                                     Page   65
-------------------------------- bank\bank0.s --------------------------------

cf23 : 70                    	db %01110000
cf24 : 28                    	db %00101000
cf25 : f0                    	db %11110000
cf26 : 20                    	db %00100000
cf27 : 00                    	db %00000000
                             ; char 37
cf28 : c0                    	db %11000000
cf29 : c8                    	db %11001000
cf2a : 10                    	db %00010000
cf2b : 20                    	db %00100000
cf2c : 40                    	db %01000000
cf2d : 98                    	db %10011000
cf2e : 18                    	db %00011000
cf2f : 00                    	db %00000000
                             ; char 38
cf30 : 40                    	db %01000000
cf31 : a0                    	db %10100000
cf32 : a0                    	db %10100000
cf33 : 40                    	db %01000000
cf34 : a8                    	db %10101000
cf35 : 90                    	db %10010000
cf36 : 68                    	db %01101000
cf37 : 00                    	db %00000000
                             ; char 39
cf38 : 20                    	db %00100000
cf39 : 20                    	db %00100000
cf3a : 20                    	db %00100000
cf3b : 00                    	db %00000000
cf3c : 00                    	db %00000000
cf3d : 00                    	db %00000000
cf3e : 00                    	db %00000000
cf3f : 00                    	db %00000000
                             ; char 40
cf40 : 20                    	db %00100000
cf41 : 40                    	db %01000000
cf42 : 80                    	db %10000000
cf43 : 80                    	db %10000000
cf44 : 80                    	db %10000000
cf45 : 40                    	db %01000000
cf46 : 20                    	db %00100000
cf47 : 00                    	db %00000000
                             ; char 41
cf48 : 20                    	db %00100000
cf49 : 10                    	db %00010000
cf4a : 08                    	db %00001000
cf4b : 08                    	db %00001000
cf4c : 08                    	db %00001000
cf4d : 10                    	db %00010000
cf4e : 20                    	db %00100000
cf4f : 00                    	db %00000000
                             ; char 42
cf50 : 20                    	db %00100000
cf51 : a8                    	db %10101000
cf52 : 70                    	db %01110000
cf53 : 20                    	db %00100000
cf54 : 70                    	db %01110000
cf55 : a8                    	db %10101000
cf56 : 20                    	db %00100000
cf57 : 00                    	db %00000000
                             ; char 43
cf58 : 00                    	db %00000000
cf59 : 20                    	db %00100000
AS65 Assembler for R6502 [1.42].                                     Page   66
-------------------------------- bank\bank0.s --------------------------------

cf5a : 20                    	db %00100000
cf5b : f8                    	db %11111000
cf5c : 20                    	db %00100000
cf5d : 20                    	db %00100000
cf5e : 00                    	db %00000000
cf5f : 00                    	db %00000000
                             ; char 44
cf60 : 00                    	db %00000000
cf61 : 00                    	db %00000000
cf62 : 00                    	db %00000000
cf63 : 00                    	db %00000000
cf64 : 00                    	db %00000000
cf65 : 20                    	db %00100000
cf66 : 20                    	db %00100000
cf67 : 40                    	db %01000000
                             ; char 45
cf68 : 00                    	db %00000000
cf69 : 00                    	db %00000000
cf6a : 00                    	db %00000000
cf6b : f8                    	db %11111000
cf6c : 00                    	db %00000000
cf6d : 00                    	db %00000000
cf6e : 00                    	db %00000000
cf6f : 00                    	db %00000000
                             ; char 46
cf70 : 00                    	db %00000000
cf71 : 00                    	db %00000000
cf72 : 00                    	db %00000000
cf73 : 00                    	db %00000000
cf74 : 00                    	db %00000000
cf75 : 10                    	db %00010000
cf76 : 00                    	db %00000000
cf77 : 00                    	db %00000000
                             ; char 47
cf78 : 00                    	db %00000000
cf79 : 08                    	db %00001000
cf7a : 10                    	db %00010000
cf7b : 20                    	db %00100000
cf7c : 40                    	db %01000000
cf7d : 80                    	db %10000000
cf7e : 00                    	db %00000000
cf7f : 00                    	db %00000000
                             ; char 48
cf80 : 70                    	db %01110000
cf81 : 88                    	db %10001000
cf82 : 98                    	db %10011000
cf83 : a8                    	db %10101000
cf84 : c8                    	db %11001000
cf85 : 88                    	db %10001000
cf86 : 70                    	db %01110000
cf87 : 00                    	db %00000000
                             ; char 49
cf88 : 20                    	db %00100000
cf89 : 60                    	db %01100000
cf8a : 20                    	db %00100000
cf8b : 20                    	db %00100000
cf8c : 20                    	db %00100000
cf8d : 20                    	db %00100000
cf8e : 70                    	db %01110000
cf8f : 00                    	db %00000000
                             ; char 50
cf90 : 70                    	db %01110000
AS65 Assembler for R6502 [1.42].                                     Page   67
-------------------------------- bank\bank0.s --------------------------------

cf91 : 88                    	db %10001000
cf92 : 08                    	db %00001000
cf93 : 10                    	db %00010000
cf94 : 20                    	db %00100000
cf95 : 40                    	db %01000000
cf96 : f8                    	db %11111000
cf97 : 00                    	db %00000000
                             ; char 51
cf98 : f8                    	db %11111000
cf99 : 08                    	db %00001000
cf9a : 10                    	db %00010000
cf9b : 30                    	db %00110000
cf9c : 08                    	db %00001000
cf9d : 88                    	db %10001000
cf9e : 70                    	db %01110000
cf9f : 00                    	db %00000000
                             ; char 52
cfa0 : 10                    	db %00010000
cfa1 : 30                    	db %00110000
cfa2 : 50                    	db %01010000
cfa3 : 90                    	db %10010000
cfa4 : f8                    	db %11111000
cfa5 : 10                    	db %00010000
cfa6 : 10                    	db %00010000
cfa7 : 00                    	db %00000000
                             ; char 53
cfa8 : f8                    	db %11111000
cfa9 : 80                    	db %10000000
cfaa : f0                    	db %11110000
cfab : 08                    	db %00001000
cfac : 08                    	db %00001000
cfad : 88                    	db %10001000
cfae : 70                    	db %01110000
cfaf : 00                    	db %00000000
                             ; char 54
cfb0 : 30                    	db %00110000
cfb1 : 40                    	db %01000000
cfb2 : 80                    	db %10000000
cfb3 : f0                    	db %11110000
cfb4 : 88                    	db %10001000
cfb5 : 88                    	db %10001000
cfb6 : 70                    	db %01110000
cfb7 : 00                    	db %00000000
                             ; char 55
cfb8 : f8                    	db %11111000
cfb9 : 08                    	db %00001000
cfba : 10                    	db %00010000
cfbb : 20                    	db %00100000
cfbc : 40                    	db %01000000
cfbd : 40                    	db %01000000
cfbe : 40                    	db %01000000
cfbf : 00                    	db %00000000
                             ; char 56
cfc0 : 70                    	db %01110000
cfc1 : 88                    	db %10001000
cfc2 : 88                    	db %10001000
cfc3 : 70                    	db %01110000
cfc4 : 88                    	db %10001000
cfc5 : 88                    	db %10001000
cfc6 : 70                    	db %01110000
cfc7 : 00                    	db %00000000
                             ; char 57
AS65 Assembler for R6502 [1.42].                                     Page   68
-------------------------------- bank\bank0.s --------------------------------

cfc8 : 70                    	db %01110000
cfc9 : 88                    	db %10001000
cfca : 88                    	db %10001000
cfcb : 78                    	db %01111000
cfcc : 08                    	db %00001000
cfcd : 10                    	db %00010000
cfce : 60                    	db %01100000
cfcf : 00                    	db %00000000
                             ; char 58
cfd0 : 00                    	db %00000000
cfd1 : 00                    	db %00000000
cfd2 : 20                    	db %00100000
cfd3 : 00                    	db %00000000
cfd4 : 00                    	db %00000000
cfd5 : 20                    	db %00100000
cfd6 : 00                    	db %00000000
cfd7 : 00                    	db %00000000
                             ; char 59
cfd8 : 00                    	db %00000000
cfd9 : 00                    	db %00000000
cfda : 20                    	db %00100000
cfdb : 00                    	db %00000000
cfdc : 00                    	db %00000000
cfdd : 20                    	db %00100000
cfde : 20                    	db %00100000
cfdf : 40                    	db %01000000
                             ; char 60
cfe0 : 10                    	db %00010000
cfe1 : 20                    	db %00100000
cfe2 : 40                    	db %01000000
cfe3 : 80                    	db %10000000
cfe4 : 40                    	db %01000000
cfe5 : 20                    	db %00100000
cfe6 : 10                    	db %00010000
cfe7 : 00                    	db %00000000
                             ; char 61
cfe8 : 00                    	db %00000000
cfe9 : 00                    	db %00000000
cfea : f8                    	db %11111000
cfeb : 00                    	db %00000000
cfec : f8                    	db %11111000
cfed : 00                    	db %00000000
cfee : 00                    	db %00000000
cfef : 00                    	db %00000000
                             ; char 62
cff0 : 40                    	db %01000000
cff1 : 20                    	db %00100000
cff2 : 10                    	db %00010000
cff3 : 08                    	db %00001000
cff4 : 10                    	db %00010000
cff5 : 20                    	db %00100000
cff6 : 40                    	db %01000000
cff7 : 00                    	db %00000000
                             ; char 63
cff8 : 70                    	db %01110000
cff9 : 88                    	db %10001000
cffa : 10                    	db %00010000
cffb : 20                    	db %00100000
cffc : 20                    	db %00100000
cffd : 00                    	db %00000000
cffe : 20                    	db %00100000
cfff : 00                    	db %00000000
AS65 Assembler for R6502 [1.42].                                     Page   69
-------------------------------- bank\bank0.s --------------------------------

                             ; char 64
d000 : 70                    	db %01110000
d001 : 88                    	db %10001000
d002 : a8                    	db %10101000
d003 : b8                    	db %10111000
d004 : b0                    	db %10110000
d005 : 80                    	db %10000000
d006 : 78                    	db %01111000
d007 : 00                    	db %00000000
d008 :                       vdp_font_a
                             ; char 65
d008 : 20                    	db %00100000
d009 : 50                    	db %01010000
d00a : 88                    	db %10001000
d00b : 88                    	db %10001000
d00c : f8                    	db %11111000
d00d : 88                    	db %10001000
d00e : 88                    	db %10001000
d00f : 00                    	db %00000000
                             ; char 66
d010 : f0                    	db %11110000
d011 : 88                    	db %10001000
d012 : 88                    	db %10001000
d013 : f0                    	db %11110000
d014 : 88                    	db %10001000
d015 : 88                    	db %10001000
d016 : f0                    	db %11110000
d017 : 00                    	db %00000000
                             ; char 67
d018 : 70                    	db %01110000
d019 : 88                    	db %10001000
d01a : 80                    	db %10000000
d01b : 80                    	db %10000000
d01c : 80                    	db %10000000
d01d : 88                    	db %10001000
d01e : 70                    	db %01110000
d01f : 00                    	db %00000000
                             ; char 68
d020 : f0                    	db %11110000
d021 : 88                    	db %10001000
d022 : 88                    	db %10001000
d023 : 88                    	db %10001000
d024 : 88                    	db %10001000
d025 : 88                    	db %10001000
d026 : f0                    	db %11110000
d027 : 00                    	db %00000000
                             ; char 69
d028 : f8                    	db %11111000
d029 : 80                    	db %10000000
d02a : 80                    	db %10000000
d02b : f0                    	db %11110000
d02c : 80                    	db %10000000
d02d : 80                    	db %10000000
d02e : f8                    	db %11111000
d02f : 00                    	db %00000000
                             ; char 70
d030 : f8                    	db %11111000
d031 : 80                    	db %10000000
d032 : 80                    	db %10000000
d033 : f0                    	db %11110000
d034 : 80                    	db %10000000
d035 : 80                    	db %10000000
AS65 Assembler for R6502 [1.42].                                     Page   70
-------------------------------- bank\bank0.s --------------------------------

d036 : 80                    	db %10000000
d037 : 00                    	db %00000000
                             ; char 71
d038 : 78                    	db %01111000
d039 : 80                    	db %10000000
d03a : 80                    	db %10000000
d03b : 80                    	db %10000000
d03c : 98                    	db %10011000
d03d : 88                    	db %10001000
d03e : 78                    	db %01111000
d03f : 00                    	db %00000000
                             ; char 72
d040 : 88                    	db %10001000
d041 : 88                    	db %10001000
d042 : 88                    	db %10001000
d043 : f8                    	db %11111000
d044 : 88                    	db %10001000
d045 : 88                    	db %10001000
d046 : 88                    	db %10001000
d047 : 00                    	db %00000000
                             ; char 73
d048 : 70                    	db %01110000
d049 : 20                    	db %00100000
d04a : 20                    	db %00100000
d04b : 20                    	db %00100000
d04c : 20                    	db %00100000
d04d : 20                    	db %00100000
d04e : 70                    	db %01110000
d04f : 00                    	db %00000000
                             ; char 74
d050 : 08                    	db %00001000
d051 : 08                    	db %00001000
d052 : 08                    	db %00001000
d053 : 08                    	db %00001000
d054 : 08                    	db %00001000
d055 : 88                    	db %10001000
d056 : 70                    	db %01110000
d057 : 00                    	db %00000000
                             ; char 75
d058 : 88                    	db %10001000
d059 : 90                    	db %10010000
d05a : a0                    	db %10100000
d05b : c0                    	db %11000000
d05c : a0                    	db %10100000
d05d : 90                    	db %10010000
d05e : 88                    	db %10001000
d05f : 00                    	db %00000000
                             ; char 76
d060 : 80                    	db %10000000
d061 : 80                    	db %10000000
d062 : 80                    	db %10000000
d063 : 80                    	db %10000000
d064 : 80                    	db %10000000
d065 : 80                    	db %10000000
d066 : f8                    	db %11111000
d067 : 00                    	db %00000000
                             ; char 77
d068 : 88                    	db %10001000
d069 : d8                    	db %11011000
d06a : a8                    	db %10101000
d06b : a8                    	db %10101000
d06c : 88                    	db %10001000
AS65 Assembler for R6502 [1.42].                                     Page   71
-------------------------------- bank\bank0.s --------------------------------

d06d : 88                    	db %10001000
d06e : 88                    	db %10001000
d06f : 00                    	db %00000000
                             ; char 78
d070 : 88                    	db %10001000
d071 : 88                    	db %10001000
d072 : c8                    	db %11001000
d073 : a8                    	db %10101000
d074 : 98                    	db %10011000
d075 : 88                    	db %10001000
d076 : 88                    	db %10001000
d077 : 00                    	db %00000000
                             ; char 79
d078 : 70                    	db %01110000
d079 : 88                    	db %10001000
d07a : 88                    	db %10001000
d07b : 88                    	db %10001000
d07c : 88                    	db %10001000
d07d : 88                    	db %10001000
d07e : 70                    	db %01110000
d07f : 00                    	db %00000000
                             ; char 80
d080 : f0                    	db %11110000
d081 : 88                    	db %10001000
d082 : 88                    	db %10001000
d083 : f0                    	db %11110000
d084 : 80                    	db %10000000
d085 : 80                    	db %10000000
d086 : 80                    	db %10000000
d087 : 00                    	db %00000000
                             ; char 81
d088 : 70                    	db %01110000
d089 : 88                    	db %10001000
d08a : 88                    	db %10001000
d08b : 88                    	db %10001000
d08c : a8                    	db %10101000
d08d : 90                    	db %10010000
d08e : 68                    	db %01101000
d08f : 00                    	db %00000000
                             ; char 82
d090 : f0                    	db %11110000
d091 : 88                    	db %10001000
d092 : 88                    	db %10001000
d093 : f0                    	db %11110000
d094 : a0                    	db %10100000
d095 : 90                    	db %10010000
d096 : 88                    	db %10001000
d097 : 00                    	db %00000000
                             ; char 83
d098 : 70                    	db %01110000
d099 : 88                    	db %10001000
d09a : 80                    	db %10000000
d09b : 70                    	db %01110000
d09c : 08                    	db %00001000
d09d : 88                    	db %10001000
d09e : 70                    	db %01110000
d09f : 00                    	db %00000000
                             ; char 84
d0a0 : f8                    	db %11111000
d0a1 : 20                    	db %00100000
d0a2 : 20                    	db %00100000
d0a3 : 20                    	db %00100000
AS65 Assembler for R6502 [1.42].                                     Page   72
-------------------------------- bank\bank0.s --------------------------------

d0a4 : 20                    	db %00100000
d0a5 : 20                    	db %00100000
d0a6 : 20                    	db %00100000
d0a7 : 00                    	db %00000000
                             ; char 85
d0a8 : 88                    	db %10001000
d0a9 : 88                    	db %10001000
d0aa : 88                    	db %10001000
d0ab : 88                    	db %10001000
d0ac : 88                    	db %10001000
d0ad : 88                    	db %10001000
d0ae : 70                    	db %01110000
d0af : 00                    	db %00000000
                             ; char 86
d0b0 : 88                    	db %10001000
d0b1 : 88                    	db %10001000
d0b2 : 88                    	db %10001000
d0b3 : 88                    	db %10001000
d0b4 : 88                    	db %10001000
d0b5 : 50                    	db %01010000
d0b6 : 20                    	db %00100000
d0b7 : 00                    	db %00000000
                             ; char 87
d0b8 : 88                    	db %10001000
d0b9 : 88                    	db %10001000
d0ba : 88                    	db %10001000
d0bb : a8                    	db %10101000
d0bc : a8                    	db %10101000
d0bd : d8                    	db %11011000
d0be : 88                    	db %10001000
d0bf : 00                    	db %00000000
                             ; char 88
d0c0 : 88                    	db %10001000
d0c1 : 88                    	db %10001000
d0c2 : 50                    	db %01010000
d0c3 : 20                    	db %00100000
d0c4 : 50                    	db %01010000
d0c5 : 88                    	db %10001000
d0c6 : 88                    	db %10001000
d0c7 : 00                    	db %00000000
                             ; char 89
d0c8 : 88                    	db %10001000
d0c9 : 88                    	db %10001000
d0ca : 50                    	db %01010000
d0cb : 20                    	db %00100000
d0cc : 20                    	db %00100000
d0cd : 20                    	db %00100000
d0ce : 20                    	db %00100000
d0cf : 00                    	db %00000000
                             ; char 90
d0d0 : f8                    	db %11111000
d0d1 : 08                    	db %00001000
d0d2 : 10                    	db %00010000
d0d3 : 20                    	db %00100000
d0d4 : 40                    	db %01000000
d0d5 : 80                    	db %10000000
d0d6 : f8                    	db %11111000
d0d7 : 00                    	db %00000000
                             ; char 91
d0d8 : 78                    	db %01111000
d0d9 : 40                    	db %01000000
d0da : 40                    	db %01000000
AS65 Assembler for R6502 [1.42].                                     Page   73
-------------------------------- bank\bank0.s --------------------------------

d0db : 40                    	db %01000000
d0dc : 40                    	db %01000000
d0dd : 40                    	db %01000000
d0de : 78                    	db %01111000
d0df : 00                    	db %00000000
                             ; char 92
d0e0 : 00                    	db %00000000
d0e1 : 80                    	db %10000000
d0e2 : 40                    	db %01000000
d0e3 : 20                    	db %00100000
d0e4 : 10                    	db %00010000
d0e5 : 08                    	db %00001000
d0e6 : 00                    	db %00000000
d0e7 : 00                    	db %00000000
                             ; char 93
d0e8 : f0                    	db %11110000
d0e9 : 10                    	db %00010000
d0ea : 10                    	db %00010000
d0eb : 10                    	db %00010000
d0ec : 10                    	db %00010000
d0ed : 10                    	db %00010000
d0ee : f0                    	db %11110000
d0ef : 00                    	db %00000000
                             ; char 94
d0f0 : 20                    	db %00100000
d0f1 : 50                    	db %01010000
d0f2 : a8                    	db %10101000
d0f3 : 20                    	db %00100000
d0f4 : 20                    	db %00100000
d0f5 : 20                    	db %00100000
d0f6 : 20                    	db %00100000
d0f7 : 00                    	db %00000000
                             ; char 95
d0f8 : 00                    	db %00000000
d0f9 : 00                    	db %00000000
d0fa : 00                    	db %00000000
d0fb : 00                    	db %00000000
d0fc : 00                    	db %00000000
d0fd : 00                    	db %00000000
d0fe : f8                    	db %11111000
d0ff : 00                    	db %00000000
                             ; char 96
d100 : 38                    	db %00111000
d101 : 40                    	db %01000000
d102 : 40                    	db %01000000
d103 : 40                    	db %01000000
d104 : f0                    	db %11110000
d105 : 40                    	db %01000000
d106 : f8                    	db %11111000
d107 : 00                    	db %00000000
                             ; char 97
d108 : 00                    	db %00000000
d109 : 00                    	db %00000000
d10a : 70                    	db %01110000
d10b : 08                    	db %00001000
d10c : 78                    	db %01111000
d10d : 88                    	db %10001000
d10e : 78                    	db %01111000
d10f : 00                    	db %00000000
                             ; char 98
d110 : 80                    	db %10000000
d111 : 80                    	db %10000000
AS65 Assembler for R6502 [1.42].                                     Page   74
-------------------------------- bank\bank0.s --------------------------------

d112 : f0                    	db %11110000
d113 : 88                    	db %10001000
d114 : 88                    	db %10001000
d115 : 88                    	db %10001000
d116 : f0                    	db %11110000
d117 : 00                    	db %00000000
                             ; char 99
d118 : 00                    	db %00000000
d119 : 00                    	db %00000000
d11a : 78                    	db %01111000
d11b : 80                    	db %10000000
d11c : 80                    	db %10000000
d11d : 80                    	db %10000000
d11e : 78                    	db %01111000
d11f : 00                    	db %00000000
                             ; char 100
d120 : 08                    	db %00001000
d121 : 08                    	db %00001000
d122 : 78                    	db %01111000
d123 : 88                    	db %10001000
d124 : 88                    	db %10001000
d125 : 88                    	db %10001000
d126 : 78                    	db %01111000
d127 : 00                    	db %00000000
                             ; char 101
d128 : 00                    	db %00000000
d129 : 00                    	db %00000000
d12a : 70                    	db %01110000
d12b : 88                    	db %10001000
d12c : f8                    	db %11111000
d12d : 80                    	db %10000000
d12e : 78                    	db %01111000
d12f : 00                    	db %00000000
                             ; char 102
d130 : 30                    	db %00110000
d131 : 48                    	db %01001000
d132 : 40                    	db %01000000
d133 : f0                    	db %11110000
d134 : 40                    	db %01000000
d135 : 40                    	db %01000000
d136 : 40                    	db %01000000
d137 : 00                    	db %00000000
                             ; char 103
d138 : 00                    	db %00000000
d139 : 00                    	db %00000000
d13a : 70                    	db %01110000
d13b : 88                    	db %10001000
d13c : 88                    	db %10001000
d13d : 78                    	db %01111000
d13e : 08                    	db %00001000
d13f : 70                    	db %01110000
                             ; char 104
d140 : 80                    	db %10000000
d141 : 80                    	db %10000000
d142 : f0                    	db %11110000
d143 : 88                    	db %10001000
d144 : 88                    	db %10001000
d145 : 88                    	db %10001000
d146 : 88                    	db %10001000
d147 : 00                    	db %00000000
                             ; char 105
d148 : 20                    	db %00100000
AS65 Assembler for R6502 [1.42].                                     Page   75
-------------------------------- bank\bank0.s --------------------------------

d149 : 00                    	db %00000000
d14a : 60                    	db %01100000
d14b : 20                    	db %00100000
d14c : 20                    	db %00100000
d14d : 20                    	db %00100000
d14e : 70                    	db %01110000
d14f : 00                    	db %00000000
                             ; char 106
d150 : 10                    	db %00010000
d151 : 00                    	db %00000000
d152 : 30                    	db %00110000
d153 : 10                    	db %00010000
d154 : 10                    	db %00010000
d155 : 10                    	db %00010000
d156 : 90                    	db %10010000
d157 : 60                    	db %01100000
                             ; char 107
d158 : 80                    	db %10000000
d159 : 80                    	db %10000000
d15a : 88                    	db %10001000
d15b : 90                    	db %10010000
d15c : e0                    	db %11100000
d15d : 90                    	db %10010000
d15e : 88                    	db %10001000
d15f : 00                    	db %00000000
                             ; char 108
d160 : 60                    	db %01100000
d161 : 20                    	db %00100000
d162 : 20                    	db %00100000
d163 : 20                    	db %00100000
d164 : 20                    	db %00100000
d165 : 20                    	db %00100000
d166 : 70                    	db %01110000
d167 : 00                    	db %00000000
                             ; char 109
d168 : 00                    	db %00000000
d169 : 00                    	db %00000000
d16a : d8                    	db %11011000
d16b : a8                    	db %10101000
d16c : a8                    	db %10101000
d16d : a8                    	db %10101000
d16e : 88                    	db %10001000
d16f : 00                    	db %00000000
                             ; char 110
d170 : 00                    	db %00000000
d171 : 00                    	db %00000000
d172 : f0                    	db %11110000
d173 : 88                    	db %10001000
d174 : 88                    	db %10001000
d175 : 88                    	db %10001000
d176 : 88                    	db %10001000
d177 : 00                    	db %00000000
                             ; char 111
d178 : 00                    	db %00000000
d179 : 00                    	db %00000000
d17a : 70                    	db %01110000
d17b : 88                    	db %10001000
d17c : 88                    	db %10001000
d17d : 88                    	db %10001000
d17e : 70                    	db %01110000
d17f : 00                    	db %00000000
                             ; char 112
AS65 Assembler for R6502 [1.42].                                     Page   76
-------------------------------- bank\bank0.s --------------------------------

d180 : 00                    	db %00000000
d181 : 00                    	db %00000000
d182 : f0                    	db %11110000
d183 : 88                    	db %10001000
d184 : 88                    	db %10001000
d185 : f0                    	db %11110000
d186 : 80                    	db %10000000
d187 : 80                    	db %10000000
                             ; char 113
d188 : 00                    	db %00000000
d189 : 00                    	db %00000000
d18a : 78                    	db %01111000
d18b : 88                    	db %10001000
d18c : 88                    	db %10001000
d18d : 78                    	db %01111000
d18e : 08                    	db %00001000
d18f : 08                    	db %00001000
                             ; char 114
d190 : 00                    	db %00000000
d191 : 00                    	db %00000000
d192 : b8                    	db %10111000
d193 : c0                    	db %11000000
d194 : 80                    	db %10000000
d195 : 80                    	db %10000000
d196 : 80                    	db %10000000
d197 : 00                    	db %00000000
                             ; char 115
d198 : 00                    	db %00000000
d199 : 00                    	db %00000000
d19a : 78                    	db %01111000
d19b : 80                    	db %10000000
d19c : 70                    	db %01110000
d19d : 08                    	db %00001000
d19e : f0                    	db %11110000
d19f : 00                    	db %00000000
                             ; char 116
d1a0 : 40                    	db %01000000
d1a1 : 40                    	db %01000000
d1a2 : f0                    	db %11110000
d1a3 : 40                    	db %01000000
d1a4 : 40                    	db %01000000
d1a5 : 48                    	db %01001000
d1a6 : 30                    	db %00110000
d1a7 : 00                    	db %00000000
                             ; char 117
d1a8 : 00                    	db %00000000
d1a9 : 00                    	db %00000000
d1aa : 88                    	db %10001000
d1ab : 88                    	db %10001000
d1ac : 88                    	db %10001000
d1ad : 98                    	db %10011000
d1ae : 68                    	db %01101000
d1af : 00                    	db %00000000
                             ; char 118
d1b0 : 00                    	db %00000000
d1b1 : 00                    	db %00000000
d1b2 : 88                    	db %10001000
d1b3 : 88                    	db %10001000
d1b4 : 88                    	db %10001000
d1b5 : 50                    	db %01010000
d1b6 : 20                    	db %00100000
d1b7 : 00                    	db %00000000
AS65 Assembler for R6502 [1.42].                                     Page   77
-------------------------------- bank\bank0.s --------------------------------

                             ; char 119
d1b8 : 00                    	db %00000000
d1b9 : 00                    	db %00000000
d1ba : 88                    	db %10001000
d1bb : 88                    	db %10001000
d1bc : a8                    	db %10101000
d1bd : a8                    	db %10101000
d1be : d8                    	db %11011000
d1bf : 00                    	db %00000000
                             ; char 120
d1c0 : 00                    	db %00000000
d1c1 : 00                    	db %00000000
d1c2 : 88                    	db %10001000
d1c3 : 50                    	db %01010000
d1c4 : 20                    	db %00100000
d1c5 : 50                    	db %01010000
d1c6 : 88                    	db %10001000
d1c7 : 00                    	db %00000000
                             ; char 121
d1c8 : 00                    	db %00000000
d1c9 : 00                    	db %00000000
d1ca : 88                    	db %10001000
d1cb : 88                    	db %10001000
d1cc : 88                    	db %10001000
d1cd : 78                    	db %01111000
d1ce : 08                    	db %00001000
d1cf : 70                    	db %01110000
                             ; char 122
d1d0 : 00                    	db %00000000
d1d1 : 00                    	db %00000000
d1d2 : f8                    	db %11111000
d1d3 : 10                    	db %00010000
d1d4 : 20                    	db %00100000
d1d5 : 40                    	db %01000000
d1d6 : f8                    	db %11111000
d1d7 : 00                    	db %00000000
                             ; char 123
d1d8 : 38                    	db %00111000
d1d9 : 60                    	db %01100000
d1da : 60                    	db %01100000
d1db : c0                    	db %11000000
d1dc : 60                    	db %01100000
d1dd : 60                    	db %01100000
d1de : 38                    	db %00111000
d1df : 00                    	db %00000000
                             ; char 124
d1e0 : 20                    	db %00100000
d1e1 : 20                    	db %00100000
d1e2 : 20                    	db %00100000
d1e3 : 20                    	db %00100000
d1e4 : 20                    	db %00100000
d1e5 : 20                    	db %00100000
d1e6 : 20                    	db %00100000
d1e7 : 20                    	db %00100000
                             ; char 125
d1e8 : e0                    	db %11100000
d1e9 : 30                    	db %00110000
d1ea : 30                    	db %00110000
d1eb : 18                    	db %00011000
d1ec : 30                    	db %00110000
d1ed : 30                    	db %00110000
d1ee : e0                    	db %11100000
AS65 Assembler for R6502 [1.42].                                     Page   78
-------------------------------- bank\bank0.s --------------------------------

d1ef : 00                    	db %00000000
                             ; char 126
d1f0 : 00                    	db %00000000
d1f1 : 00                    	db %00000000
d1f2 : 40                    	db %01000000
d1f3 : a8                    	db %10101000
d1f4 : 10                    	db %00010000
d1f5 : 00                    	db %00000000
d1f6 : 00                    	db %00000000
d1f7 : 00                    	db %00000000
                             ; char 127
d1f8 : f8                    	db %11111000
d1f9 : f8                    	db %11111000
d1fa : f8                    	db %11111000
d1fb : f8                    	db %11111000
d1fc : f8                    	db %11111000
d1fd : f8                    	db %11111000
d1fe : f8                    	db %11111000
d1ff : 00                    	db %00000000
                             	
                             	
                             
                             
                             
                             ;****************************************
                             ;* vdp_init
                             ;* Initialise VDP
                             ;* Clears all of VRAM to zero
                             ;****************************************
d200 :                       vdp_init
d200 : 20e5d2           [ 6] 	jsr clear_vram
d203 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* vdp_init_mode
                             ;* Initialise VDP  to required mode and addresses
                             ;* Input : Y = Offset in to VDP init table
                             ;* Output : None
                             ;* Regs affected : All
                             ;****************************************
d204 :                       vdp_init_mode
d204 : 78               [ 2] 	sei
d205 : be6cd3           [ 4] 	ldx vdp_base_table+0,y		; Get delay
d208 : 8613             [ 3] 	stx vdp_delay
                             
d20a : a900             [ 2] 	lda	#0						; Do R0
d20c : be6dd3           [ 4] 	ldx vdp_base_table+1,y		; Get R0 value
d20f : 20d6c4           [ 6] 	jsr vdp_wr_reg				; Write X to Reg A
                             
d212 : a901             [ 2] 	lda	#1						; Do R1
d214 : be6ed3           [ 4] 	ldx vdp_base_table+2,y		; Get R1 value
d217 : 20d6c4           [ 6] 	jsr vdp_wr_reg				; Write X to Reg A
                             
d21a : be6fd3           [ 4] 	ldx vdp_base_table+3,y		; Get name table low add
d21d : 8614             [ 3] 	stx vdp_base+vdp_addr_nme	; Save in vdp_base
d21f : be70d3           [ 4] 	ldx vdp_base_table+4,y		; Get name table high ad
d222 : 8615             [ 3] 	stx vdp_base+vdp_addr_nme+1	; Save in vdp_base
d224 : a902             [ 2] 	lda #2						; Do R2
d226 : be71d3           [ 4] 	ldx vdp_base_table+5,y		; Get R2 value
d229 : 20d6c4           [ 6] 	jsr vdp_wr_reg				; Write X to Reg A
                             
d22c : be72d3           [ 4] 	ldx vdp_base_table+6,y		; Get col table low addr
AS65 Assembler for R6502 [1.42].                                     Page   79
-------------------------------- bank\bank0.s --------------------------------

d22f : 8616             [ 3] 	stx vdp_base+vdp_addr_col	; Save in vdp_base
d231 : be73d3           [ 4] 	ldx vdp_base_table+7,y		; Get col table high add
d234 : 8617             [ 3] 	stx vdp_base+vdp_addr_col+1	; Save in vdp_base
d236 : a903             [ 2] 	lda #3						; Do R3
d238 : be74d3           [ 4] 	ldx vdp_base_table+8,y		; Get R3 value
d23b : 20d6c4           [ 6] 	jsr vdp_wr_reg				; Write X to Reg A
                             
d23e : be75d3           [ 4] 	ldx vdp_base_table+9,y		; Get pat table low addr
d241 : 8618             [ 3] 	stx vdp_base+vdp_addr_pat	; Save in vdp_base
d243 : be76d3           [ 4] 	ldx vdp_base_table+10,y		; Get pat table high ad
d246 : 8619             [ 3] 	stx vdp_base+vdp_addr_pat+1	; Save in vdp_base
d248 : a904             [ 2] 	lda #4						; Do R4
d24a : be77d3           [ 4] 	ldx vdp_base_table+11,y		; Get R4 value
d24d : 20d6c4           [ 6] 	jsr vdp_wr_reg				; Write X to Reg A
                             
d250 : be78d3           [ 4] 	ldx vdp_base_table+12,y		; Get spr att table low
d253 : 861a             [ 3] 	stx vdp_base+vdp_addr_spa	; Save in vdp_base
d255 : be79d3           [ 4] 	ldx vdp_base_table+13,y		; Get spr att table hig
d258 : 861b             [ 3] 	stx vdp_base+vdp_addr_spa+1	; Save in vdp_base
d25a : a905             [ 2] 	lda #5						; Do R5
d25c : be7ad3           [ 4] 	ldx vdp_base_table+14,y		; Get R5 value
d25f : 20d6c4           [ 6] 	jsr vdp_wr_reg				; Write X to Reg A
                             
d262 : be7bd3           [ 4] 	ldx vdp_base_table+15,y		; Get spr pat table low
d265 : 861c             [ 3] 	stx vdp_base+vdp_addr_spp	; Save in vdp_base
d267 : be7cd3           [ 4] 	ldx vdp_base_table+16,y		; Get spr pat table hig
d26a : 861d             [ 3] 	stx vdp_base+vdp_addr_spp+1	; Save in vdp_base
d26c : a906             [ 2] 	lda #6						; Do R6
d26e : be7dd3           [ 4] 	ldx vdp_base_table+17,y		; Get R6 value
d271 : 20d6c4           [ 6] 	jsr vdp_wr_reg				; Write X to Reg A
                             
d274 : a907             [ 2] 	lda #7						; Do R7
d276 : be7ed3           [ 4] 	ldx vdp_base_table+18,y		; Get R7 value
d279 : 861e             [ 3] 	stx vdp_base+vdp_bord_col	; Save border colour
d27b : 20d6c4           [ 6] 	jsr vdp_wr_reg				; Write X to Reg A
                             	
d27e : 58               [ 2] 	cli
                             
d27f : 60               [ 6] 	rts
                             	
                             
                             ;****************************************
                             ;* vdp_set_txt_mode
                             ;* Set up text mode
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : All
                             ;****************************************
d280 :                       vdp_set_txt_mode
d280 : a039             [ 2] 	ldy #vdp_base_table_txt-vdp_base_table
d282 : 2004d2           [ 6] 	jsr vdp_init_mode
d285 : 4c2bd3           [ 3] 	jmp init_fonts
                             
                             	
                             ;****************************************
                             ;* vdp_set_g1_mode
                             ;* Set up G1 mode
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : All
                             ;****************************************
d288 :                       vdp_set_g1_mode
AS65 Assembler for R6502 [1.42].                                     Page   80
-------------------------------- bank\bank0.s --------------------------------

d288 : a000             [ 2] 	ldy #vdp_base_table_g1-vdp_base_table
d28a : 2004d2           [ 6] 	jsr vdp_init_mode
d28d : 4c2bd3           [ 3] 	jmp init_fonts
                             
                             ;****************************************
                             ;* vdp_set_g2_mode
                             ;* Set up G2 mode
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : All
                             ;****************************************
d290 :                       vdp_set_g2_mode
d290 : a013             [ 2] 	ldy #vdp_base_table_g2-vdp_base_table
d292 : 2004d2           [ 6] 	jsr vdp_init_mode
d295 : 4c2bd3           [ 3] 	jmp init_fonts
                             
                             ;****************************************
                             ;* vdp_set_hires
                             ;* Set up HI mode
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : All
                             ;****************************************
d298 :                       vdp_set_hires
d298 : a026             [ 2] 	ldy #vdp_base_table_hi-vdp_base_table
d29a : 2004d2           [ 6] 	jsr vdp_init_mode
                             	
                             	; No fonts to init but pre-fill name table
                             	; to use all 3 character sets
d29d : 78               [ 2] 	sei
                             
                             	; Point at name table
d29e : a614             [ 3] 	ldx vdp_base+vdp_addr_nme
d2a0 : a515             [ 3] 	lda vdp_base+vdp_addr_nme+1
d2a2 : 20e3c4           [ 6] 	jsr vdp_wr_addr
                             	
                             	; set name for 3 pages (768)
d2a5 : a200             [ 2] 	ldx #0
d2a7 : a003             [ 2] 	ldy #3
d2a9 :                       vdp_set_hires_fill_nme
d2a9 : 8a               [ 2] 	txa						; Name table is 0..255 for 3 pages
d2aa : 2009c5           [ 6] 	jsr vdp_wr_vram
d2ad : e8               [ 2] 	inx
d2ae : d0f9             [ 3] 	bne vdp_set_hires_fill_nme
d2b0 : 88               [ 2] 	dey
d2b1 : d0f6             [ 3] 	bne vdp_set_hires_fill_nme
                             	
d2b3 : 58               [ 2] 	cli
                             	
d2b4 : 60               [ 6] 	rts
                             
                             	
                             ;****************************************
                             ;* init_vdp_g1
                             ;* Initialise video processor graphics 1
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : All
                             ;***************************************
d2b5 :                       init_vdp_g1
d2b5 : 2088d2           [ 6] 	jsr vdp_set_g1_mode
d2b8 : 2038d3           [ 6] 	jsr init_sprtpat_g1
AS65 Assembler for R6502 [1.42].                                     Page   81
-------------------------------- bank\bank0.s --------------------------------

d2bb : 20f2d2           [ 6] 	jsr init_colours_g1
d2be : 2018d3           [ 6] 	jsr init_sprites_g1
d2c1 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* init_vdp_g1
                             ;* Initialise video processor graphics 1
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : All
                             ;***************************************
d2c2 :                       init_vdp_g2
d2c2 : 2090d2           [ 6] 	jsr vdp_set_g2_mode
d2c5 : 2038d3           [ 6] 	jsr init_sprtpat_g1		; Same as G1
d2c8 : 2005d3           [ 6] 	jsr init_colours_g2
d2cb : 2018d3           [ 6] 	jsr init_sprites_g1		; Same as G1
d2ce : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* init_vdp_hires
                             ;* Initialise video processor graphics 1
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : All
                             ;***************************************
d2cf :                       init_vdp_hires
d2cf : 2098d2           [ 6] 	jsr vdp_set_hires
d2d2 : 2038d3           [ 6] 	jsr init_sprtpat_g1
d2d5 : 4c18d3           [ 3] 	jmp init_sprites_g1
                             
                             
                             ;****************************************
                             ;* init_vdp_txt
                             ;* Initialise video processor text mode
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : All
                             ;***************************************
d2d8 :                       init_vdp_txt
d2d8 : 4c80d2           [ 3] 	jmp vdp_set_txt_mode
                             	
                             
                             ;****************************************
                             ;* fill_vram
                             ;* Fill a number of VRAM bytes with a value
                             ;* Input : X,Y = Fill length (lo,hi), A = Value
                             ;* Output : None
                             ;* Regs affected : All
                             ;* ASSUMES vdp_wr_vram already called
                             ;* Works for < 256 bytes as long as Y=1
                             ;* Else only use for WHOLE pages at a time so X m
                             ;* INTERRUPTS MUST HAVE BEEN DISABLED BY THE CALL
                             ;****************************************
d2db :                       vdp_fill_vram
d2db : 2009c5           [ 6] 	jsr vdp_wr_vram
d2de : ca               [ 2] 	dex
d2df : d0fa             [ 3] 	bne vdp_fill_vram
d2e1 : 88               [ 2] 	dey
d2e2 : d0f7             [ 3] 	bne vdp_fill_vram
d2e4 : 60               [ 6] 	rts
                             
                             ;****************************************
AS65 Assembler for R6502 [1.42].                                     Page   82
-------------------------------- bank\bank0.s --------------------------------

                             ;* clear_vram
                             ;* Set all 16k VDP vram to 0x00
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : All
                             ;****************************************
d2e5 :                       clear_vram
                             ;	sei
d2e5 : a200             [ 2] 	ldx #0x00			; Low byte of address
d2e7 : a900             [ 2] 	lda #0x00			; High byte of address
d2e9 : 20e3c4           [ 6] 	jsr vdp_wr_addr		; Write address to VDP
                             
d2ec : a040             [ 2] 	ldy #0x40			; 0x40 pages = 16k (X already zero)
d2ee : 20dbd2           [ 6] 	jsr vdp_fill_vram
                             ;	cli
d2f1 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* init_colours_g1
                             ;* Initialise colour table for graphics 1
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : All
                             ;****************************************
d2f2 :                       init_colours_g1
d2f2 : 78               [ 2] 	sei
d2f3 : a616             [ 3] 	ldx vdp_base+vdp_addr_col
d2f5 : a517             [ 3] 	lda vdp_base+vdp_addr_col+1
d2f7 : 20e3c4           [ 6] 	jsr vdp_wr_addr				; Set VDP address
                             	
d2fa : a220             [ 2] 	ldx #0x20					; 32 bytes to fill	
d2fc : a001             [ 2] 	ldy #0x01					; Only 1 pass through
d2fe : a51e             [ 3] 	lda vdp_base+vdp_bord_col	; Border colour
d300 : 20dbd2           [ 6] 	jsr vdp_fill_vram
d303 : 58               [ 2] 	cli
d304 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* init_colours_g2
                             ;* Initialise colour table for graphics 2
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : All
                             ;****************************************
d305 :                       init_colours_g2
d305 : 78               [ 2] 	sei
d306 : a616             [ 3] 	ldx vdp_base+vdp_addr_col
d308 : a517             [ 3] 	lda vdp_base+vdp_addr_col+1
d30a : 20e3c4           [ 6] 	jsr vdp_wr_addr				; Set VDP address
                             	
d30d : a200             [ 2] 	ldx #0x00					; 2048 bytes to fill	
d30f : a008             [ 2] 	ldy #0x08					; 8 pass through
d311 : a51e             [ 3] 	lda vdp_base+vdp_bord_col	; Border colour
d313 : 20dbd2           [ 6] 	jsr vdp_fill_vram
d316 : 58               [ 2] 	cli
d317 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* init_sprites_g1
                             ;* Initialise sprite attribute table for graphics
                             ;* Input : None
                             ;* Output : None
AS65 Assembler for R6502 [1.42].                                     Page   83
-------------------------------- bank\bank0.s --------------------------------

                             ;* Regs affected : All
                             ;****************************************
d318 :                       init_sprites_g1
d318 : 78               [ 2] 	sei
d319 : a61a             [ 3] 	ldx vdp_base+vdp_addr_spa
d31b : a51b             [ 3] 	lda vdp_base+vdp_addr_spa+1
d31d : 20e3c4           [ 6] 	jsr vdp_wr_addr				; Set VDP address
                             	
d320 : a280             [ 2] 	ldx #0x80					; 128 bytes of attribute to fill
d322 : a001             [ 2] 	ldy #0x01					; Only 1 pass
d324 : a9d0             [ 2] 	lda #0xd0					; Sprite terminator
d326 : 20dbd2           [ 6] 	jsr vdp_fill_vram
d329 : 58               [ 2] 	cli
d32a : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* init_fonts
                             ;* Initialise fonts 
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : All
                             ;****************************************
d32b :                       init_fonts
d32b : 78               [ 2] 	sei
d32c : a618             [ 3] 	ldx vdp_base+vdp_addr_pat
d32e : a519             [ 3] 	lda vdp_base+vdp_addr_pat+1
d330 : 20e3c4           [ 6] 	jsr vdp_wr_addr				; Write the address
d333 : 2045d3           [ 6] 	jsr init_fonts_sub
d336 : 58               [ 2] 	cli
d337 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* init_sprtpat_g1
                             ;* Initialise fonts for sprites
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : All
                             ;****************************************
d338 :                       init_sprtpat_g1
d338 : 78               [ 2] 	sei
d339 : a61c             [ 3] 	ldx vdp_base+vdp_addr_spp
d33b : a51d             [ 3] 	lda vdp_base+vdp_addr_spp+1
d33d : 20e3c4           [ 6] 	jsr vdp_wr_addr				; Write the address
d340 : 2045d3           [ 6] 	jsr init_fonts_sub
d343 : 58               [ 2] 	cli
d344 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* init_fonts_sub
                             ;* Initialise fonts common subroutine
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : All
                             ;* INTERRUPTS MUST HAVE BEEN DISABLED BY CALLER!!
                             ;****************************************
d345 :                       init_fonts_sub
d345 : 643f             [ 3] 	stz tmp_a				; XOR with zero = no change
d347 : a000             [ 2] 	ldy #0					; byte within page
d349 :                       init_write_fonts
d349 : a900             [ 2] 	lda #lo(vdp_font)		; Low byte of fonts source
d34b : 8539             [ 3] 	sta tmp_alo
d34d : a9ce             [ 2] 	lda #hi(vdp_font)		; High byte of fonts source
AS65 Assembler for R6502 [1.42].                                     Page   84
-------------------------------- bank\bank0.s --------------------------------

d34f : 853a             [ 3] 	sta tmp_ahi
d351 : a204             [ 2] 	ldx #0x04				; 4 pages = 1024 bytes
d353 :                       init_pattern
d353 : 98               [ 2] 	tya
d354 : b139             [ 5] 	lda (tmp_alo),y			; Get byte from font table
d356 : 453f             [ 3] 	eor tmp_a				; Invert if tmp_a is 0xff
d358 : 2009c5           [ 6] 	jsr vdp_wr_vram			; Write the byte to VRAM
d35b : c8               [ 2] 	iny
d35c : d0f5             [ 3] 	bne init_pattern		; keep going for 1 page
d35e : e63a             [ 5] 	inc tmp_ahi				; only need to increment high byt
d360 : ca               [ 2] 	dex						; page counter
d361 : d0f0             [ 3] 	bne init_pattern		; keep going for 4 pages
d363 : a53f             [ 3] 	lda tmp_a				; get the current eor mask
d365 : 49ff             [ 2] 	eor	#0xff				; Invert the EOR mask
d367 : 853f             [ 3] 	sta tmp_a				; And save for next go around
d369 : d0de             [ 3] 	bne init_write_fonts
d36b : 60               [ 6] 	rts
                             
                             ;**** BASE TABLES ****
d36c :                       vdp_base_table
d36c :                       vdp_base_table_g1
d36c : 02                    	db	VDP_LONGDELAY	; Long delay
d36d : 00                    	db	%00000000		; R0 - No-extvid
d36e : e0                    	db	%11100000		; R1 - 16K,Disp-enable,Int-enable,
d36f : 0010                  	dw	0x1000			; Name table address
d371 : 04                    	db	0x1000>>10		; R2 Name table value
d372 : 8013                  	dw	0x1380			; Colour table
d374 : 4e                    	db	0x1380>>6		; R3 Colour table value
d375 : 0000                  	dw	0x0000			; Pattern table
d377 : 00                    	db	0x0000>>11		; R4 Pattern table value
d378 : 0013                  	dw	0x1300			; Sprite attribute table
d37a : 26                    	db	0x1300>>7		; R5 Sprite attribute table value
d37b : 0008                  	dw	0x0800			; Sprite pattern table
d37d : 01                    	db	0x0800>>11		; R6 Sprite pattern table value
d37e : f4                    	db	0xf4			; R7 White f/gnd, blue background
                             
d37f :                       vdp_base_table_g2
d37f : 02                    	db	VDP_LONGDELAY	; Long delay
d380 : 02                    	db	%00000010		; R0 - GR2HiRes,No-extvid
d381 : e0                    	db	%11100000		; R1 - 16K,Disp-enable,Int-enable,
d382 : 0038                  	dw	0x3800			; Name table address
d384 : 0e                    	db	0x3800>>10		; R2 Name table value
d385 : 0020                  	dw	0x2000			; Colour table
d387 : 9f                    	db	0x9f			; R3 Colour table magic value 0x9f
d388 : 0000                  	dw	0x0000			; Pattern table
d38a : 00                    	db	0x0000>>11		; R4 Pattern table value
d38b : 003b                  	dw	0x3b00			; Sprite attribute table
d38d : 76                    	db	0x3b00>>7		; R5 Sprite attribute table value
d38e : 0018                  	dw	0x1800			; Sprite pattern table
d390 : 03                    	db	0x1800>>11		; R6 Sprite pattern table value
d391 : fc                    	db	0xfc			; R7 White f/gnd, green background
                             
d392 :                       vdp_base_table_hi
d392 : 02                    	db	VDP_LONGDELAY	; Long delay
d393 : 02                    	db	%00000010		; R0 - GR2HiRes,No-extvid
d394 : e0                    	db	%11100000		; R1 - 16K,Disp-enable,Int-enable,
d395 : 0038                  	dw	0x3800			; Name table
d397 : 0e                    	db	0x3800>>10		; R2 Name table value
d398 : 0020                  	dw	0x2000			; Colour table
d39a : ff                    	db	0xff			; R3 Colour table value - always 0xff
d39b : 0000                  	dw	0x0000			; Pattern table
d39d : 03                    	db	0x03			; R4 Pattern table value - always 0x03
AS65 Assembler for R6502 [1.42].                                     Page   85
-------------------------------- bank\bank0.s --------------------------------

d39e : 003b                  	dw	0x3b00			; Sprite attribute table
d3a0 : 76                    	db	0x3b00>>7		; R5 Sprite attribute table value
d3a1 : 0018                  	dw	0x1800			; Sprite pattern table
d3a3 : 03                    	db	0x1800>>11		; R6 Sprite pattern table value
d3a4 : f4                    	db	0xf4			; R7 White f/gnd, blue background
                             
d3a5 :                       vdp_base_table_txt
d3a5 : 01                    	db	VDP_SHORTDELAY	; Short delay
d3a6 : 00                    	db	%00000000		; R0 - No-extvid
d3a7 : f0                    	db	%11110000		; R1 - 16K,Disp-enable,Int-enable,
d3a8 : 0008                  	dw	0x0800			; Name table
d3aa : 02                    	db	0x0800>>10		; R2 Name table value
d3ab : 0000                  	dw	0				; Colour table NA
d3ad : 00                    	db	0				; R3 Colour table value
d3ae : 0000                  	dw	0x0000			; Pattern table
d3b0 : 00                    	db	0x0000>>11		; R4 Pattern table value
d3b1 : 0000                  	dw	0				; Sprite attribute table NA
d3b3 : 00                    	db	0				; R5 Sprite attribute table value
d3b4 : 0000                  	dw	0				; Sprite pattern table NA
d3b6 : 00                    	db	0				; R6 Sprite pattern table value
d3b7 : fd                    	db	0xfd			; R7 White f/gnd, magenta background
                             
d3b8 :                       mod_sz_vdp_e
                             
                             	include "vdp\graph.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  GRAPH.S
                             ;*  This is the graphics module, to handle text a
                             ;*  graphics.  On startup, the BBC DIP settings d
                             ;*  whether the computer will go in to 32 or 40 c
                             ;*  screen mode.  The kernel code calls the right
                             ;*  initialisation code.
                             ;*  For text modes, this module keeps track of wh
                             ;*  next put a character, and also takes care of 
                             ;*  to the next line as well as scrolling the con
                             ;*  when the cursor has reached the bottom right.
                             ;*  module also enables text input which is echoe
                             ;*  screen, to allow interactive input and editin
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             
d3b8 :                       mod_sz_graph_s
                             
                             ;****************************************
                             ;* gr_init_screen_common
                             ;* Common screen initialisation code
                             ;* A = Blank character
                             ;****************************************
d3b8 :                       gr_init_screen_common
                             	; Store blank char
d3b8 : 8512             [ 3] 	sta vdp_blank
                             	; Save value for cursor
AS65 Assembler for R6502 [1.42].                                     Page   86
-------------------------------- bank\bank0.s --------------------------------

d3ba : 8511             [ 3] 	sta vdp_curval
                             	
                             	; VRAM address of screen data
d3bc : a514             [ 3] 	lda vdp_base+vdp_addr_nme
d3be : 851f             [ 3] 	sta gr_scrngeom+gr_screen_start
d3c0 : a515             [ 3] 	lda vdp_base+vdp_addr_nme+1
d3c2 : 8520             [ 3] 	sta gr_scrngeom+gr_screen_start+1
                             
                             	; Top left cursor position 0,0
d3c4 : a200             [ 2] 	ldx #0
d3c6 : 8626             [ 3] 	stx gr_scrngeom+gr_cur_x
d3c8 : a000             [ 2] 	ldy #0
d3ca : 8427             [ 3] 	sty gr_scrngeom+gr_cur_y
                             
                             	; Clear screen
d3cc : 205fd4           [ 6] 	jsr gr_cls
                             
                             	; Cursor pointer in to screen
d3cf : 20e9d4           [ 6] 	jsr gr_set_cur	
                             	
d3d2 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* gr_init_screen_g1 if A=1 else g2 if A=2
                             ;* initialise the screen in graphic mode 1/2
                             ;****************************************
d3d3 :                       gr_init_screen_g
d3d3 : c901             [ 2] 	cmp #1
d3d5 : d005             [ 3] 	bne gr_init_screen_skip_g1
d3d7 : 20b5d2           [ 6] 	jsr init_vdp_g1
d3da : 8003             [ 3] 	bra gr_init_screen_cont
                             
d3dc :                       gr_init_screen_skip_g1
d3dc : 20c2d2           [ 6] 	jsr init_vdp_g2
                             
d3df :                       gr_init_screen_cont	
                             	; Size of screen in bytes
d3df : a900             [ 2] 	lda #lo(768)					
d3e1 : 8521             [ 3] 	sta gr_scrngeom+gr_screen_size
d3e3 : a903             [ 2] 	lda #hi(768)	
d3e5 : 8522             [ 3] 	sta gr_scrngeom+gr_screen_size+1
                             
                             	; Width and height
d3e7 : a920             [ 2] 	lda #32
d3e9 : 8523             [ 3] 	sta gr_scrngeom+gr_screen_w
d3eb : a918             [ 2] 	lda #24
d3ed : 8524             [ 3] 	sta gr_scrngeom+gr_screen_h
d3ef : 6425             [ 3] 	stz gr_scrngeom+gr_cur_off		; No cursor offset
                             
d3f1 : a920             [ 2] 	lda #' '						; Blank is SPACE
d3f3 : 20b8d3           [ 6] 	jsr gr_init_screen_common
d3f6 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* gr_init_screen_txt
                             ;* initialise the screen in text mode
                             ;****************************************
d3f7 :                       gr_init_screen_txt
d3f7 : 20d8d2           [ 6] 	jsr init_vdp_txt
                             
                             	; Size of screen in bytes
d3fa : a9c0             [ 2] 	lda #lo(960)					
AS65 Assembler for R6502 [1.42].                                     Page   87
-------------------------------- bank\bank0.s --------------------------------

d3fc : 8521             [ 3] 	sta gr_scrngeom+gr_screen_size
d3fe : a903             [ 2] 	lda #hi(960)	
d400 : 8522             [ 3] 	sta gr_scrngeom+gr_screen_size+1
                             
                             	; Width and height
d402 : a928             [ 2] 	lda #40
d404 : 8523             [ 3] 	sta gr_scrngeom+gr_screen_w
d406 : a918             [ 2] 	lda #24
d408 : 8524             [ 3] 	sta gr_scrngeom+gr_screen_h
d40a : 6425             [ 3] 	stz gr_scrngeom+gr_cur_off		; No cursor offset
                             
d40c : a920             [ 2] 	lda #' '						; Blank is SPACE
d40e : 20b8d3           [ 6] 	jsr gr_init_screen_common
                             
d411 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* gr_init_hires
                             ;* Input : X = Colour table fill value
                             ;* initialise the screen in hires mode
                             ;****************************************
d412 :                       gr_init_hires
d412 : 862c             [ 3] 	stx gr_scrngeom+gr_pixcol		; Save pixel colour
                             
d414 : e60f             [ 5] 	inc vdp_curoff
                             	
d416 : 20cfd2           [ 6] 	jsr init_vdp_hires
                             
                             	; Size of screen in bytes
d419 : a900             [ 2] 	lda #lo(6144)					
d41b : 8521             [ 3] 	sta gr_scrngeom+gr_screen_size
d41d : a918             [ 2] 	lda #hi(6144)	
d41f : 8522             [ 3] 	sta gr_scrngeom+gr_screen_size+1
                             
                             	; Width and height
d421 : a920             [ 2] 	lda #32
d423 : 8523             [ 3] 	sta gr_scrngeom+gr_screen_w
d425 : a9c0             [ 2] 	lda #192
d427 : 8524             [ 3] 	sta gr_scrngeom+gr_screen_h
d429 : a907             [ 2] 	lda #7
d42b : 8525             [ 3] 	sta gr_scrngeom+gr_cur_off		; Cursor on bottom r
                             
                             	; default pixel mode and mask
d42d : a901             [ 2] 	lda #1
d42f : 852a             [ 3] 	sta gr_scrngeom+gr_pixmode
d431 : a9ff             [ 2] 	lda #255
d433 : 852b             [ 3] 	sta gr_scrngeom+gr_pixmask
                             	
d435 : 78               [ 2] 	sei
                             	; point to colour table
d436 : a616             [ 3] 	ldx vdp_base+vdp_addr_col
d438 : a517             [ 3] 	lda vdp_base+vdp_addr_col+1
d43a : 20e3c4           [ 6] 	jsr vdp_wr_addr
                             	; set colour for 0x18 pages (6144) bytes
d43d : a52c             [ 3] 	lda gr_scrngeom+gr_pixcol		; Get the colour valu
d43f : a200             [ 2] 	ldx #0							; And fill 18 pages
d441 : a018             [ 2] 	ldy #0x18						
d443 : 20dbd2           [ 6] 	jsr vdp_fill_vram
                             
d446 : 58               [ 2] 	cli
                             	
                             	; Now point screen at pattern for HIRES
AS65 Assembler for R6502 [1.42].                                     Page   88
-------------------------------- bank\bank0.s --------------------------------

d447 : a518             [ 3] 	lda vdp_base+vdp_addr_pat
d449 : 8514             [ 3] 	sta vdp_base+vdp_addr_nme
d44b : a519             [ 3] 	lda vdp_base+vdp_addr_pat+1
d44d : 8515             [ 3] 	sta vdp_base+vdp_addr_nme+1
                             	
d44f : a900             [ 2] 	lda #0							; Blank is ZERO
d451 : 20b8d3           [ 6] 	jsr gr_init_screen_common
                             	
                             
d454 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* gr_init_screen
                             ;* A = Mode (0 = text, Not zero = graphic)
                             ;* initialise the screen in text mode
                             ;****************************************
d455 :                       gr_init_screen
d455 : c900             [ 2] 	cmp #0
d457 : d003             [ 3] 	bne gr_init_skip_txt
d459 : 4cf7d3           [ 3] 	jmp gr_init_screen_txt
d45c :                       gr_init_skip_txt
d45c : 4cd3d3           [ 3] 	jmp gr_init_screen_g
                             
                             ;****************************************
                             ;* gr_cls
                             ;* Clear the screen
                             ;****************************************
d45f :                       gr_cls
d45f : 48               [ 3] 	pha
d460 : da               [ 3] 	phx
d461 : 5a               [ 3] 	phy
                             
                             	; Set VDP Address
d462 : 78               [ 2] 	sei
d463 : a61f             [ 3] 	ldx gr_scrngeom+gr_screen_start
d465 : a520             [ 3] 	lda gr_scrngeom+gr_screen_start+1
d467 : 20e3c4           [ 6] 	jsr vdp_wr_addr
                             
                             	; X and Y count bytes to fill
d46a : a200             [ 2] 	ldx #0
d46c : a000             [ 2] 	ldy #0
d46e : a512             [ 3] 	lda vdp_blank
d470 :                       gr_cls_loop
d470 : 2009c5           [ 6] 	jsr vdp_wr_vram
d473 : e8               [ 2] 	inx
d474 : d001             [ 3] 	bne gr_cls_skipy
d476 : c8               [ 2] 	iny
d477 :                       gr_cls_skipy
d477 : e421             [ 3] 	cpx gr_scrngeom+gr_screen_size
d479 : d0f5             [ 3] 	bne gr_cls_loop
d47b : c422             [ 3] 	cpy gr_scrngeom+gr_screen_size+1
d47d : d0f1             [ 3] 	bne gr_cls_loop
                             	
d47f : 58               [ 2] 	cli
                             	
d480 : 7a               [ 4] 	ply
d481 : fa               [ 4] 	plx
d482 : 68               [ 4] 	pla
                             	
d483 : 60               [ 6] 	rts
                             	
                             ;****************************************
AS65 Assembler for R6502 [1.42].                                     Page   89
-------------------------------- bank\bank0.s --------------------------------

                             ;* gr_getXY_ptr
                             ;* Get VRAM address of screen from X,Y
                             ;* Input : X, Y = coords
                             ;* Output : X,Y = low and high VRAM address
                             ;* Regs affected : A
                             ;****************************************
d484 :                       gr_getXY_ptr
                             	; 32 or 40 columns table selection
d484 : a523             [ 3] 	lda gr_scrngeom+gr_screen_w
d486 : c928             [ 2] 	cmp #40
d488 : d011             [ 3] 	bne gr_set_skip_40
                             
d48a : 18               [ 2] 	clc
d48b : b9ead9           [ 4] 	lda gr_offset_40lo, y
d48e : 651f             [ 3] 	adc gr_scrngeom+gr_screen_start
d490 : 852d             [ 3] 	sta gr_scrngeom+gr_geom_tmp
d492 : b902da           [ 4] 	lda gr_offset_40hi, y
d495 : 6520             [ 3] 	adc gr_scrngeom+gr_screen_start+1
d497 : 852e             [ 3] 	sta gr_scrngeom+gr_geom_tmp+1
d499 : 8013             [ 3] 	bra gr_add_x_offset
                             
d49b :                       gr_set_skip_40
                             	; 32 byte width window - but what if hi-res (bec
d49b : a525             [ 3] 	lda gr_scrngeom+gr_cur_off
d49d : d01a             [ 3] 	bne gr_calc_hires_ptr
d49f : 18               [ 2] 	clc
d4a0 : b91ada           [ 4] 	lda gr_offset_32lo, y
d4a3 : 651f             [ 3] 	adc gr_scrngeom+gr_screen_start
d4a5 : 852d             [ 3] 	sta gr_scrngeom+gr_geom_tmp
d4a7 : b932da           [ 4] 	lda gr_offset_32hi, y
d4aa : 6520             [ 3] 	adc gr_scrngeom+gr_screen_start+1
d4ac : 852e             [ 3] 	sta gr_scrngeom+gr_geom_tmp+1
                             
d4ae :                       gr_add_x_offset	
d4ae : 18               [ 2] 	clc
d4af : 8a               [ 2] 	txa
d4b0 : 652d             [ 3] 	adc gr_scrngeom+gr_geom_tmp
d4b2 : aa               [ 2] 	tax								; vram addr lo in X
d4b3 : a52e             [ 3] 	lda gr_scrngeom+gr_geom_tmp+1
d4b5 : 6900             [ 2] 	adc #0
d4b7 : a8               [ 2] 	tay								; vram addr hi in Y
d4b8 : 60               [ 6] 	rts
                             	
d4b9 :                       gr_calc_hires_ptr
                             	; Low byte = X&F8 | Y&07
d4b9 : 8a               [ 2] 	txa
d4ba : 29f8             [ 2] 	and #0xf8
d4bc : 852d             [ 3] 	sta gr_scrngeom+gr_geom_tmp
d4be : 98               [ 2] 	tya
d4bf : 2907             [ 2] 	and #0x07
d4c1 : 052d             [ 3] 	ora gr_scrngeom+gr_geom_tmp
d4c3 : aa               [ 2] 	tax			; Low address in X
                             	; High byte = Y>>3
d4c4 : 98               [ 2] 	tya
d4c5 : 4a               [ 2] 	lsr a
d4c6 : 4a               [ 2] 	lsr a
d4c7 : 4a               [ 2] 	lsr a
d4c8 : a8               [ 2] 	tay			; High address in Y
d4c9 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* gr_plot
AS65 Assembler for R6502 [1.42].                                     Page   90
-------------------------------- bank\bank0.s --------------------------------

                             ;* Write a byte in the screen pos
                             ;* Input : X,Y = coord, A = Byte to put
                             ;* Output : None
                             ;* Regs affected : All
                             ;****************************************
d4ca :                       gr_plot
d4ca : 48               [ 3] 	pha					; Save byte to put
d4cb : 2084d4           [ 6] 	jsr gr_getXY_ptr	; vram addr in x,y
d4ce : 68               [ 4] 	pla					; Get byte to put
d4cf : 200ec5           [ 6] 	jsr vdp_poke
d4d2 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* gr_put
                             ;* Write a byte in the current cursor position
                             ;* Input : A = Byte to put
                             ;* Output : None
                             ;* Regs affected : All
                             ;****************************************
d4d3 :                       gr_put
d4d3 : e60f             [ 5] 	inc vdp_curoff		; Disable cusror
d4d5 : 8511             [ 3] 	sta vdp_curval		; Update cursor value
                             	; Load cursor address
d4d7 : a628             [ 3] 	ldx gr_scrngeom+gr_cur_ptr
d4d9 : a429             [ 3] 	ldy gr_scrngeom+gr_cur_ptr+1
d4db : 200ec5           [ 6] 	jsr vdp_poke
d4de : c60f             [ 5] 	dec vdp_curoff		; Allow cursor flashing
d4e0 : 60               [ 6] 	rts
                             	
                             	
                             ;****************************************
                             ;* gr_get
                             ;* Get the byte in the screen pos
                             ;* Input : X,Y = coord
                             ;* Output : X,Y = address, A = peeked byte
                             ;* Regs affected : All
                             ;****************************************
d4e1 :                       gr_get
d4e1 : 2084d4           [ 6] 	jsr gr_getXY_ptr	; vram addr in x,y
d4e4 : 98               [ 2] 	tya					; hi needs to be in A for peek
d4e5 : 201ac5           [ 6] 	jsr vdp_peek
d4e8 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* gr_set_cur
                             ;* Set the cursor position
                             ;* Input : X, Y = position
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
d4e9 :                       gr_set_cur
d4e9 : e60f             [ 5] 	inc vdp_curoff				; Disable cursor
                             	
                             	; Save new cursor position
d4eb : 8626             [ 3] 	stx gr_scrngeom+gr_cur_x
d4ed : 8427             [ 3] 	sty gr_scrngeom+gr_cur_y
                             	
                             	; First restore what is under the cursor
d4ef : a511             [ 3] 	lda vdp_curval
d4f1 : 20d3d4           [ 6] 	jsr gr_put
                             
                             	; Now calculate the new cursor vram address
AS65 Assembler for R6502 [1.42].                                     Page   91
-------------------------------- bank\bank0.s --------------------------------

d4f4 : a626             [ 3] 	ldx gr_scrngeom+gr_cur_x
d4f6 : a427             [ 3] 	ldy gr_scrngeom+gr_cur_y
d4f8 : 20e1d4           [ 6] 	jsr gr_get					; X,Y=address,A=vram contents
d4fb : 8628             [ 3] 	stx gr_scrngeom+gr_cur_ptr
d4fd : 8429             [ 3] 	sty gr_scrngeom+gr_cur_ptr+1
d4ff : 8511             [ 3] 	sta vdp_curval
                             
d501 : c60f             [ 5] 	dec vdp_curoff
                             	
d503 : 60               [ 6] 	rts
                             	
                             
                             ;****************************************
                             ;* gr_hchar
                             ;* Plot a char to hires X,Y coordinates with char
                             ;* Input : X,Y = coord, A = Char code
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
d504 :                       gr_hchar
d504 : 863b             [ 3] 	stx tmp_blo				; Save X coord
d506 : 843c             [ 3] 	sty tmp_bhi				; Save Y coord
                             	
                             	; Calculate font address of char code A in to tm
d508 : 853d             [ 3] 	sta tmp_clo
d50a : 643e             [ 3] 	stz tmp_chi
                             	; Multiply by 8
d50c : 063d             [ 5] 	asl tmp_clo
d50e : 263e             [ 5] 	rol tmp_chi
d510 : 063d             [ 5] 	asl tmp_clo
d512 : 263e             [ 5] 	rol tmp_chi
d514 : 063d             [ 5] 	asl tmp_clo
d516 : 263e             [ 5] 	rol tmp_chi
                             	; Add font ROM address
d518 : a900             [ 2] 	lda #lo(vdp_font)
d51a : 653d             [ 3] 	adc tmp_clo
d51c : 853d             [ 3] 	sta tmp_clo
d51e : a9ce             [ 2] 	lda #hi(vdp_font)
d520 : 653e             [ 3] 	adc tmp_chi
d522 : 853e             [ 3] 	sta tmp_chi
                             	
                             	; Save 3LSB of x coord
d524 : 8a               [ 2] 	txa
d525 : 2907             [ 2] 	and #7
d527 : 853f             [ 3] 	sta tmp_a
                             	
                             	; Generate the shifted character for each line (
                             	; 16 bytes to store a 2x8 byte shifted image of 
d529 : a200             [ 2] 	ldx #0	
d52b :                       gr_hchar_shiftline
                             	; load up a line of font in to 16 bits, left jus
d52b : b23d             [ 5] 	lda (tmp_clo)
d52d : e63d             [ 5] 	inc tmp_clo
d52f : 7496             [ 4] 	stz ztmp_16+8,x
                             	; Get 3LSB of x coord in to Y = number of column
d531 : a43f             [ 3] 	ldy tmp_a
d533 :                       gr_hchar_shiftcol
d533 : f006             [ 3] 	beq gr_hchar_shiftdone		; Branch on Y = 0
d535 : 4a               [ 2] 	lsr a
d536 : 7696             [ 6] 	ror ztmp_16+8,x
d538 : 88               [ 2] 	dey
d539 : 80f8             [ 3] 	bra gr_hchar_shiftcol
AS65 Assembler for R6502 [1.42].                                     Page   92
-------------------------------- bank\bank0.s --------------------------------

d53b :                       gr_hchar_shiftdone
d53b : 958e             [ 4] 	sta ztmp_16,x
d53d : e8               [ 2] 	inx
d53e : e008             [ 2] 	cpx #8						; Do 8 lines each 16 bits wide
d540 : d0e9             [ 3] 	bne gr_hchar_shiftline
                             
                             	; Ok we have a char image in dram ztmp_16, need 
                             
d542 : e60f             [ 5] 	inc vdp_curoff				; Disable cursor
                             	
                             	; do 8 lines of left image
d544 : a200             [ 2] 	ldx #0
d546 :                       gr_hchar_getlimage
d546 : da               [ 3] 	phx					; Save index
                             	; Get x,y coord and calc address in to tmp_alo
d547 : a63b             [ 3] 	ldx tmp_blo
d549 : a43c             [ 3] 	ldy tmp_bhi
d54b : 2084d4           [ 6] 	jsr gr_getXY_ptr
d54e : 8639             [ 3] 	stx tmp_alo
d550 : 843a             [ 3] 	sty tmp_ahi
                             	; high need to be in A for peek
d552 : 98               [ 2] 	tya
d553 : 201ac5           [ 6] 	jsr vdp_peek		; Get image byte from vram
d556 : 853d             [ 3] 	sta tmp_clo
d558 : fa               [ 4] 	plx					; Restore index but don't lose it
d559 : da               [ 3] 	phx
d55a : a42a             [ 3] 	ldy gr_scrngeom+gr_pixmode		; Get the mode to pl
d55c : 158e             [ 4] 	ora ztmp_16,x		; First assume draw
d55e : c001             [ 2] 	cpy #1				; Is that the mode
d560 : f00a             [ 3] 	beq gr_hchar_getlimage_plot
d562 : 558e             [ 4] 	eor ztmp_16,x		; Then assume erase
d564 : c000             [ 2] 	cpy #0
d566 : f004             [ 3] 	beq gr_hchar_getlimage_plot
d568 : a53d             [ 3] 	lda tmp_clo			; Else we want to EOR
d56a : 558e             [ 4] 	eor ztmp_16,x		; EOR VRAM with Image
d56c :                       gr_hchar_getlimage_plot
                             	; Get vram address from tmp_alo
d56c : a639             [ 3] 	ldx tmp_alo
d56e : a43a             [ 3] 	ldy tmp_ahi
d570 : 200ec5           [ 6] 	jsr vdp_poke		; Put image on
d573 : e63c             [ 5] 	inc tmp_bhi			; Update y coord
d575 : fa               [ 4] 	plx					; Restore index
d576 : e8               [ 2] 	inx
d577 : e008             [ 2] 	cpx #8
d579 : d0cb             [ 3] 	bne gr_hchar_getlimage
                             
d57b : 38               [ 2] 	sec					; Re-adjust y coord back to top
d57c : a53c             [ 3] 	lda tmp_bhi
d57e : e908             [ 2] 	sbc #8
d580 : 853c             [ 3] 	sta tmp_bhi
d582 : 18               [ 2] 	clc					; Move x coord across to RHS by adding 8
d583 : a53b             [ 3] 	lda tmp_blo
d585 : 6908             [ 2] 	adc #8
d587 : 853b             [ 3] 	sta tmp_blo
d589 : b037             [ 3] 	bcs	gr_hchar_skip_rimage	; Don't do RHS if out o
                             	
                             	; do 8 lines of right image
d58b : a200             [ 2] 	ldx #0
d58d :                       gr_hchar_getrimage
d58d : da               [ 3] 	phx					; Save index
                             	; Get x,y coord and calc address in to tmp_alo
d58e : a63b             [ 3] 	ldx tmp_blo
AS65 Assembler for R6502 [1.42].                                     Page   93
-------------------------------- bank\bank0.s --------------------------------

d590 : a43c             [ 3] 	ldy tmp_bhi
d592 : 2084d4           [ 6] 	jsr gr_getXY_ptr
d595 : 8639             [ 3] 	stx tmp_alo
d597 : 843a             [ 3] 	sty tmp_ahi
                             	; high need to be in A for peek
d599 : 98               [ 2] 	tya
d59a : 201ac5           [ 6] 	jsr vdp_peek		; Get image byte from vram
d59d : 853d             [ 3] 	sta tmp_clo
d59f : fa               [ 4] 	plx					; Restore index but don't lose it
d5a0 : da               [ 3] 	phx
d5a1 : a42a             [ 3] 	ldy gr_scrngeom+gr_pixmode		; Get the mode to pl
d5a3 : 1596             [ 4] 	ora ztmp_16+8,x		; First assume draw
d5a5 : c001             [ 2] 	cpy #1				; Is that the mode
d5a7 : f00a             [ 3] 	beq gr_hchar_getrimage_plot
d5a9 : 5596             [ 4] 	eor ztmp_16+8,x		; Then assume erase
d5ab : c000             [ 2] 	cpy #0
d5ad : f004             [ 3] 	beq gr_hchar_getrimage_plot
d5af : a53d             [ 3] 	lda tmp_clo			; Else we want to EOR
d5b1 : 5596             [ 4] 	eor ztmp_16+8,x		; EOR VRAM with Image
d5b3 :                       gr_hchar_getrimage_plot
                             	; Get vram address from tmp_alo
d5b3 : a639             [ 3] 	ldx tmp_alo
d5b5 : a43a             [ 3] 	ldy tmp_ahi
d5b7 : 200ec5           [ 6] 	jsr vdp_poke		; Put image on
d5ba : e63c             [ 5] 	inc tmp_bhi			; Update y coord
d5bc : fa               [ 4] 	plx					; Restore index
d5bd : e8               [ 2] 	inx
d5be : e008             [ 2] 	cpx #8
d5c0 : d0cb             [ 3] 	bne gr_hchar_getrimage
d5c2 :                       gr_hchar_skip_rimage
d5c2 : c60f             [ 5] 	dec vdp_curoff				; Enable cursor
                             
d5c4 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* gr_point
                             ;* Write a point to the X,Y coordinates
                             ;* Input : X,Y = coord
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
d5c5 :                       gr_point
                             	; Save A and X for later
d5c5 : da               [ 3] 	phx
                             
                             	; Get hires address from X,Y coordinates
d5c6 : 2084d4           [ 6] 	jsr gr_getXY_ptr
d5c9 : 8639             [ 3] 	stx tmp_alo
d5cb : 843a             [ 3] 	sty tmp_ahi
                             
                             	; A is hi byte for peek
d5cd : 98               [ 2] 	tya
                             	
d5ce : 201ac5           [ 6] 	jsr vdp_peek
                             	; Save in temp
d5d1 : 853b             [ 3] 	sta tmp_blo
                             
                             	; Get X back and mask off 3 LSBs
d5d3 : 68               [ 4] 	pla
d5d4 : 2907             [ 2] 	and #0x07
                             	; Use this to find the bit number mask and save 
d5d6 : aa               [ 2] 	tax
AS65 Assembler for R6502 [1.42].                                     Page   94
-------------------------------- bank\bank0.s --------------------------------

d5d7 : bd08d6           [ 4] 	lda gr_point_mask,x
d5da : 853c             [ 3] 	sta tmp_bhi
                             	; Get the mode number in to X
d5dc : a62a             [ 3] 	ldx gr_scrngeom+gr_pixmode
                             	; load VRAM byte
d5de : a53b             [ 3] 	lda tmp_blo
                             	; first assume that we want to set a bit - OR wi
d5e0 : 053c             [ 3] 	ora tmp_bhi
                             	; if that is correct then done
d5e2 : e001             [ 2] 	cpx #1
d5e4 : f00a             [ 3] 	beq gr_point_done
                             	; now assume that actually we want to erase but 
d5e6 : 453c             [ 3] 	eor tmp_bhi
                             	; if that is correct then done
d5e8 : e000             [ 2] 	cpx #0
d5ea : f004             [ 3] 	beq gr_point_done
                             	; else we want to really just do an eor of VRAM 
d5ec : a53b             [ 3] 	lda tmp_blo
d5ee : 453c             [ 3] 	eor tmp_bhi
                             	; so now we have the VRAM bit set properly in te
d5f0 :                       gr_point_done
d5f0 : a639             [ 3] 	ldx tmp_alo
d5f2 : a43a             [ 3] 	ldy tmp_ahi
d5f4 : 200ec5           [ 6] 	jsr vdp_poke
                             
                             	; now put in the right colour
                             	; add the x,y offset in to the colour table
d5f7 : 18               [ 2] 	clc
d5f8 : a516             [ 3] 	lda vdp_base+vdp_addr_col
d5fa : 6539             [ 3] 	adc tmp_alo
d5fc : aa               [ 2] 	tax
d5fd : a517             [ 3] 	lda vdp_base+vdp_addr_col+1
d5ff : 653a             [ 3] 	adc tmp_ahi
d601 : a8               [ 2] 	tay
d602 : a52c             [ 3] 	lda gr_scrngeom+gr_pixcol
d604 : 200ec5           [ 6] 	jsr vdp_poke
                             
d607 : 60               [ 6] 	rts
d608 :                       gr_point_mask
d608 : 8040201008040201      	db 0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01
                             
                             
                             ;****************************************
                             ;* gr_box
                             ;* Draw a box from x0,y0 -> x1,y1
                             ;* Input :	num_a   = x0
                             ;*			num_a+1 = y0
                             ;*			num_a+2 = x1
                             ;*			num_a+3 = y1
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
d610 :                       gr_box
d610 : a58e             [ 3] 	lda num_a					; If x0,x1 in same byte column
d612 : 29f8             [ 2] 	and #0xf8					; then special handling
d614 : 853b             [ 3] 	sta tmp_blo
d616 : a590             [ 3] 	lda num_a+2
d618 : 29f8             [ 2] 	and #0xf8
d61a : c53b             [ 3] 	cmp tmp_blo
d61c : f05f             [ 3] 	beq gr_box_tiny_width
                             	; x0, x1 in different byte columns
d61e : a58e             [ 3] 	lda num_a					; Get lhs mask
AS65 Assembler for R6502 [1.42].                                     Page   95
-------------------------------- bank\bank0.s --------------------------------

d620 : 2907             [ 2] 	and #7
d622 : aa               [ 2] 	tax
d623 : bd0bd7           [ 4] 	lda gr_box_lmask,x
d626 : 853b             [ 3] 	sta tmp_blo
d628 : a68e             [ 3] 	ldx num_a					; Do top left
d62a : a48f             [ 3] 	ldy num_a+1
d62c : 20d9d6           [ 6] 	jsr gr_box_plot
d62f : a53b             [ 3] 	lda tmp_blo
d631 : a68e             [ 3] 	ldx num_a					; Do bottom left
d633 : a491             [ 3] 	ldy num_a+3
d635 : 20d9d6           [ 6] 	jsr gr_box_plot
d638 : a590             [ 3] 	lda num_a+2					; Get rhs mask
d63a : 2907             [ 2] 	and #7
d63c : aa               [ 2] 	tax
d63d : bd13d7           [ 4] 	lda gr_box_rmask,x
d640 : 853b             [ 3] 	sta tmp_blo
d642 : a690             [ 3] 	ldx num_a+2					; Do top right
d644 : a48f             [ 3] 	ldy num_a+1
d646 : 20d9d6           [ 6] 	jsr gr_box_plot
d649 : a53b             [ 3] 	lda tmp_blo
d64b : a690             [ 3] 	ldx num_a+2					; Do bottom right
d64d : a491             [ 3] 	ldy num_a+3
d64f : 20d9d6           [ 6] 	jsr gr_box_plot
                             	; Do fast horz lines if x0,x1
                             	; are in different byte columns
d652 : a58e             [ 3] 	lda num_a					; Byte align x0
d654 : 29f8             [ 2] 	and #0xf8
d656 : 853b             [ 3] 	sta tmp_blo
d658 : a590             [ 3] 	lda num_a+2					; Byte align x1
d65a : 29f8             [ 2] 	and #0xf8
d65c : 853c             [ 3] 	sta tmp_bhi
d65e :                       gr_box_8line
d65e : a53c             [ 3] 	lda tmp_bhi					; Move left 1 column
d660 : 38               [ 2] 	sec
d661 : e908             [ 2] 	sbc #8
d663 : 853c             [ 3] 	sta tmp_bhi
d665 : c53b             [ 3] 	cmp tmp_blo
d667 : f039             [ 3] 	beq gr_box_do_vert			; if columns same then done
d669 : a63c             [ 3] 	ldx tmp_bhi					; Do top from right to left
d66b : a48f             [ 3] 	ldy num_a+1
d66d : a9ff             [ 2] 	lda #0xff
d66f : 20d9d6           [ 6] 	jsr gr_box_plot
d672 : a63c             [ 3] 	ldx tmp_bhi					; Do top from right to left
d674 : a491             [ 3] 	ldy num_a+3
d676 : a9ff             [ 2] 	lda #0xff
d678 : 20d9d6           [ 6] 	jsr gr_box_plot
d67b : 80e1             [ 3] 	bra gr_box_8line			; Looping
d67d :                       gr_box_tiny_width
d67d : a58e             [ 3] 	lda num_a
d67f : 2907             [ 2] 	and #7
d681 : 48               [ 3] 	pha
d682 : a590             [ 3] 	lda num_a+2
d684 : 2907             [ 2] 	and #7
d686 : aa               [ 2] 	tax
d687 : bd13d7           [ 4] 	lda gr_box_rmask,x			; Get rhs mask
d68a : fa               [ 4] 	plx
d68b : 3d0bd7           [ 4] 	and gr_box_lmask,x			; AND with lhs mask
d68e : 853b             [ 3] 	sta tmp_blo					; This is the intra column mask
d690 : a68e             [ 3] 	ldx num_a					; Plot top
d692 : a48f             [ 3] 	ldy num_a+1
d694 : 20d9d6           [ 6] 	jsr gr_box_plot
d697 : a690             [ 3] 	ldx num_a+2					; Plot bottom
AS65 Assembler for R6502 [1.42].                                     Page   96
-------------------------------- bank\bank0.s --------------------------------

d699 : a491             [ 3] 	ldy num_a+3
d69b : c48f             [ 3] 	cpy num_a+1					; but only if different from top
d69d : f039             [ 3] 	beq gr_box_done				; if top=bottom then finished
d69f : 20d9d6           [ 6] 	jsr gr_box_plot
d6a2 :                       gr_box_do_vert
                             	; Do the vertical sides of the box
d6a2 : a58e             [ 3] 	lda num_a					; Find bit position of x0 (left)
d6a4 : 2907             [ 2] 	and #7
d6a6 : aa               [ 2] 	tax							; And get value to write
d6a7 : bd08d6           [ 4] 	lda gr_point_mask,x
d6aa : 853b             [ 3] 	sta tmp_blo
                             	
d6ac : a590             [ 3] 	lda num_a+2					; Find bit position of x1 (right
d6ae : 2907             [ 2] 	and #7
d6b0 : aa               [ 2] 	tax							; And get value to write
d6b1 : bd08d6           [ 4] 	lda gr_point_mask,x
d6b4 : 853c             [ 3] 	sta tmp_bhi
                             
d6b6 : a48f             [ 3] 	ldy num_a+1					; Get y0 coord and save
d6b8 : 849a             [ 3] 	sty num_tmp
d6ba :                       gr_box_vert
d6ba : e69a             [ 5] 	inc num_tmp					; Increment y first
d6bc : a49a             [ 3] 	ldy num_tmp
d6be : c491             [ 3] 	cpy num_a+3					; if thisY>=y1 then done
d6c0 : b016             [ 3] 	bcs gr_box_vert_done
d6c2 : a68e             [ 3] 	ldx num_a					; Do left side
d6c4 : a53b             [ 3] 	lda tmp_blo
d6c6 : 20d9d6           [ 6] 	jsr gr_box_plot
d6c9 : a690             [ 3] 	ldx num_a+2					; Do right line
d6cb : e48e             [ 3] 	cpx num_a					; Only if not same as lhs
d6cd : f007             [ 3] 	beq gr_box_skip_rhs
d6cf : a49a             [ 3] 	ldy num_tmp
d6d1 : a53c             [ 3] 	lda tmp_bhi
d6d3 : 20d9d6           [ 6] 	jsr gr_box_plot
d6d6 :                       gr_box_skip_rhs
d6d6 : 80e2             [ 3] 	bra gr_box_vert				; looping
d6d8 :                       gr_box_vert_done
d6d8 :                       gr_box_done
d6d8 : 60               [ 6] 	rts
                             
                             ; Box draw common draw routine
                             ; x,y is pixel coord
                             ; a is the value to write
d6d9 :                       gr_box_plot
d6d9 : 853d             [ 3] 	sta tmp_clo					; Save mask to write
d6db : 8a               [ 2] 	txa
d6dc : 98               [ 2] 	tya
d6dd : 2084d4           [ 6] 	jsr gr_getXY_ptr
d6e0 : da               [ 3] 	phx
d6e1 : 98               [ 2] 	tya							; A=high byte for peek
d6e2 : 201ac5           [ 6] 	jsr vdp_peek				; Get current screen byte
d6e5 : 853e             [ 3] 	sta tmp_chi
d6e7 : a62a             [ 3] 	ldx gr_scrngeom+gr_pixmode	; Use screen mode
d6e9 : 053d             [ 3] 	ora tmp_clo					; Assume mode 1 (or)
d6eb : e001             [ 2] 	cpx #1						; Done if correct
d6ed : f00a             [ 3] 	beq gr_box_write
d6ef : 453d             [ 3] 	eor tmp_clo					; Assume mode 0 (eor erases or)
d6f1 : e000             [ 2] 	cpx #0						; Done if correct
d6f3 : f004             [ 3] 	beq gr_box_write
d6f5 : a53e             [ 3] 	lda tmp_chi					; Else eor with source
d6f7 : 453d             [ 3] 	eor tmp_clo
d6f9 :                       gr_box_write
AS65 Assembler for R6502 [1.42].                                     Page   97
-------------------------------- bank\bank0.s --------------------------------

d6f9 : fa               [ 4] 	plx							; Restore x, y is intact
d6fa : 200ec5           [ 6] 	jsr vdp_poke				; Poke the value
d6fd : 18               [ 2] 	clc							; Calculate the colour table offset
d6fe : 8a               [ 2] 	txa							; Low byte
d6ff : 6516             [ 3] 	adc vdp_base+vdp_addr_col
d701 : aa               [ 2] 	tax
d702 : 98               [ 2] 	tya							; High byte
d703 : 6517             [ 3] 	adc vdp_base+vdp_addr_col+1
d705 : a8               [ 2] 	tay
d706 : a52c             [ 3] 	lda gr_scrngeom+gr_pixcol	; Colour
d708 : 4c0ec5           [ 3] 	jmp vdp_poke
                             
d70b :                       gr_box_lmask
d70b : ff7f3f1f0f070301      	db 0xff,0x7f,0x3f,0x1f,0x0f,0x07,0x03,0x01
d713 :                       gr_box_rmask
d713 : 80c0e0f0f8fcfeff      	db 0x80,0xc0,0xe0,0xf0,0xf8,0xfc,0xfe,0xff
                             
                             	
                             ;****************************************
                             ;* gr_circle
                             ;* Draw a circle centre x0,y0, radius r
                             ;* Input :	num_a   = x0
                             ;*			num_a+1 = y0
                             ;*			num_a+2 = r
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
d71b :                       gr_circle
                             ; Local definitions of temp space to make
                             ; the rest of the code easier to read
008e =                       grc_x0 	= (num_a)
008f =                       grc_y0 	= (num_a+1)
0090 =                       grc_r 	= (num_a+2)
0091 =                       grc_x 	= (num_a+3)
0093 =                       grc_y	= (num_b+1)
0094 =                       grc_d	= (num_b+2)
                             
                             	;x = radius
d71b : a590             [ 3] 	lda grc_r
d71d : 8591             [ 3] 	sta grc_x
                             	;y = 0
d71f : 6493             [ 3] 	stz grc_y
                             	;decision = 1 - x
d721 : a901             [ 2] 	lda #1
d723 : 38               [ 2] 	sec
d724 : e591             [ 3] 	sbc grc_x
d726 : 8594             [ 3] 	sta grc_d
d728 :                       gr_circle_plot
                             	;while(x >= y)
d728 : a591             [ 3] 	lda grc_x
d72a : c593             [ 3] 	cmp grc_y
d72c : 9028             [ 3] 	bcc gr_circle_done
                             	;plot 8 points on current x,y
d72e : 2057d7           [ 6] 	jsr gr_circle_points
                             	;y++
d731 : e693             [ 5] 	inc grc_y
                             	;if d<=0
d733 : a594             [ 3] 	lda grc_d
d735 : f013             [ 3] 	beq gr_circle_d_lte0
d737 : 3011             [ 3] 	bmi gr_circle_d_lte0
                             	;else
                             	;x--
AS65 Assembler for R6502 [1.42].                                     Page   98
-------------------------------- bank\bank0.s --------------------------------

d739 : c691             [ 5] 	dec grc_x
                             	;decision += 2 * (y - x) + 1
d73b : a593             [ 3] 	lda grc_y
d73d : 38               [ 2] 	sec
d73e : e591             [ 3] 	sbc grc_x
d740 : 0a               [ 2] 	asl a
d741 : 18               [ 2] 	clc
d742 : 6901             [ 2] 	adc #1
d744 : 6594             [ 3] 	adc grc_d
d746 : 8594             [ 3] 	sta grc_d
d748 : 80de             [ 3] 	bra gr_circle_plot	
d74a :                       gr_circle_d_lte0
                             	;decision += 2 * y + 1
d74a : a593             [ 3] 	lda grc_y
d74c : 0a               [ 2] 	asl a
d74d : 18               [ 2] 	clc
d74e : 6901             [ 2] 	adc #1
d750 : 6594             [ 3] 	adc grc_d
d752 : 8594             [ 3] 	sta grc_d
d754 : 80d2             [ 3] 	bra gr_circle_plot	
d756 :                       gr_circle_done
d756 : 60               [ 6] 	rts
d757 :                       gr_circle_points
                             ; Local names of temp storage
                             ; to make code easier to read
                             	;DrawPixel( x + x0,  yh + y0);
d757 : a591             [ 3] 	lda grc_x
d759 : 18               [ 2] 	clc
d75a : 658e             [ 3] 	adc grc_x0
d75c : aa               [ 2] 	tax
d75d : a593             [ 3] 	lda grc_y
d75f : 18               [ 2] 	clc
d760 : 658f             [ 3] 	adc grc_y0
d762 : a8               [ 2] 	tay
d763 : 20c5d5           [ 6] 	jsr gr_point
                             	;DrawPixel( y + x0,  xh + y0);
d766 : a593             [ 3] 	lda grc_y
d768 : 18               [ 2] 	clc
d769 : 658e             [ 3] 	adc grc_x0
d76b : aa               [ 2] 	tax
d76c : a591             [ 3] 	lda grc_x
d76e : 18               [ 2] 	clc
d76f : 658f             [ 3] 	adc grc_y0
d771 : a8               [ 2] 	tay
d772 : 20c5d5           [ 6] 	jsr gr_point
                             	;DrawPixel(-x + x0,  yh + y0);
d775 : a58e             [ 3] 	lda grc_x0
d777 : 38               [ 2] 	sec
d778 : e591             [ 3] 	sbc grc_x
d77a : aa               [ 2] 	tax
d77b : a593             [ 3] 	lda grc_y
d77d : 18               [ 2] 	clc
d77e : 658f             [ 3] 	adc grc_y0
d780 : a8               [ 2] 	tay
d781 : 20c5d5           [ 6] 	jsr gr_point
                             	;DrawPixel(-y + x0,  xh + y0);
d784 : a58e             [ 3] 	lda grc_x0
d786 : 38               [ 2] 	sec
d787 : e593             [ 3] 	sbc grc_y
d789 : aa               [ 2] 	tax
d78a : a591             [ 3] 	lda grc_x
d78c : 18               [ 2] 	clc
AS65 Assembler for R6502 [1.42].                                     Page   99
-------------------------------- bank\bank0.s --------------------------------

d78d : 658f             [ 3] 	adc grc_y0
d78f : a8               [ 2] 	tay
d790 : 20c5d5           [ 6] 	jsr gr_point
                             	;DrawPixel(-x + x0, -yh + y0);
d793 : a58e             [ 3] 	lda grc_x0
d795 : 38               [ 2] 	sec
d796 : e591             [ 3] 	sbc grc_x
d798 : aa               [ 2] 	tax
d799 : a58f             [ 3] 	lda grc_y0
d79b : 38               [ 2] 	sec
d79c : e593             [ 3] 	sbc grc_y
d79e : a8               [ 2] 	tay
d79f : 20c5d5           [ 6] 	jsr gr_point
                             	;DrawPixel(-y + x0, -xh + y0);
d7a2 : a58e             [ 3] 	lda grc_x0
d7a4 : 38               [ 2] 	sec
d7a5 : e593             [ 3] 	sbc grc_y
d7a7 : aa               [ 2] 	tax
d7a8 : a58f             [ 3] 	lda grc_y0
d7aa : 38               [ 2] 	sec
d7ab : e591             [ 3] 	sbc grc_x
d7ad : a8               [ 2] 	tay
d7ae : 20c5d5           [ 6] 	jsr gr_point
                             	;DrawPixel( x + x0, -yh + y0);
d7b1 : a591             [ 3] 	lda grc_x
d7b3 : 18               [ 2] 	clc
d7b4 : 658e             [ 3] 	adc grc_x0
d7b6 : aa               [ 2] 	tax
d7b7 : a58f             [ 3] 	lda grc_y0
d7b9 : 38               [ 2] 	sec
d7ba : e593             [ 3] 	sbc grc_y
d7bc : a8               [ 2] 	tay
d7bd : 20c5d5           [ 6] 	jsr gr_point
                             	;DrawPixel( y + x0, -xh + y0);
d7c0 : a593             [ 3] 	lda grc_y
d7c2 : 18               [ 2] 	clc
d7c3 : 658e             [ 3] 	adc grc_x0
d7c5 : aa               [ 2] 	tax
d7c6 : a58f             [ 3] 	lda grc_y0
d7c8 : 38               [ 2] 	sec
d7c9 : e591             [ 3] 	sbc grc_x
d7cb : a8               [ 2] 	tay
d7cc : 20c5d5           [ 6] 	jsr gr_point
d7cf : 60               [ 6] 	rts
                             
                             	
                             	
                             ;****************************************
                             ;* gr_line
                             ;* Draw a line from x0,y0 -> x1,y1
                             ;* Input :	num_a   = x0
                             ;*			num_a+1 = y0
                             ;*			num_a+2 = x1
                             ;*			num_a+3 = y1
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
d7d0 :                       gr_line
                             
                             ; Local definitions of temp space to make
                             ; the rest of the code easier to read
008e =                       grl_x0 	= (num_a)
AS65 Assembler for R6502 [1.42].                                     Page  100
-------------------------------- bank\bank0.s --------------------------------

008f =                       grl_y0 	= (num_a+1)
0090 =                       grl_x1 	= (num_a+2)
0091 =                       grl_y1 	= (num_a+3)
0093 =                       grl_dx	= (num_b+1)
0094 =                       grl_dy	= (num_b+2)
0095 =                       grl_xyyx= (num_b+3)
0096 =                       grl_2dx	= (num_x)
0098 =                       grl_2dy	= (num_x+2)
009a =                       grl_2dxy= (num_tmp)
009c =                       grl_inx	= (num_tmp+2)
009d =                       grl_iny = (num_tmp+3)
009e =                       grl_p	= (num_buf)
                             
d7d0 : 6495             [ 3] 	stz grl_xyyx				; Assume normal xy axis
                             	
                             ;    int dx, dy, p, x, y;
                             	; check if abs(dy)>abs(dx) if so need to swap xy
                             	; num_b = abs(x), num_b+1 = abs(dy)
d7d2 : 38               [ 2] 	sec
d7d3 : a590             [ 3] 	lda grl_x1
d7d5 : e58e             [ 3] 	sbc grl_x0
d7d7 : b003             [ 3] 	bcs gr_line_skip_dx_neg
d7d9 : 49ff             [ 2] 	eor #0xff
d7db : 1a               [ 2] 	inc a
d7dc :                       gr_line_skip_dx_neg
d7dc : 8593             [ 3] 	sta grl_dx
d7de : 38               [ 2] 	sec
d7df : a591             [ 3] 	lda grl_y1
d7e1 : e58f             [ 3] 	sbc grl_y0
d7e3 : b003             [ 3] 	bcs gr_line_skip_dy_neg
d7e5 : 49ff             [ 2] 	eor #0xff
d7e7 : 1a               [ 2] 	inc a
d7e8 :                       gr_line_skip_dy_neg
d7e8 : 8594             [ 3] 	sta grl_dy
d7ea : c593             [ 3] 	cmp grl_dx
d7ec : 901a             [ 4] 	bcc gr_line_skip_xy_swap
                             	; swap xy axes and also dx and dy
d7ee : a58e             [ 3] 	lda grl_x0					; swap x0 and y0
d7f0 : a68f             [ 3] 	ldx grl_y0
d7f2 : 858f             [ 3] 	sta grl_y0
d7f4 : 868e             [ 3] 	stx grl_x0
d7f6 : a590             [ 3] 	lda grl_x1					; swap x1 and y1
d7f8 : a691             [ 3] 	ldx grl_y1
d7fa : 8591             [ 3] 	sta grl_y1
d7fc : 8690             [ 3] 	stx grl_x1
d7fe : a593             [ 3] 	lda grl_dx					; swap dy and dx
d800 : a694             [ 3] 	ldx grl_dy
d802 : 8594             [ 3] 	sta grl_dy
d804 : 8693             [ 3] 	stx grl_dx
d806 : e695             [ 5] 	inc grl_xyyx				; set flag to Not Z to know abou
                             	
d808 :                       gr_line_skip_xy_swap	
                             	; assume going from left to right
d808 : a901             [ 2] 	lda #1
d80a : 859c             [ 3] 	sta grl_inx
d80c : a58e             [ 3] 	lda grl_x0
d80e : c590             [ 3] 	cmp grl_x1
d810 : 9004             [ 3] 	bcc gr_line_skip_x_swap
d812 : a9ff             [ 2] 	lda #0xff					; make x increment negative
d814 : 859c             [ 3] 	sta grl_inx
                             	
d816 :                       gr_line_skip_x_swap
AS65 Assembler for R6502 [1.42].                                     Page  101
-------------------------------- bank\bank0.s --------------------------------

                             	; assume going from top to bottom
d816 : a901             [ 2] 	lda #1
d818 : 859d             [ 3] 	sta grl_iny
d81a : a58f             [ 3] 	lda grl_y0
d81c : c591             [ 3] 	cmp grl_y1
d81e : 9004             [ 3] 	bcc gr_line_skip_y_up
d820 : a9ff             [ 2] 	lda #0xff					; make y increment negative
d822 : 859d             [ 3] 	sta grl_iny
                             
d824 :                       gr_line_skip_y_up
d824 : a593             [ 3] 	lda grl_dx
d826 : 0a               [ 2] 	asl a
d827 : 8596             [ 3] 	sta grl_2dx					; 2*dx (word)
d829 : 6497             [ 3] 	stz grl_2dx+1
d82b : 2697             [ 5] 	rol grl_2dx+1
                             
d82d : a594             [ 3] 	lda grl_dy
d82f : 0a               [ 2] 	asl a
d830 : 8598             [ 3] 	sta grl_2dy					; 2*dy (word)
d832 : 6499             [ 3] 	stz grl_2dy+1
d834 : 2699             [ 5] 	rol grl_2dy+1
                             	
                             ;    p=2*dy-dx;					; p (word)
d836 : 38               [ 2] 	sec
d837 : a598             [ 3] 	lda grl_2dy
d839 : e593             [ 3] 	sbc grl_dx
d83b : 859e             [ 3] 	sta grl_p
d83d : a599             [ 3] 	lda grl_2dy+1
d83f : e900             [ 2] 	sbc #0
d841 : 859f             [ 3] 	sta grl_p+1
                             	
                             ;   2*(dy-dx)					; num_tmp+2 = 2*(dy-dx)
d843 : 38               [ 2] 	sec
d844 : a598             [ 3] 	lda grl_2dy
d846 : e596             [ 3] 	sbc grl_2dx
d848 : 859a             [ 3] 	sta grl_2dxy
d84a : a599             [ 3] 	lda grl_2dy+1
d84c : e597             [ 3] 	sbc grl_2dx+1
d84e : 859b             [ 3] 	sta grl_2dxy+1
                             
d850 :                       gr_line_pixel
                             	; plot the current pixel position
d850 : a68e             [ 3] 	ldx grl_x0
d852 : a48f             [ 3] 	ldy grl_y0
d854 : a595             [ 3] 	lda grl_xyyx				; is xy swapped?
d856 : f004             [ 3] 	beq gr_skip_xy_swap2
d858 : a68f             [ 3] 	ldx grl_y0
d85a : a48e             [ 3] 	ldy grl_x0	
d85c :                       gr_skip_xy_swap2
d85c : 20c5d5           [ 6] 	jsr gr_point
                             	
d85f : a58e             [ 3] 	lda grl_x0					; Check if done
d861 : c590             [ 3] 	cmp grl_x1
d863 : f030             [ 3] 	beq gr_line_done
                             
                             	; check sign of p
d865 : a59f             [ 3] 	lda grl_p+1
d867 : 3016             [ 3] 	bmi gr_line_neg_p
                             
                             	; if p >=0
                             	
                             	; y=y+increment
AS65 Assembler for R6502 [1.42].                                     Page  102
-------------------------------- bank\bank0.s --------------------------------

d869 : 18               [ 2] 	clc
d86a : a58f             [ 3] 	lda grl_y0
d86c : 659d             [ 3] 	adc grl_iny
d86e : 858f             [ 3] 	sta grl_y0
                             
                             	; p=p+2*dy-2*dx
                             	_addZPWord grl_p,grl_2dxy
                             
d87d : 800d             [ 3] 	bra gr_line_incx
                             
d87f :                       gr_line_neg_p
                             	; if p < 0
                             	; p=p+2*dy
                             	_addZPWord grl_p,grl_2dy
                             
                             	
d88c :                       gr_line_incx
d88c : 18               [ 2] 	clc
d88d : a58e             [ 3] 	lda grl_x0
d88f : 659c             [ 3] 	adc grl_inx
d891 : 858e             [ 3] 	sta grl_x0
d893 : 80bb             [ 3] 	bra gr_line_pixel
d895 :                       gr_line_done
d895 : 60               [ 6] 	rts
                             	
                             
                             ;    while(x<x1)
                             ;    {
                             ;        if(p>=0)
                             ;        {
                             ;            putpixel(x,y,7);
                             ;            y=y+1;
                             ;            p=p+2*dy-2*dx;
                             ;        }
                             ;        else
                             ;        {
                             ;            putpixel(x,y,7);
                             ;            p=p+2*dy;
                             ;        }
                             ;        x=x+1;
                             ;    }
                             
                             
                             ;****************************************
                             ;* gr_scroll_up
                             ;* Scroll screen one line up
                             ;****************************************
d896 :                       gr_scroll_up
d896 : e60f             [ 5] 	inc vdp_curoff
                             	
                             	; Get VDP Address of line + 1 line (source addr)
d898 : 18               [ 2] 	clc
d899 : a51f             [ 3] 	lda gr_scrngeom+gr_screen_start
d89b : 6523             [ 3] 	adc gr_scrngeom+gr_screen_w
d89d : 8539             [ 3] 	sta tmp_alo
d89f : a520             [ 3] 	lda gr_scrngeom+gr_screen_start+1
d8a1 : 6900             [ 2] 	adc #0
d8a3 : 853a             [ 3] 	sta tmp_ahi
                             	
                             	; Get destinaton address = first line of screen
d8a5 : a51f             [ 3] 	lda gr_scrngeom+gr_screen_start
d8a7 : 853b             [ 3] 	sta tmp_blo
AS65 Assembler for R6502 [1.42].                                     Page  103
-------------------------------- bank\bank0.s --------------------------------

d8a9 : a520             [ 3] 	lda gr_scrngeom+gr_screen_start+1
d8ab : 853c             [ 3] 	sta tmp_bhi
                             	
d8ad : a424             [ 3] 	ldy gr_scrngeom+gr_screen_h
d8af : 88               [ 2] 	dey
                             	
d8b0 : 78               [ 2] 	sei						; Stop IRQ as it messes with VDP
                             	; Only use vdp primitives inside sei,cli
                             
                             	; Restore what was underneath cursor
d8b1 : a628             [ 3] 	ldx gr_scrngeom+gr_cur_ptr
d8b3 : a529             [ 3] 	lda gr_scrngeom+gr_cur_ptr+1
d8b5 : 20e3c4           [ 6] 	jsr vdp_wr_addr
d8b8 : a511             [ 3] 	lda vdp_curval
d8ba : 2009c5           [ 6] 	jsr vdp_wr_vram
                             
d8bd :                       gr_scroll_cpy_ln
                             	; Set VDP with source address to read
d8bd : a639             [ 3] 	ldx tmp_alo
d8bf : a53a             [ 3] 	lda tmp_ahi
d8c1 : 20fac4           [ 6] 	jsr vdp_rd_addr
                             
                             	; Read in a line worth of screen
d8c4 : a623             [ 3] 	ldx gr_scrngeom+gr_screen_w
d8c6 :                       gr_scroll_read_ln
d8c6 : 2004c5           [ 6] 	jsr vdp_rd_vram
d8c9 : 9dbb0b           [ 5] 	sta scratch,x
d8cc : ca               [ 2] 	dex
d8cd : d0f7             [ 3] 	bne gr_scroll_read_ln
                             
                             	; Set VDP with destinaton to write
d8cf : a63b             [ 3] 	ldx tmp_blo
d8d1 : a53c             [ 3] 	lda tmp_bhi
d8d3 : 20e3c4           [ 6] 	jsr vdp_wr_addr
                             	
                             	; Write out a line worth of screen
d8d6 : a623             [ 3] 	ldx gr_scrngeom+gr_screen_w
d8d8 :                       gr_scroll_write_ln
d8d8 : bdbb0b           [ 4] 	lda scratch,x
d8db : 2009c5           [ 6] 	jsr vdp_wr_vram
d8de : ca               [ 2] 	dex
d8df : d0f7             [ 3] 	bne gr_scroll_write_ln
                             
                             	; Update source address
d8e1 : 18               [ 2] 	clc
d8e2 : a539             [ 3] 	lda tmp_alo
d8e4 : 6523             [ 3] 	adc gr_scrngeom+gr_screen_w
d8e6 : 8539             [ 3] 	sta tmp_alo
d8e8 : a53a             [ 3] 	lda tmp_ahi
d8ea : 6900             [ 2] 	adc #0
d8ec : 853a             [ 3] 	sta tmp_ahi
                             	; Update destinaton address
d8ee : 18               [ 2] 	clc
d8ef : a53b             [ 3] 	lda tmp_blo
d8f1 : 6523             [ 3] 	adc gr_scrngeom+gr_screen_w
d8f3 : 853b             [ 3] 	sta tmp_blo
d8f5 : a53c             [ 3] 	lda tmp_bhi
d8f7 : 6900             [ 2] 	adc #0
d8f9 : 853c             [ 3] 	sta tmp_bhi
                             
                             	; One line complete
d8fb : 88               [ 2] 	dey
AS65 Assembler for R6502 [1.42].                                     Page  104
-------------------------------- bank\bank0.s --------------------------------

d8fc : d0bf             [ 3] 	bne gr_scroll_cpy_ln
                             	
                             	; VDP is pointing at last line
                             	; Needs to be filled with blank
d8fe : a512             [ 3] 	lda vdp_blank
d900 : 8511             [ 3] 	sta vdp_curval			; Also this is the cursor value
d902 : a623             [ 3] 	ldx gr_scrngeom+gr_screen_w
d904 :                       gr_scroll_erase_ln
d904 : 2009c5           [ 6] 	jsr vdp_wr_vram
d907 : ca               [ 2] 	dex
d908 : d0fa             [ 3] 	bne gr_scroll_erase_ln
                             
d90a : 58               [ 2] 	cli			; Enable IRQ
                             
d90b : c60f             [ 5] 	dec vdp_curoff
                             
d90d : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* gr_cur_right
                             ;* Advance cursor position
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
d90e :                       gr_cur_right
                             	_pushAXY
                             
                             	; Load cursor x,y position
d911 : a626             [ 3] 	ldx gr_scrngeom+gr_cur_x
d913 : a427             [ 3] 	ldy gr_scrngeom+gr_cur_y
                             
                             	; Move cursor right
d915 : e8               [ 2] 	inx
                             	; Check if reached past edge of line
d916 : e423             [ 3] 	cpx gr_scrngeom+gr_screen_w
d918 : d00f             [ 3] 	bne gr_adv_skip_nl
                             	; If got here then wrap to next line
d91a : a200             [ 2] 	ldx #0
d91c : c8               [ 2] 	iny
d91d : c424             [ 3] 	cpy gr_scrngeom+gr_screen_h
d91f : d008             [ 3] 	bne gr_adv_skip_nl
                             	; If got here then screen needs to scroll
d921 : 88               [ 2] 	dey					; First put y back in bound
d922 : da               [ 3] 	phx
d923 : 5a               [ 3] 	phy
d924 : 2096d8           [ 6] 	jsr gr_scroll_up
d927 : 7a               [ 4] 	ply
d928 : fa               [ 4] 	plx
d929 :                       gr_adv_skip_nl
d929 : 20e9d4           [ 6] 	jsr gr_set_cur
                             	_pullAXY
                             
d92f : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* gr_cur_left
                             ;* Advance cursor left
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
AS65 Assembler for R6502 [1.42].                                     Page  105
-------------------------------- bank\bank0.s --------------------------------

d930 :                       gr_cur_left
                             	_pushAXY
                             
                             	; Load cursor x,y position, load X last to check
d933 : a427             [ 3] 	ldy gr_scrngeom+gr_cur_y
d935 : a626             [ 3] 	ldx gr_scrngeom+gr_cur_x
                             	
                             	; Decrement screen pointer
                             	; Move cursor left
d937 : d007             [ 3] 	bne gr_cur_skip_at_left		; If already at the lef
d939 : c000             [ 2] 	cpy #0						; If already at the top left
d93b : f007             [ 3] 	beq gr_cur_skip_at_tl
d93d : 88               [ 2] 	dey
d93e : a623             [ 3] 	ldx gr_scrngeom+gr_screen_w
d940 :                       gr_cur_skip_at_left
d940 : ca               [ 2] 	dex
d941 : 20e9d4           [ 6] 	jsr gr_set_cur
                             
d944 :                       gr_cur_skip_at_tl	
                             	_pullAXY
                             
d947 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* gr_cur_up
                             ;* Advance cursor up
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
d948 :                       gr_cur_up
                             	_pushAXY
                             
                             	; Load cursor x,y position, load Y last to check
d94b : a626             [ 3] 	ldx gr_scrngeom+gr_cur_x
d94d : a427             [ 3] 	ldy gr_scrngeom+gr_cur_y
                             	
d94f : f004             [ 3] 	beq gr_cur_skip_at_top	; If already at the top, 
d951 : 88               [ 2] 	dey
d952 : 20e9d4           [ 6] 	jsr gr_set_cur
                             	
d955 :                       gr_cur_skip_at_top	
                             	_pullAXY
                             
d958 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* gr_cur_down
                             ;* Advance cursor down
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
d959 :                       gr_cur_down
                             	_pushAXY
                             
                             	; Load cursor x,y position
d95c : a626             [ 3] 	ldx gr_scrngeom+gr_cur_x
d95e : a427             [ 3] 	ldy gr_scrngeom+gr_cur_y
d960 : c8               [ 2] 	iny
d961 : c424             [ 3] 	cpy gr_scrngeom+gr_screen_h			; If already at  b
d963 : f003             [ 3] 	beq gr_cur_skip_at_bot				; then don't do anythi
AS65 Assembler for R6502 [1.42].                                     Page  106
-------------------------------- bank\bank0.s --------------------------------

                             	
d965 : 20e9d4           [ 6] 	jsr gr_set_cur
                             
d968 :                       gr_cur_skip_at_bot
                             	_pullAXY
                             
d96b : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* gr_new_ln
                             ;* Carry out a new line
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
d96c :                       gr_new_ln
                             	_pushAXY
                             
                             	; X pos is zero, Y needs to increment
d96f : a200             [ 2] 	ldx #0
d971 : a427             [ 3] 	ldy gr_scrngeom+gr_cur_y
d973 : c8               [ 2] 	iny
d974 : c424             [ 3] 	cpy gr_scrngeom+gr_screen_h
d976 : d008             [ 3] 	bne gr_nl_skip_nl
                             	; If got here then screen needs to scroll
d978 : 88               [ 2] 	dey
d979 : da               [ 3] 	phx
d97a : 5a               [ 3] 	phy
d97b : 2096d8           [ 6] 	jsr gr_scroll_up
d97e : 7a               [ 4] 	ply
d97f : fa               [ 4] 	plx
d980 :                       gr_nl_skip_nl
d980 : 20e9d4           [ 6] 	jsr gr_set_cur
                             	_pullAXY
                             
d986 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* gr_del
                             ;* Action del
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
d987 :                       gr_del
                             	_pushAXY
                             
d98a : 2030d9           [ 6] 	jsr gr_cur_left
d98d : a920             [ 2] 	lda #' '							; Put a space
d98f : 20d3d4           [ 6] 	jsr gr_put
                             	_pullAXY
                             
d995 : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* gr_get_key
                             ;* Waits for a key press, C=1 synchronous
                             ;* A = Key code
                             ;****************************************
d996 :                       gr_get_key
AS65 Assembler for R6502 [1.42].                                     Page  107
-------------------------------- bank\bank0.s --------------------------------

d996 : 20a3cb           [ 6] 	jsr kb_get_key
d999 : b007             [ 3] 	bcs gr_key_no_key
d99b : c906             [ 2] 	cmp #UTF_ACK						; Copy key pressed?
d99d : d002             [ 3] 	bne gr_not_copy
d99f : a511             [ 3] 	lda vdp_curval						; If yes the get char under 
d9a1 :                       gr_not_copy
d9a1 : 18               [ 2] 	clc
d9a2 :                       gr_key_no_key
d9a2 : 60               [ 6] 	rts	
                             	
                             ;****************************************
                             ;* gr_put_byte
                             ;* Put a byte out
                             ;* Input : A = Byte to put
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
d9a3 :                       gr_put_byte
d9a3 : c97f             [ 2] 	cmp #UTF_DEL			; Del key
d9a5 : f004             [ 3] 	beq gr_process_special
d9a7 : c920             [ 2] 	cmp #32					; Special char?
d9a9 : b032             [ 3] 	bcs gr_pb_notspecial	; >=32 == carry clear
                             
d9ab :                       gr_process_special
d9ab : c90d             [ 2] 	cmp #UTF_CR				; New line?
d9ad : d003             [ 3] 	bne gr_skip_new_ln
d9af : 4c6cd9           [ 3] 	jmp gr_new_ln
d9b2 :                       gr_skip_new_ln
d9b2 : c97f             [ 2] 	cmp #UTF_DEL			; Delete?
d9b4 : d003             [ 3] 	bne gr_skip_del
d9b6 : 4c87d9           [ 3] 	jmp gr_del
d9b9 :                       gr_skip_del
d9b9 : c908             [ 2] 	cmp #CRSR_LEFT
d9bb : d003             [ 3] 	bne gr_skip_left
d9bd : 4c30d9           [ 3] 	jmp gr_cur_left
d9c0 :                       gr_skip_left
d9c0 : c909             [ 2] 	cmp #CRSR_RIGHT
d9c2 : d003             [ 3] 	bne gr_skip_right
d9c4 : 4c0ed9           [ 3] 	jmp gr_cur_right
d9c7 :                       gr_skip_right
d9c7 : c90b             [ 2] 	cmp #CRSR_UP
d9c9 : d003             [ 3] 	bne gr_skip_up
d9cb : 4c48d9           [ 3] 	jmp gr_cur_up
d9ce :                       gr_skip_up
d9ce : c90a             [ 2] 	cmp #CRSR_DOWN
d9d0 : d003             [ 3] 	bne gr_skip_down
d9d2 : 4c59d9           [ 3] 	jmp gr_cur_down
d9d5 :                       gr_skip_down
d9d5 : c90c             [ 2] 	cmp #UTF_FF
d9d7 : d003             [ 3] 	bne gr_skip_cls
d9d9 : 4c5fd4           [ 3] 	jmp gr_cls
d9dc :                       gr_skip_cls
d9dc : 60               [ 6] 	rts
                             
                             ;	Normal caracter processing here.
d9dd :                       gr_pb_notspecial
                             	_pushAXY
                             
                             	
                             	; Place in current position and move right
d9e0 : 20d3d4           [ 6] 	jsr gr_put
d9e3 : 200ed9           [ 6] 	jsr gr_cur_right
AS65 Assembler for R6502 [1.42].                                     Page  108
-------------------------------- bank\bank0.s --------------------------------

                             
                             	_pullAXY
                             
                             	
d9e9 : 60               [ 6] 	rts
                             
                             ;* These tables are to speed up calculating the 
                             ;* offset for plot commands, rather than using
                             ;* a series of left shifts and additions.
                             ;* Not sure if it is worth the 96 bytes :-O
d9ea :                       gr_offset_40lo
d9ea : 00285078              	db lo(0*40), lo(1*40), lo(2*40), lo(3*40)
d9ee : a0c8f018              	db lo(4*40), lo(5*40), lo(6*40), lo(7*40)
d9f2 : 406890b8              	db lo(8*40), lo(9*40), lo(10*40), lo(11*40)
d9f6 : e0083058              	db lo(12*40), lo(13*40), lo(14*40), lo(15*40)
d9fa : 80a8d0f8              	db lo(16*40), lo(17*40), lo(18*40), lo(19*40)
d9fe : 20487098              	db lo(20*40), lo(21*40), lo(22*40), lo(23*40)
da02 :                       gr_offset_40hi
da02 : 00000000              	db hi(0*40), hi(1*40), hi(2*40), hi(3*40)
da06 : 00000001              	db hi(4*40), hi(5*40), hi(6*40), hi(7*40)
da0a : 01010101              	db hi(8*40), hi(9*40), hi(10*40), hi(11*40)
da0e : 01020202              	db hi(12*40), hi(13*40), hi(14*40), hi(15*40)
da12 : 02020202              	db hi(16*40), hi(17*40), hi(18*40), hi(19*40)
da16 : 03030303              	db hi(20*40), hi(21*40), hi(22*40), hi(23*40)
da1a :                       gr_offset_32lo
da1a : 00204060              	db lo(0*32), lo(1*32), lo(2*32), lo(3*32)
da1e : 80a0c0e0              	db lo(4*32), lo(5*32), lo(6*32), lo(7*32)
da22 : 00204060              	db lo(8*32), lo(9*32), lo(10*32), lo(11*32)
da26 : 80a0c0e0              	db lo(12*32), lo(13*32), lo(14*32), lo(15*32)
da2a : 00204060              	db lo(16*32), lo(17*32), lo(18*32), lo(19*32)
da2e : 80a0c0e0              	db lo(20*32), lo(21*32), lo(22*32), lo(23*32)
da32 :                       gr_offset_32hi
da32 : 00000000              	db hi(0*32), hi(1*32), hi(2*32), hi(3*32)
da36 : 00000000              	db hi(4*32), hi(5*32), hi(6*32), hi(7*32)
da3a : 01010101              	db hi(8*32), hi(9*32), hi(10*32), hi(11*32)
da3e : 01010101              	db hi(12*32), hi(13*32), hi(14*32), hi(15*32)
da42 : 02020202              	db hi(16*32), hi(17*32), hi(18*32), hi(19*32)
da46 : 02020202              	db hi(20*32), hi(21*32), hi(22*32), hi(23*32)
                             	
da4a :                       mod_sz_graph_e
                             
                             
                             	; End of Code
da4a :                       _code_end
                             
No errors in pass 2.
Wrote binary from address $c000 through $ffff.
Total size 16384 bytes.
