AS65 Assembler for R6502 [1.42].                                     Page    1
-------------------------------- bank\bank1.s --------------------------------

12701 lines read, no errors in pass 1.
                             	include "kernel\kernel.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  KERNEL.S
                             ;*	The 'kernel' routine includes code and data wh
                             ;* 	be in every ROM bank.  In the auto-generated 
                             ;*  files, the kernel is added before the bank sp
                             ;*	code.  See bank0.s as an example.
                             ;*
                             ;************************************************
                             
                             ;* Include all definition and code files in the r
                             	include "inc\includes.i"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  INCLUDES.S
                             ;*  Main include file for key definitions and mac
                             ;*  Many of the settings here are exremely machin
                             ;*  Defines : IO block addresses, VIA port usage,
                             ;*  settings, useful macros, sound chip registers
                             ;*  VDP registers, ACIA registers.
                             ;*
                             ;************************************************
                             
                             ;* The IO block is at 0x04000 and decodes up to
                             ;* eight IO addresses, at 0x0080 intervals
                             ;* All eight are not used at the present time:
                             ;* - 0 : VIA 1 (Keyboard)
                             ;* - 1 : VIA 2 (Sound and SD card interface)
                             ;* - 2 : VDP (Video)
                             ;* - 3 : ACIA (Serial)
0400 =                       IO_0		= 0x0400
0480 =                       IO_1		= 0x0480
0500 =                       IO_2		= 0x0500
0580 =                       IO_3		= 0x0580
0600 =                       IO_4		= 0x0600
0680 =                       IO_5		= 0x0680
0700 =                       IO_6		= 0x0700
0780 =                       IO_7		= 0x0780
                             
                             ;* VDP is accessed through IO_2
0500 =                       VDP_MODE0		= IO_2
0501 =                       VDP_MODE1		= IO_2+1
0501 =                       VDP_STATUS		= IO_2+1
0501 =                       VDP_ADDR		= IO_2+1
0500 =                       VDP_VRAM		= IO_2
0001 =                       VDP_SHORTDELAY	= 1
0002 =                       VDP_LONGDELAY 	= 2
0010 =                       VDP_FLASH		= 0x10				;* Must be a power of 2 *
AS65 Assembler for R6502 [1.42].                                     Page    2
-------------------------------- bank\bank1.s --------------------------------

                             
                             ;* This structure defines the key information
                             ;* kept about the VDP current mode
0000 =                       	struct vdp_addr_struct
0000 =                       	dw vdp_addr_nme				;* Address of name table
0002 =                       	dw vdp_addr_col				;* Address of colour table
0004 =                       	dw vdp_addr_pat				;* Address of pattern table
0006 =                       	dw vdp_addr_spa				;* Address of sprite pattern 
0008 =                       	dw vdp_addr_spp				;* Address of sprite position
000a =                       	db vdp_bord_col				;* Value of border colour
                             	end struct
                             
                             ;* Standard definitions of 6522 registers
                             ;* As found in the datasheets
0000 =                       PRB			= 0x00
0001 =                       PRA			= 0x01
0002 =                       DDRB		= 0x02
0003 =                       DDRA		= 0x03
0004 =                       T1CL		= 0x04
0005 =                       T1CH		= 0x05
0006 =                       T1LL		= 0x06
0007 =                       T1LH		= 0x07
0008 =                       T2CL		= 0x08
0009 =                       T2CH		= 0x09
000a =                       SR			= 0x0a
000b =                       ACR			= 0x0b
000c =                       PCR			= 0x0c
000d =                       IFR			= 0x0d
000e =                       IER			= 0x0e
000f =                       PRAH		= 0x0f
                             
0001 =                       IFR_CA2		= 0x01
0002 =                       IFR_CA1		= 0x02
                             
                             ;* AY-3-8910 definitions
                             ;* The sound chip is accessed through VIA 2
0481 =                       SND_ADBUS	= IO_1+PRA
0480 =                       SND_MODE	= IO_1+PRB
                             
0040 =                       SND_SELREAD			= 0x40
0002 =                       SND_SELWRITE		= 0x02
0042 =                       SND_SELSETADDR		= (SND_SELREAD|SND_SELWRITE)
00bd =                       SND_DESELECT_MASK	= (0xff-SND_SELREAD-SND_SELWRIT
                             
0000 =                       SND_REG_CHAPL	= 0x00
0001 =                       SND_REG_CHAPH	= 0x01
0002 =                       SND_REG_CHBPL	= 0x02
0003 =                       SND_REG_CHBPH	= 0x03
0004 =                       SND_REG_CHCPL	= 0x04
0005 =                       SND_REG_CHCPH	= 0x05
0006 =                       SND_REG_CHNP	= 0x06
0007 =                       SND_REG_CTL		= 0x07
0008 =                       SND_REG_CHAVOL	= 0x08
0009 =                       SND_REG_CHBVOL	= 0x09
000a =                       SND_REG_CHBVOL	= 0x0a
000b =                       SND_REG_ENVPL	= 0x0b
000c =                       SND_REG_ENVPH	= 0x0c
000d =                       SND_REG_ENVCYC	= 0x0d
                             
000e =                       SND_REG_IOA	= 0x0e
000f =                       SND_REG_IOB	= 0x0f
                             
AS65 Assembler for R6502 [1.42].                                     Page    3
-------------------------------- bank\bank1.s --------------------------------

                             ;* 6551 ACIA definitions
                             ;* As found in the datasheets
0580 =                       SER_DATA	= (IO_3+0)
0581 =                       SER_STATUS	= (IO_3+1)
0581 =                       SER_RESET	= (IO_3+1)
0582 =                       SER_CMD		= (IO_3+2)
0583 =                       SER_CTL		= (IO_3+3)
                             
0080 =                       SER_IRQ		= 0x80
0040 =                       SER_DSRB	= 0x40
0020 =                       SER_DCDB	= 0x20
0010 =                       SER_TDRE	= 0x10
0008 =                       SER_RDRF	= 0x08
0004 =                       SER_OVRN	= 0x04
0002 =                       SER_FE		= 0x02
0001 =                       SER_PE		= 0x01
0080 =                       SER_SBN		= 0x80
0040 =                       SER_WL1		= 0x40
0020 =                       SER_WL0		= 0x20
0060 =                       SER_WL		= (SER_WL1|SER_WL0)
0010 =                       SER_RCS		= 0x10
0008 =                       SER_SBR3	= 0x08
0004 =                       SER_SBR2	= 0x04
0002 =                       SER_SBR1	= 0x02
0001 =                       SER_SBR0	= 0x01
000f =                       SER_SBR		= (SER_SBR3|SER_SBR2|SER_SBR1|SER_SBR0)
000f =                       SER_19200B	= (SER_SBR3|SER_SBR2|SER_SBR1|SER_SBR0
000e =                       SER_9600B	= (SER_SBR3|SER_SBR2|SER_SBR1)
0080 =                       SER_PMC1	= 0x80
0040 =                       SER_PMC0	= 0x40
00c0 =                       SER_PMC		= (SER_PMC1|SER_PMC0)
0020 =                       SER_PME		= 0x20
0010 =                       SER_REM		= 0x10
0008 =                       SER_TIC1	= 0x08
0004 =                       SER_TIC0	= 0x04
000c =                       SER_TIC		= (SER_TIC1|SER_TIC0)
0002 =                       SER_IRD		= 0x02
0001 =                       SER_DTR		= 0x01
                             
                             ;* BBC keyboard definitions
                             ;* The keyboard is accessed through VIA 1
                             ;* Port A - all output
0001 =                       KB_ROWA		= 0x01
0002 =                       KB_ROWB		= 0x02
0004 =                       KB_ROWC		= 0x04
0008 =                       KB_COLA		= 0x08
0010 =                       KB_COLB		= 0x10
0020 =                       KB_COLC		= 0x20
0040 =                       KB_COLD		= 0x40
0080 =                       KB_EN		= 0x80
                             ;* Port B
0001 =                       KB_W		= 0x01			; Input - BBC keyboard hardware se
0002 =                       KB_LED0		= 0x02			; Output - led 0
0004 =                       KB_LED1		= 0x04			; Output - led 1
0008 =                       KB_LED2		= 0x08			; Output - led 2
0001 =                       KB_CAPSLK	= 0x01			; Id of Caps Lock - maps to Le
0002 =                       KB_SHIFTLK	= 0x02			; Id of Shift lock - maps to 
                             
0005 =                       KB_REP_TIM	= 5				; Number of VB periods for the 
001e =                       KB_REP_DEL	= 30			; Number of VB periods before r
0003 =                       KB_DEBOUNCE	= 3				; Number of VB periods before 
                             
AS65 Assembler for R6502 [1.42].                                     Page    4
-------------------------------- bank\bank1.s --------------------------------

0003 =                       UTF_ETX		= 0x03			; Break character
0007 =                       UTF_BEL		= 0x07
0008 =                       CRSR_LEFT	= 0x08
0009 =                       CRSR_RIGHT	= 0x09
000a =                       CRSR_DOWN	= 0x0a
000b =                       CRSR_UP		= 0x0b
0006 =                       UTF_ACK		= 0x06			; Used for the copy key in this
000c =                       UTF_FF		= 0x0c
000d =                       UTF_CR		= 0x0d
001a =                       UTF_BRK		= 0x1a			; Debug - drop in to monitor
007f =                       UTF_DEL		= 0x7f
0020 =                       UTF_SPECIAL = 0x20
                             
                             ;* SD Card interface definitions
                             ;* The card is accessed through port B of VIA 2
0001 =                       SD_CLK		= 0x01			; Clock output to SD card
0004 =                       SD_CD		= 0x04			; Card detect input
0008 =                       SD_CS		= 0x08			; Card select output
0010 =                       SD_DI		= 0x10			; Data output from VIA to SD Card
0080 =                       SD_DO		= 0x80			; Data input to VIA from SD card
                             
0010 =                       SD_MOSI		= SD_DI
0080 =                       SD_MISO		= SD_DO
0480 =                       SD_REG		= IO_1+PRB
                             
0000 =                       CMD_ERR_NOERROR			= 0x00
0001 =                       CMD_ERR_NOTFOUND		= 0x01
0002 =                       CMD_ERR_PARM			= 0x02
0003 =                       CMD_ERR_VAL				= 0x03
                             
                             ;* Memory management definitions
                             ;* Y1,Y0 = ROM bank selection CIA1 PORTB
0080 =                       MM_Y1					= 0x80
0040 =                       MM_Y0					= 0x40
                             ;* X1,X0 = RAM bank selection CIA1 PORTB
0020 =                       MM_X1					= 0x20
0010 =                       MM_X0					= 0x10
                             ;* DIS = ROM disable *CIA2* PORTB
0020 =                       MM_DIS					= 0x20
                             
                             ;* Number formats for conversion routines
0000 =                       NUM_ANY		= 0x00
0001 =                       NUM_DEC		= 0x01
0002 =                       NUM_HEX		= 0x02
0003 =                       NUM_BIN		= 0x03
                             
                             	
                             ;* SD Card Master Boot Record (MBR) definitions
                             ;* The MBR contains the essential information
                             ;* needed to access the data on the card
                             ;* MBR is usually sector 0, but not always
                             ;* however the card I am using does work ok.
0000 =                       MBR_Code				=	0x0000
0003 =                       MBR_OEMName				=	0x0003
000b =                       MBR_BytesPerSect		=	0x000b
000d =                       MBR_SectPerClust		=	0x000d
000e =                       MBR_ResvSect			=	0x000e
0010 =                       MBR_FATCopies			=	0x0010
0011 =                       MBR_RootEntries			=	0x0011
0013 =                       MBR_SmlSect				=	0x0013
0015 =                       MBR_MediaDesc			=	0x0015
0016 =                       MBR_SectPerFAT			=	0x0016
AS65 Assembler for R6502 [1.42].                                     Page    5
-------------------------------- bank\bank1.s --------------------------------

0018 =                       MBR_SectPerTrk			=	0x0018
001a =                       MBR_NumHeads			=	0x001a
001c =                       MBR_NumHidSect			=	0x001c
0020 =                       MBR_NumSect				=	0x0020
0024 =                       MBR_DrvNum				=	0x0024
0026 =                       MBR_ExtSig				=	0x0026
0027 =                       MBR_SerNo				=	0x0027
002b =                       MBR_VolName				=	0x002b
0036 =                       MBR_FATName				=	0x0036
003e =                       MBR_ExeCode				=	0x003e
01c6 =                       MBR_BootPart1			=	(0x01be+0x08)
01fe =                       MBR_ExeMark				=	0x01fe
                             
                             ;* FAT16 definitions - these are offsets
                             ;* in to a FAT table entry which is
                             ;* 32 bytes in length.
0000 =                       FAT_Name				= 	0x00
0008 =                       FAT_Ext					=	0x08
000b =                       FAT_Attr				=	0x0b
000c =                       FAT_Resv				=	0x0c
000d =                       FAT_Createms			=	0x0d
000e =                       FAT_CreateTime			=	0x0e
0010 =                       FAT_CreateDate			=	0x10
0012 =                       FAT_AccessDate			=	0x12
0014 =                       FAT_EAIndex				=	0x14
0016 =                       FAT_ModTime				=	0x16
0018 =                       FAT_ModDate				=	0x18
001a =                       FAT_FirstClust			=	0x1a
001c =                       FAT_FileSize			=	0x1c
                             
                             ;* The FileHandle stucture is key to
                             ;* accessing the file system
0000 =                       	struct FileHandle
0000 =                       	ds FH_Name, 13			; 8 name, 3 extension, 1 separa
000d =                       	ds FH_Size, 4
0011 =                       	ds FH_Attr, 1
0012 =                       	ds FH_CurrClust, 2
0014 =                       	ds FH_SectCounter, 1
0015 =                       	ds FH_CurrSec, 4
0019 =                        	ds FH_Pointer, 4
001d =                       	ds FH_DirSect, 4
0021 =                       	ds FH_DirOffset, 2
0023 =                       	ds FH_FirstClust, 2
0025 =                       	ds FH_LastClust, 2
0027 =                       	ds FH_FileMode, 1
                             	end struct
                             
0001 =                       FS_BLK_FLG_LOAD		 	= 	0x01		; On next byte, load 
0002 =                       FS_BLK_FLG_FLUSH		=	0x02		; Block has changed, ne
                             	
0001 =                       FS_ERR_EOF				=	0x01
                             
                             
                             ;* USEFUL MACROS HERE
                             
                             ;* Software break to throw errors
                             ;* use like this : SWBRK XX
                             ;* Where XX is the error code
                             SWBRK macro sig
                             	brk
                             	db sig
                             	endm
AS65 Assembler for R6502 [1.42].                                     Page    6
-------------------------------- bank\bank1.s --------------------------------

                             
                             _pushAXY macro
                             	pha
                             	phx
                             	phy
                             	endm
                             
                             _pullAXY macro
                             	ply
                             	plx
                             	pla
                             	endm
                             
                             _println macro msg
                             	_pushAXY
                             	ldx #lo(msg)
                             	lda #hi(msg)
                             	jsr io_print_line
                             	_pullAXY
                             	endm
                             
                             _printmsgA macro msg
                             	phx
                             	phy
                             	pha
                             	ldx #lo(msg)
                             	lda #hi(msg)
                             	jsr io_print_line
                             	pla
                             	pha
                             	jsr str_a_to_x
                             	jsr _put_byte
                             	txa
                             	jsr _put_byte
                             	lda #UTF_CR
                             	jsr _put_byte
                             	pla
                             	ply
                             	plx
                             	endm
                             
                             _printA macro
                             	phx
                             	phy
                             	pha
                             	jsr str_a_to_x
                             	jsr _put_byte
                             	txa
                             	jsr _put_byte
                             	pla
                             	ply
                             	plx
                             	endm
                             
                             _printCRLF macro
                             	pha
                             	lda #UTF_CR
                             	jsr _put_byte
                             	pla
                             	endm
                             
                             _printC macro ch
AS65 Assembler for R6502 [1.42].                                     Page    7
-------------------------------- bank\bank1.s --------------------------------

                             	pha
                             	lda #ch
                             	jsr _put_byte
                             	pla
                             	endm
                             
                             _printCA macro
                             	pha
                             	jsr _put_byte
                             	pla
                             	endm
                             
                             _sendcmd macro cmd
                             	_pushAXY
                             	ldx #lo(cmd)
                             	lda #hi(cmd)
                             	jsr sd_sendcmd
                             	_pullAXY
                             	endm
                             
                             _incZPWord macro wordp
                             	inc wordp
                             	db	0xd0, 0x02
                             	inc wordp+1
                             	endm
                             
                             _decZPWord macro wordp
                             	pha
                             	sec
                             	lda wordp
                             	sbc #1
                             	sta wordp
                             	lda wordp+1
                             	sbc #0
                             	sta wordp+1
                             	pla
                             	endm
                             
                             _cpyZPWord macro worda,wordb
                             	lda worda
                             	sta wordb
                             	lda worda+1
                             	sta wordb+1
                             	endm
                             	
                             _addZPWord macro worda, wordb
                             	clc
                             	lda worda
                             	adc wordb
                             	sta worda
                             	lda worda+1
                             	adc wordb+1
                             	sta worda+1
                             	endm
                             
                             _subZPWord macro worda, wordb
                             	sec
                             	lda worda
                             	sbc wordb
                             	sta worda
                             	lda worda+1
                             	sbc wordb+1
AS65 Assembler for R6502 [1.42].                                     Page    8
-------------------------------- bank\bank1.s --------------------------------

                             	sta worda+1
                             	endm
                             	
                             _adcZPWord macro worda,const
                             	clc
                             	lda worda
                             	adc #const
                             	sta worda
                             	lda worda+1
                             	adc #0
                             	sta worda+1
                             	endm
                             
                             
                             	include "inc\graph.i"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  GRAPH.I
                             ;*  This is the definition file for graphics, spe
                             ;*  The graphics screen handling module.  It is j
                             ;*  structure definition - but this structure is 
                             ;*  record the important attributes of a text scr
                             ;*  Needed because there is both a 40 and 32 colu
                             ;*  supported by the VDP, and the screens are not
                             ;*  same location.
                             ;*
                             ;************************************************
                             
0000 =                       	struct gr_screen
0000 =                       	dw gr_screen_start			; Start of screen memory in
0002 =                       	dw gr_screen_size			; Number of bytes screen occ
0004 =                       	db gr_screen_w				; Number of columns
0005 =                       	db gr_screen_h				; Number of rows
0006 =                       	db gr_cur_off				; Y offset of cursor image from
0007 =                       	db gr_cur_x					; Current X position of cursor
0008 =                       	db gr_cur_y					; Current Y position of cursor
0009 =                       	dw gr_cur_ptr				; VDP address of cursor
000b =                       	db gr_pixmode				; Pixel plot mode (0=Erase, 1=P
000c =                       	db gr_pixmask				; Pixel plot mask
000d =                       	db gr_pixcol				; Pixel colour
000e =                       	dw gr_geom_tmp				; One word of temp storage for
                             	end struct
                             	include "io\io.i"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  IO.I
                             ;*  Definitions file for the IO module.  The key 
                             ;*  used by the IO system is defined here.
                             ;*
                             ;************************************************
AS65 Assembler for R6502 [1.42].                                     Page    9
-------------------------------- bank\bank1.s --------------------------------

                             
                             ;* General IO structure allows the system to swap
                             ;* different IO devices by using indirect calls t
                             ;* the appropriate routines.
0000 =                       	struct io_struct
0000 =                       	ds	io_get_byte,	2			;* Address of get byte
0002 =                       	ds	io_put_byte,	2			;* Address of put byte
0004 =                       	ds	io_open_r,		2			;* Address of open file for r
0006 =                       	ds	io_open_w,		2			;* Address of open file for w
0008 =                       	ds	io_close_f,		2			;* Address of close file
000a =                       	ds	io_del_f,		2			;* Address of delete file
000c =                       	ds	io_ext1,		2			;* Address of extended function
000e =                       	ds	io_ext2,		2			;* Address of extended function
                             	end struct
                             	include "dflat\dflat.i"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  DFLAT.I
                             ;*  This is the main definitions file for dflat. 
                             ;*  definitions are in here to access the data st
                             ;*  used by dflat.
                             ;*
                             ;************************************************
                             
                             ;* Start dflat program memory
0cbb =                       DF_PROGSTART=	mem_start
                             ;* This is the top of usable dflat memory plus 1
c000 =                       DF_MEMTOP	=	0xc000
                             
                             ;* Offset in to tokenised line of length and line
0000 =                       DFTK_LINLEN	=	0x00
0001 =                       DFTK_LINNUM	=	0x01
                             
                             ;* Flags for token, escape value for data types a
0080 =                       DFTK_TOKEN	=	0x80
0020 =                       DFTK_ESCVAL	=	0x20
0000 =                       DFTK_EOL	=	0x00
                             
                             ;* Numeric constants are encoded based on size an
                             ;* user representation.
                             ;* For example the decimal value 16 will be encod
                             ;* DFTK_INTDEC followed by the bytes 0 and 16 to 
                             ;* The same value in binary will be encoded as DF
                             ;* followed by the same 0 and 16 bytes.  This is 
                             ;* tokenised value to be displayed in original re
                             ;* So in the two examples, they will be shown as 
                             ;* '0x0010' respectively.
0000 =                       DFTK_CHR	=	0x00
0001 =                       DFTK_RESV1	=	0x01
0002 =                       DFTK_RESV2	=	0x02
0003 =                       DFTK_RESV3	=	0x03
0004 =                       DFTK_RESV4	=	0x04
0005 =                       DFTK_BYTDEC	=	0x05
0006 =                       DFTK_BYTHEX = 	0x06
0007 =                       DFTK_BYTBIN =	0x07
0008 =                       DFTK_RESV8	=	0x08
AS65 Assembler for R6502 [1.42].                                     Page   10
-------------------------------- bank\bank1.s --------------------------------

0009 =                       DFTK_INTDEC	=	0x09
000a =                       DFTK_INTHEX =	0x0a
000b =                       DFTK_INTBIN	=	0x0b
000c =                       DFTK_RESVC	=	0x0c
000d =                       DFTK_RESVD	=	0x0d
000e =                       DFTK_RESVE	=	0x0e
000f =                       DFTK_RESVF	=	0x0f
                             
                             ;* String constant, variable and procedure tokens
0010 =                       DFTK_STRLIT	=	0x10
0011 =                       DFTK_VAR	=	0x11
0012 =                       DFTK_PROC	=	0x12
001f =                       DFTK_STEND	=	0x1f
                             
                             ;* Qualifier for non-local parameters passed to a
0026 =                       DFTK_VARPARM=	'&'
                             
                             ;* Variable Value Table (VVT) definitions
                             ;* The VVT records the values of variables define
                             ;* the Variable Name Table (VNT).  When a variabl
                             ;* used, it is added to the VNT, and the position
                             ;* VNT is used as an index in to the VVT.
                             ;* Every VVT entry is 8 bytes - so the VNT index 
                             ;* shifted left 3 bits to get the VVT offset.
                             ;* The VNT grows from top of memory down, the VVT
                             ;* grows from start of VNT down.
                             
                             ;* Index in to each entry of the VVT
0000 =                       DFVVT_TYPE	=	0x00
0001 =                       DFVVT_LO	=	0x01
0002 =                       DFVVT_HI	=	0x02
0003 =                       DFVVT_DIM1	=	0x03
0004 =                       DFVVT_DIM2	=	0x04
0008 =                       DFVVT_SZ	=	0x08	;VVT is aligned to 8 byte blocks
                             
                             ;* The meaning of the DFVVT_TYPE entry
0001 =                       DFVVT_INT	=	0x01
0002 =                       DFVVT_BYT	=	0x02
0004 =                       DFVVT_STR	=	0x04
0008 =                       DFVVT_FLT	=	0x08
0040 =                       DFVVT_PROC	=	0x40
0080 =                       DFVVT_ARRY	=	0x80
                             
                             ;* Flags indicating the meaning of a token
                             ;* A token has the top bit set (0x80), then the
                             ;* remaining bits indicate what it represents.
0001 =                       DFTK_KW		=	0x01
0002 =                       DFTK_FN		=	0x02
0004 =                       DFTK_STROP	=	0x04
0008 =                       DFTK_OP		=	0x08
0010 =                       DFTK_INT	=	0x10
0020 =                       DFTK_BYT	=	0x20
0040 =                       DFTK_STR	=	0x40
0080 =                       DFTK_FLT	=	0x80
0007 =                       DFTK_OPMSK	=	0x07
00f8 =                       DFTK_RTMSK	= 	0xf8
                             
                             ;* Defines what type of value is on the parameter
                             ;* All numerics are stored as INT, all STR
                             ;* are pointers to the actual string, thus
                             ;* all entries in the parmeter stack are 3 bytes
0001 =                       DFST_INT	=	0x01
AS65 Assembler for R6502 [1.42].                                     Page   11
-------------------------------- bank\bank1.s --------------------------------

0080 =                       DFST_STR	=	0x80
                             
                             ;* Token values of specific commands, used during
                             ;* command processing.
                             ;* ANY CHANGE TO THE ORDER OF KEYWORDS NEEDS TO R
0086 =                       DFRT_DEF	=	0x86
0087 =                       DFRT_ENDDEF	=	0x87
0088 =                       DFRT_RETURN	=	0x88
0089 =                       DFRT_ABORT	=	0x89
008c =                       DFRT_REPEAT	=	0x8c
008e =                       DFRT_FOR	=	0x8e
008f =                       DFRT_NEXT	=	0x8f
0090 =                       DFRT_WHILE	=	0x90
0091 =                       DFRT_WEND	=	0x91
0092 =                       DFRT_IF		=	0x92
0093 =                       DFRT_ELSE	=	0x93
0094 =                       DFRT_ENDIF	=	0x94
0095 =                       DFRT_ELSEIF	=	0x95
0096 =                       DFRT_DATA	=	0x96
0097 =                       DFRT_ASM	=	0x97
                             
                             _PushTrueJmp macro
                             	ldx #0xff
                             	txa
                             	jmp df_st_pushInt
                             	endm
                             
                             _PushFalseJmp macro
                             	ldx #0x00
                             	txa
                             	jmp df_st_pushInt
                             	endm
                             
                             	include "kernel\zeropage.i"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  ZEROPAGE.I
                             ;*  This module name is misleading it is not only
                             ;*  allocations, but also page 2, 3, 4, 5, 6, 7 a
                             ;*  Basically, this module defines:
                             ;*  - All zero page variables for system and dfla
                             ;*  - Page 1 is stack so no need to worry about t
                             ;*  - Page 2 is the serial IO buffer for the 6551
                             ;*  - Page 3 and 4 is a 512 buffer for SD card se
                             ;*  - Page 5 onwards is mainly for dflat working 
                             ;*    but also non-zero page storage for general 
                             ;*    system and scratch usage.
                             ;*  memstart is a handy label that indicates the 
                             ;*  location that we can store dflat programs fro
                             ;*  Zero page is a valuable asset as the 6502 can
                             ;*  this page one cycle quicker than the rest of 
                             ;*  and infact some addressing modes can only use
                             ;*  Due to the value of zero page, a lot of syste
                             ;*  dflat variables are put here.  But we don't h
                             ;*  luxury for single use variables - so you will
                             ;*  see a lot of temporary sounding names which a
AS65 Assembler for R6502 [1.42].                                     Page   12
-------------------------------- bank\bank1.s --------------------------------

                             ;*  have multiple used across the code base.
                             ;*
                             ;************************************************
                             
                             	; Zero page declarations
                             	bss
0000 =                       	org 0x0000
                             
0000 =                       tmp_bank1	ds	1		; Temp storage ONLY FOR USE BY BA
0001 =                       tmp_bank2	ds	1		; Temp storage ONLY FOR USE BY BA
                             
                             ; Interrupt routine addresses
0002 =                       int_irq		 ds	2		; Master IRQ handler
0004 =                       int_brk		 ds	2		; Master BRK handler
0006 =                       int_uservdp	 ds	2		; Where to jump for VDP interr
0008 =                       int_usercia0 ds	2		; Where to jump for CIA0 inter
000a =                       int_usercia1 ds	2		; Where to jump for CIA1 inter
                             
                             ; VDP parameters
000c =                       vdp_cnt		ds	1		; VDP interrupt counter
000d =                       vdp_cnt_hi 	ds	1		; VDP counter high
000e =                       vdp_cnt_hi2	ds	1		; VDP counter high 2
000f =                       vdp_curoff	ds	1		; Cursor off (0 = On)
0010 =                       vdp_curstat	ds	1		; Cursor status
0011 =                       vdp_curval	ds	1		; Cursor value on screen
0012 =                       vdp_blank	ds	1		; Screen blank value normally 32
0013 =                       vdp_delay	ds	1		; Delay counter for VRAM access
                             
                             ; vdp settings
0014 =                       vdp_base	ds	vdp_addr_struct
                             
                             ; Screen geometry
001f =                       gr_scrngeom	ds	gr_screen
                             
                             ;Keyboard parameters
002f =                       kb_raw  	ds	1		; Raw keyboard code
0030 =                       kb_last		ds	1		; Raw code of last key
0031 =                       kb_code 	ds	1		; Converted keyboard code
0032 =                       kb_stat		ds	1		; Keyboard status for caps and shi
0033 =                       kb_deb		ds	1		; VB periods since last KB spike
0034 =                       kb_rep		ds	1		; Keyboard repeat timer
0035 =                       kb_rep_tim 	ds	1		; Default repeat speed
0036 =                       kb_rep_del 	ds	1		; Default repeat delay timing
0037 =                       kb_debounce ds	1		; Default repeat debounce
0038 =                       kb_pressed	ds	1		; Set by the interrupt handler i
                             
0039 =                       tmp_alo 	ds	1		; VDP addresses lo
003a =                       tmp_ahi 	ds	1		; VDP addresses hi
003b =                       tmp_blo 	ds	1		; Temp address lo
003c =                       tmp_bhi		ds	1		; Temp address hi
003d =                       tmp_clo		ds	1		; Temp address lo
003e =                       tmp_chi		ds	1		; Temp address hi
003f =                       tmp_a		ds	1		; Temp storage a
                             
                             ; Raw input/output parameters
0040 =                       buf_lo		ds	1		; Line buffer address low
0041 =                       buf_hi		ds	1		; Line buffer address high
0042 =                       buf_sz		ds	1		; Buffer size
0043 =                       buf_ef		ds	1		; End file / line marker
                             
                             ; SD card driver parameters
0044 =                       sd_slo		ds	1		; Sector pointer low
AS65 Assembler for R6502 [1.42].                                     Page   13
-------------------------------- bank\bank1.s --------------------------------

0045 =                       sd_shi		ds	1		; Sector pointer high
0046 =                       sd_sect		ds	4		; SD Card sector address
004a =                       sd_addr		ds	4		; SD Card byte address
                             
                             ; File system parameters
004e =                       fs_bootsect	ds	4		; Start of partition (usually 0
0052 =                       fs_fatsect	ds	4		; Start of FAT tables
0056 =                       fs_rootsect	ds	4		; Start of Root Directory
005a =                       fs_datasect	ds	4		; Start of Data Area
005e =                       fs_dirsect	ds	4		; Current directory
0062 =                       fh_temp		ds	4		; File handling temporary storage
0066 =                       fh_handle	ds	FileHandle ; File handle parameters
                             
                             
                             ; ** Integer function storage **
008e =                       ztmp_16					; Start of 16 byte scratch area (all 
008e =                       num_a		ds	4		; 4 byte primary accumulator
0092 =                       num_b		ds	4		; 4 byte secondary accumulator
0096 =                       num_x		ds	4		; 4 byte x register
009a =                       num_tmp		ds	4		; 4 byte temp space
009e =                       num_buf		ds	8		; 8 byte string buffer
                             
                             ;
                             ; **** INTERPRETER ZERO PAGE ****
                             ;
00a6 =                       errno		ds	1		; General error condition status
00a7 =                       df_immed	ds	1		; Immediate mode (0 = not immediat
00a8 =                       df_sp		ds	1		; Stack pointer after error to resto
00a9 =                       df_pc		ds	2		; PC after error to return to
00ab =                       df_brkpc	ds	2		; PC pushed on the stack for BRK
00ad =                       df_brkval	ds	1		; Byte after BRK instruction
00ae =                       df_prgstrt	ds	2		; Start of program code
00b0 =                       df_prgend	ds	2		; End of program code
00b2 =                       df_vntstrt	ds	2		; Variable name table start
00b4 =                       df_vntend	ds	2		; Variable name table end
00b6 =                       df_vvtstrt	ds	2		; Variable value table start
00b8 =                       df_vvtend	ds	2		; Variable value table end
00ba =                       df_varcnt	ds	1		; Variable counter
00bb =                       df_starstrt	ds	2		; String and array table start
00bd =                       df_starend	ds	2		; String and array table end
00bf =                       df_rtstop	ds	1		; Runtime stack pointer
00c0 =                       df_parmtop	ds	1		; Top of parameter stack (grows 
00c1 =                       df_strbuff	ds	1		; String expression buffer
00c2 =                       df_stridx	ds	1		; Top of string buffer (grows dow
00c3 =                       df_sevalptr	ds	2		; Pointer to next free char in 
                             
00c5 =                       df_linoff	ds	1		; Offset in to line buffer
00c6 =                       df_tokoff	ds	1		; Offset in to tokenised buffer
00c7 =                       df_eolidx	ds	1		; End of line index (i.e length)
00c8 =                       df_nxtstidx	ds	1		; Offset to the next statement 
00c9 =                       df_curstidx	ds	1		; Offset to the start of curren
00ca =                       df_symtab	ds	2		; Pointer to next free symtab ent
00cc =                       df_symoff	ds	1		; Offset in to token table
00cd =                       df_symini	ds	2		; Start of symtab
00cf =                       df_currlin	ds	2		; Execution current line pointer
00d1 =                       df_exeoff	ds	1		; Execution line buffer offset
00d2 =                       df_nextlin	ds	2		; Next line to execute
00d4 =                       df_tmpptra	ds	2		; Temp pointer a
00d6 =                       df_tmpptrb	ds	2		; Temp pointer b
00d8 =                       df_tmpptrc	ds	2		; Temp pointer c
00da =                       df_tmpptrd	ds	2		; Temp pointer d
00dc =                       df_tmpptre	ds	2		; Temp pointer e
AS65 Assembler for R6502 [1.42].                                     Page   14
-------------------------------- bank\bank1.s --------------------------------

00de =                       df_procmode	ds	1		; Only used during tokenisation
00df =                       df_procargs	ds	1		; Only used during tokenisation
00e0 =                       df_procloc	ds	1		; Counts the number of local par
00e1 =                       df_procptr	ds	2		; Pointer to proc vvt slot
00e3 =                       df_lineptr	ds	2		; Pointer to line during searche
00e5 =                       df_lineidx	ds	1		; Pointer to line index during s
00e6 =                       df_ifnest	ds	1		; Global nested if counter
00e7 =                       df_currdat	ds	2		; Data current line pointer
00e9 =                       df_datoff	ds	1		; Data line buffer offset
00ea =                       df_rnd		ds	2		; Random number seed
                             
00ec =                       df_asmpc	ds	2		; Assembler program counter
00ee =                       df_asmopt	ds	1		; Assembler current option
00ef =                       df_asmadmd	ds	1		; Addressing mode
00f0 =                       df_asmopcde	ds	1		; Current opcode
00f1 =                       df_asmoprnd	ds	2		; Current operand
00f3 =                       df_asmlen	ds	1		; Instruction length
                             
                             
                             
                             ;***** END OF ZERO PAGE *****
00f4 =                       _end_zero_page
                             
                             ;***** Page 1 is CPU stack ****
0100 =                       	org 0x0100
0100 =                       _cpu_stack
0100 =                       			ds	256		; All of page 1
                             
                             ;***** Page 2 and 3 is SD card buffer
0200 =                       	org 0x0200			; SD Card data buffer 512 bytes
0200 =                       sd_buf		ds	512
                             
                             ;***** Page 4,5,6,7 is IO space
0400 =                       	org 0x0400
0400 =                       			ds	1024	; 1 k area divided in to 8x128 byte de
                             
                             
                             ;***** Page 8 is serial buffer *****
0800 =                       	org 0x0800
0800 =                       ser_buf		ds	256		; Serial input / output line buf
                             
0900 =                       	org 0x0900			; Page 9 = dflat space
0900 =                       df_linbuff
0900 =                       df_raw		ds	128		; untokenised input line
0980 =                       df_tokbuff
0980 =                       df_tok		ds 	128		; tokenised output line
                             
0a00 =                       	org 0x0a00			; Page 10 = fixed space for runtime
0a00 =                       df_rtstck
0a00 =                       df_rtspace	ds	256
                             
0b00 =                       	org 0x0b00			; Page 11 = 1/2 page fixed space fo
0b00 =                       df_opstck
0b00 =                       df_opspace	ds	128
                             
                             ;***** NON-ZERO PAGE VARIABLES *****
                             
                             ; Acticve IO device settings
0b80 =                       io_default	ds	1		; The default device number
0b81 =                       io_block	ds	io_struct
                             
                             ; File entry current dir entry
AS65 Assembler for R6502 [1.42].                                     Page   15
-------------------------------- bank\bank1.s --------------------------------

0b91 =                       fh_dir		ds	FileHandle
                             
                             ; Dflat top of memory+1 - normally initialised to
0bb9 =                       df_memtop	ds	2
                             
                             ; Scratch area e.g. string and numeric expression
0bbb =                       scratch		ds	256
                             
                             ;***** THIS IS THE START OF FREE SPACE for DFLAT 
0cbb =                       mem_start
                             
                             
                             	include "dflat\dflat.i"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  DFLAT.I
                             ;*  This is the main definitions file for dflat. 
                             ;*  definitions are in here to access the data st
                             ;*  used by dflat.
                             ;*
                             ;************************************************
                             
                             ;* Start dflat program memory
0cbb =                       DF_PROGSTART=	mem_start
                             ;* This is the top of usable dflat memory plus 1
c000 =                       DF_MEMTOP	=	0xc000
                             
                             ;* Offset in to tokenised line of length and line
0000 =                       DFTK_LINLEN	=	0x00
0001 =                       DFTK_LINNUM	=	0x01
                             
                             ;* Flags for token, escape value for data types a
0080 =                       DFTK_TOKEN	=	0x80
0020 =                       DFTK_ESCVAL	=	0x20
0000 =                       DFTK_EOL	=	0x00
                             
                             ;* Numeric constants are encoded based on size an
                             ;* user representation.
                             ;* For example the decimal value 16 will be encod
                             ;* DFTK_INTDEC followed by the bytes 0 and 16 to 
                             ;* The same value in binary will be encoded as DF
                             ;* followed by the same 0 and 16 bytes.  This is 
                             ;* tokenised value to be displayed in original re
                             ;* So in the two examples, they will be shown as 
                             ;* '0x0010' respectively.
0000 =                       DFTK_CHR	=	0x00
0001 =                       DFTK_RESV1	=	0x01
0002 =                       DFTK_RESV2	=	0x02
0003 =                       DFTK_RESV3	=	0x03
0004 =                       DFTK_RESV4	=	0x04
0005 =                       DFTK_BYTDEC	=	0x05
0006 =                       DFTK_BYTHEX = 	0x06
0007 =                       DFTK_BYTBIN =	0x07
0008 =                       DFTK_RESV8	=	0x08
0009 =                       DFTK_INTDEC	=	0x09
000a =                       DFTK_INTHEX =	0x0a
AS65 Assembler for R6502 [1.42].                                     Page   16
-------------------------------- bank\bank1.s --------------------------------

000b =                       DFTK_INTBIN	=	0x0b
000c =                       DFTK_RESVC	=	0x0c
000d =                       DFTK_RESVD	=	0x0d
000e =                       DFTK_RESVE	=	0x0e
000f =                       DFTK_RESVF	=	0x0f
                             
                             ;* String constant, variable and procedure tokens
0010 =                       DFTK_STRLIT	=	0x10
0011 =                       DFTK_VAR	=	0x11
0012 =                       DFTK_PROC	=	0x12
001f =                       DFTK_STEND	=	0x1f
                             
                             ;* Qualifier for non-local parameters passed to a
0026 =                       DFTK_VARPARM=	'&'
                             
                             ;* Variable Value Table (VVT) definitions
                             ;* The VVT records the values of variables define
                             ;* the Variable Name Table (VNT).  When a variabl
                             ;* used, it is added to the VNT, and the position
                             ;* VNT is used as an index in to the VVT.
                             ;* Every VVT entry is 8 bytes - so the VNT index 
                             ;* shifted left 3 bits to get the VVT offset.
                             ;* The VNT grows from top of memory down, the VVT
                             ;* grows from start of VNT down.
                             
                             ;* Index in to each entry of the VVT
0000 =                       DFVVT_TYPE	=	0x00
0001 =                       DFVVT_LO	=	0x01
0002 =                       DFVVT_HI	=	0x02
0003 =                       DFVVT_DIM1	=	0x03
0004 =                       DFVVT_DIM2	=	0x04
0008 =                       DFVVT_SZ	=	0x08	;VVT is aligned to 8 byte blocks
                             
                             ;* The meaning of the DFVVT_TYPE entry
0001 =                       DFVVT_INT	=	0x01
0002 =                       DFVVT_BYT	=	0x02
0004 =                       DFVVT_STR	=	0x04
0008 =                       DFVVT_FLT	=	0x08
0040 =                       DFVVT_PROC	=	0x40
0080 =                       DFVVT_ARRY	=	0x80
                             
                             ;* Flags indicating the meaning of a token
                             ;* A token has the top bit set (0x80), then the
                             ;* remaining bits indicate what it represents.
0001 =                       DFTK_KW		=	0x01
0002 =                       DFTK_FN		=	0x02
0004 =                       DFTK_STROP	=	0x04
0008 =                       DFTK_OP		=	0x08
0010 =                       DFTK_INT	=	0x10
0020 =                       DFTK_BYT	=	0x20
0040 =                       DFTK_STR	=	0x40
0080 =                       DFTK_FLT	=	0x80
0007 =                       DFTK_OPMSK	=	0x07
00f8 =                       DFTK_RTMSK	= 	0xf8
                             
                             ;* Defines what type of value is on the parameter
                             ;* All numerics are stored as INT, all STR
                             ;* are pointers to the actual string, thus
                             ;* all entries in the parmeter stack are 3 bytes
0001 =                       DFST_INT	=	0x01
0080 =                       DFST_STR	=	0x80
                             
AS65 Assembler for R6502 [1.42].                                     Page   17
-------------------------------- bank\bank1.s --------------------------------

                             ;* Token values of specific commands, used during
                             ;* command processing.
                             ;* ANY CHANGE TO THE ORDER OF KEYWORDS NEEDS TO R
0086 =                       DFRT_DEF	=	0x86
0087 =                       DFRT_ENDDEF	=	0x87
0088 =                       DFRT_RETURN	=	0x88
0089 =                       DFRT_ABORT	=	0x89
008c =                       DFRT_REPEAT	=	0x8c
008e =                       DFRT_FOR	=	0x8e
008f =                       DFRT_NEXT	=	0x8f
0090 =                       DFRT_WHILE	=	0x90
0091 =                       DFRT_WEND	=	0x91
0092 =                       DFRT_IF		=	0x92
0093 =                       DFRT_ELSE	=	0x93
0094 =                       DFRT_ENDIF	=	0x94
0095 =                       DFRT_ELSEIF	=	0x95
0096 =                       DFRT_DATA	=	0x96
0097 =                       DFRT_ASM	=	0x97
                             
                             _PushTrueJmp macro
                             	ldx #0xff
                             	txa
                             	jmp df_st_pushInt
                             	endm
                             
                             _PushFalseJmp macro
                             	ldx #0x00
                             	txa
                             	jmp df_st_pushInt
                             	endm
                             
                             	include "dflat\error.i"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  ERROR.I
                             ;*  Error definitions file.
                             ;*  The macro to throw an error is elswhere, but 
                             ;*  it issues a 6502 BRK commmand with the next b
                             ;*  the error code.  The BRK handler then picks u
                             ;*  code and shows the appropriate message plus a
                             ;*  number if a program was running.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
                             ; Error message numbers
0000 =                       DFERR_OK		=	0
0001 =                       DFERR_ERROR		=	1
0002 =                       DFERR_SYNTAX	=	2
0003 =                       DFERR_RUNTIME	=	3
0004 =                       DFERR_TYPEMISM	=	4
0005 =                       DFERR_DIM		=	5
0006 =                       DFERR_UNTIL		=	6
0007 =                       DFERR_NOPROC	=	7
AS65 Assembler for R6502 [1.42].                                     Page   18
-------------------------------- bank\bank1.s --------------------------------

0008 =                       DFERR_PROCPARM	=	8
0009 =                       DFERR_IMMEDIATE	=	9
000a =                       DFERR_UNCLOSEDIF=	10
000b =                       DFERR_NOIF		=	11
000c =                       DFERR_NEXTFOR	=	12
000d =                       DFERR_FNAME		=	13
000e =                       DFERR_STRLONG	=	14
000f =                       DFERR_BREAK		=	15
0010 =                       DFERR_NODATA	=	16
0011 =                       DFERR_WEND		=	17
0012 =                       DFERR_NOLINE	=	18
0013 =                       DFERR_RETURN	=	19
0014 =                       DFERR_ABORT		=	20
0015 =                       DFERR_QUANTITY	=	21
0016 =                       DFERR_NOORG		=	22
0017 =                       DFERR_ADDRMODE	=	23
                             
                             
                             
                             	include "bank\bank.i"
c000 =                       bankjsr_nul_addr	=	0xc000
0000 =                       bankjsr_nul_bank	=	0x00
003f =                       ROM_ZMASK			=	0x3f
00cf =                       RAM_ZMASK			=	0xcf
                             
                             _bankjsr	macro	addr,bank
                             	; Save A
                             	sta tmp_bank1
                             	
                             	; Save current bank
                             	lda bank_num
                             	pha
                             	
                             	; Switch to new bank
                             	lda IO_0+PRB
                             	and #ROM_ZMASK
                             	ora #(bank^3) << 6			; Shift left 6 bits
                             	sta IO_0+PRB
                             
                             	; Restore A
                             	lda tmp_bank1
                             	; JSR to the routine
                             	jsr addr
                             	
                             	jmp _restore_bank
                             	; 62 clock cycles inc restore vs 6 for a near js
                             
                             	endm
                             	
                             _bankram macro bank
                             	pha
                             	lda IO_0+PRB
                             	and #RAM_ZMASK
                             	ora #bank << 4
                             	sta IO_0+PRB
                             	pla
                             	endm
                             	
                             _bankram_fast macro bank
                             	lda IO_0+PRB
                             	and #RAM_ZMASK
                             	ora #bank << 4
AS65 Assembler for R6502 [1.42].                                     Page   19
-------------------------------- bank\bank1.s --------------------------------

                             	sta IO_0+PRB
                             	endm
                             	
                             
                             
                             
                             ;****************************************
                             ;*	Set 6502 default vectors	*
                             ;****************************************
                             	data				; Set vectors
fffa =                       	org 0xfffa			; Vectors lie at addresses
fffa : f7c9                  	fcw nmi				; 0xfffa : NMI Vector
fffc : 98c9                  	fcw init			; 0xfffc : Reset Vector
fffe : 20c6                  	fcw call_irq_master	; 0xfffe : IRQ Vector
                             	
                             	; ROM code
                             	code				;  
c000 =                       	org 0xc000			; Start of ROM
                             
                             	; The bank number is hardwired and aligned to PB
c000 :                       bank_num
                             	if BANK0
                             	  db 192
                             	endif
                             	if BANK1
c000 : 80                    	  db 128
                             	endif
                             	if BANK2
                             	  db 64
                             	endif
                             	if BANK3
                             	  db 0
                             	endif
                             
c001 :                       _code_start
                             	; Restore current bank always at address c001
c001 :                       _OSVectors
                             	include "kernel\osvec.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  OSVEC.S
                             ;*  Simply this is a bunch of JMP XXXX the order 
                             ;*  will always be maintained.  This is to allow 
                             ;*  code programs to be able to rely on fixed loc
                             ;*  some key low-level functions.
                             ;*  Only low level functions are needed, the idea
                             ;*  as the assembler is part of the BASIC, one ca
                             ;*  level slow stuff using BASIC then switch to M
                             ;*  speed up.
                             ;*  This code goes straight after the bank number
                             ;*  Each JMP is at 0xc001+3*(vector #)
                             ;*
                             ;************************************************
                             
c001 : 4c49c4           [ 3] 	jmp	io_put_ch			; Vec 0
c004 : 4c46c4           [ 3] 	jmp io_get_ch			; Vec 1
AS65 Assembler for R6502 [1.42].                                     Page   20
-------------------------------- bank\bank1.s --------------------------------

c007 : 4cd6c4           [ 3] 	jmp vdp_wr_reg			; Vec 2
c00a : 4c0ec5           [ 3] 	jmp vdp_poke			; Vec 3
c00d : 4c1ac5           [ 3] 	jmp vdp_peek			; Vec 4
c010 : 4c7bc5           [ 3] 	jmp snd_get_joy0		; Vec 5
c013 : 4c23c5           [ 3] 	jmp snd_set				; Vec 6
c016 : 4ce3c4           [ 3] 	jmp vdp_wr_addr			; Vec 7
c019 : 4cfac4           [ 3] 	jmp	vdp_rd_addr			; Vec 8
c01c :                       _restore_bank
                             	; Save A
c01c : 8500             [ 3] 	sta tmp_bank1
                             	; Get old bank from stack
c01e : 68               [ 4] 	pla
c01f : 8501             [ 3] 	sta tmp_bank2
c021 : ad0004           [ 4] 	lda IO_0+PRB
c024 : 293f             [ 2] 	and #ROM_ZMASK
c026 : 0501             [ 3] 	ora tmp_bank2
c028 : 8d0004           [ 4] 	sta IO_0+PRB
                             	
                             	; Restore A
c02b : a500             [ 3] 	lda tmp_bank1
                             
c02d : 60               [ 6] 	rts
                             
                             	; include cross-bank functions (see extern.mak)
                             	include "bank\autogen.s"	
                             ; 
c02e :                       mod_sz_autogen_s 
c02e :                       _df_init 
                               _bankjsr $ef9a, 1 
                             
c046 :                       _df_pg_dflat 
                               _bankjsr $d677, 1 
                             
c05e :                       _fs_chdir 
                               _bankjsr $d1e3, 2 
                             
c076 :                       _fs_delete 
                               _bankjsr $d1a9, 2 
                             
c08e :                       _fs_close 
                               _bankjsr $d188, 2 
                             
c0a6 :                       _fs_get_next_byte 
                               _bankjsr $cf13, 2 
                             
c0be :                       _fs_open_read 
                               _bankjsr $d126, 2 
                             
c0d6 :                       _fs_open_write 
                               _bankjsr $d14f, 2 
                             
c0ee :                       _fs_put_byte 
                               _bankjsr $d044, 2 
                             
c106 :                       _get_byte 
                               _bankjsr $ca78, 0 
                             
c11e :                       _put_byte 
                               _bankjsr $ca88, 0 
                             
c136 :                       _gr_get_key 
                               _bankjsr $d996, 0 
AS65 Assembler for R6502 [1.42].                                     Page   21
-------------------------------- bank\bank1.s --------------------------------

                             
c14e :                       _gr_put_byte 
                               _bankjsr $d9a3, 0 
                             
c166 :                       _gr_init_screen 
                               _bankjsr $d455, 0 
                             
c17e :                       _init_acia 
                               _bankjsr $ca95, 0 
                             
c196 :                       _init_cia0 
                               _bankjsr $ca25, 0 
                             
c1ae :                       _init_cia1 
                               _bankjsr $ca56, 0 
                             
c1c6 :                       _init_fs 
                               _bankjsr $ccc3, 2 
                             
c1de :                       _init_sdcard 
                               _bankjsr $c9f8, 2 
                             
c1f6 :                       _init_snd 
                               _bankjsr $cc6c, 0 
                             
c20e :                       _init_keyboard 
                               _bankjsr $caa3, 0 
                             
c226 :                       _kb_read_raw 
                               _bankjsr $cab2, 0 
                             
c23e :                       _command_line 
                               _bankjsr $d23e, 2 
                             
c256 :                       _fs_dir_find_entry 
                               _bankjsr $cdc4, 2 
                             
c26e :                       _fs_dir_root_start 
                               _bankjsr $cdab, 2 
                             
c286 :                       _gr_cls 
                               _bankjsr $d45f, 0 
                             
c29e :                       _gr_init_hires 
                               _bankjsr $d412, 0 
                             
c2b6 :                       _gr_line 
                               _bankjsr $d7d0, 0 
                             
c2ce :                       _gr_box 
                               _bankjsr $d610, 0 
                             
c2e6 :                       _gr_circle 
                               _bankjsr $d71b, 0 
                             
c2fe :                       _gr_plot 
                               _bankjsr $d4ca, 0 
                             
c316 :                       _gr_hchar 
                               _bankjsr $d504, 0 
                             
c32e :                       _gr_point 
AS65 Assembler for R6502 [1.42].                                     Page   22
-------------------------------- bank\bank1.s --------------------------------

                               _bankjsr $d5c5, 0 
                             
c346 :                       _gr_get 
                               _bankjsr $d4e1, 0 
                             
c35e :                       _gr_set_cur 
                               _bankjsr $d4e9, 0 
                             
c376 :                       _snd_get_note 
                               _bankjsr $cc65, 0 
                             
c38e :                       _snd_get_joy0 
                               _bankjsr $c57b, 0 
                             
c3a6 :                       _snd_set 
                               _bankjsr $c523, 0 
                             
c3be :                       _vdp_peek 
                               _bankjsr $c51a, 0 
                             
c3d6 :                       _vdp_poke 
                               _bankjsr $c50e, 0 
                             
c3ee :                       _vdp_init 
                               _bankjsr $d200, 0 
                             
c406 :                       mod_sz_autogen_e 
                             
                             	
c406 :                       mod_sz_kernel_s
                             
                             ;* Include all common code in the right order
                             	include "io\io.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  IO.S
                             ;*  General IO module.  Allows different IO devic
                             ;*  utilised transparently by the rest of the cod
                             ;*  Other code should use "io_" commands so that 
                             ;*  do not need to know what specific device is p
                             ;*  input and output capabilities.  On startup, t
                             ;*  examines the BBC DIP switch to decide whether
                             ;*  initialise the IO to serial through the ACIA 
                             ;*  the BBC keyboard for input with the VDP for o
                             ;*  Loading and saving files from the SD card is 
                             ;*  achieved by pointing to SD card get and put b
                             ;*  routines.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             
c406 :                       mod_sz_io_s
                             
                             ;****************************************
AS65 Assembler for R6502 [1.42].                                     Page   23
-------------------------------- bank\bank1.s --------------------------------

                             ;* io_init
                             ;* Initialise the default device and make active
                             ;* No keys pressed = serial (default)
                             ;* F0 pressed = KB/VDP
                             ;* F1 pressed = Serial
                             ;* Keyboard and screen or serial port
                             ;* Output : None
                             ;* Regs affected : P, A
                             ;****************************************
c406 :                       io_init
c406 : 2026c2           [ 6] 	jsr _kb_read_raw	; Check pressed key
c409 : a900             [ 2] 	lda #0				; Default = Serial
c40b : e080             [ 2] 	cpx #0x80			; f0 key pressed?
c40d : d004             [ 3] 	bne io_init_skip_f0
c40f : a901             [ 2] 	lda #1				; Default = KB/VDP
c411 : 8006             [ 3] 	bra io_init_done
c413 :                       io_init_skip_f0
c413 : e081             [ 2] 	cpx #0x81			; f1 key pressed?
c415 : d002             [ 3] 	bne io_init_done
c417 : a900             [ 2] 	lda #0				; f1 pressed = serial
c419 :                       io_init_done
c419 : 8d800b           [ 4] 	sta io_default
c41c : 4c22c4           [ 3] 	jmp io_active_device; Activate the device
                             
                             
                             ;****************************************
                             ;* io_set_default, io_active_device
                             ;* Activate device based on default or A
                             ;* Input : A = Device number
                             ;* Output : None
                             ;* Regs affected : P, A
                             ;****************************************
c41f :                       io_set_default			; Entry point for default
c41f : ad800b           [ 4] 	lda io_default
c422 :                       io_active_device		; Entry point for A set
c422 : 0a               [ 2] 	asl	a				; x16 the Block number
c423 : 0a               [ 2] 	asl a
c424 : 0a               [ 2] 	asl a
c425 : 0a               [ 2] 	asl a
c426 : a8               [ 2] 	tay
c427 : a200             [ 2] 	ldx #0
                             	; Copy device settings to io block
c429 :                       io_copy_data
c429 : b9a6c4           [ 4] 	lda io_devices,y
c42c : 9d810b           [ 5] 	sta io_block,x
c42f : c8               [ 2] 	iny
c430 : e8               [ 2] 	inx
c431 : e010             [ 2] 	cpx #16
c433 : d0f4             [ 3] 	bne io_copy_data
                             	
c435 : a900             [ 2] 	lda #lo(ser_buf)	; Initialise buffer and size
c437 : 8540             [ 3] 	sta buf_lo
c439 : a908             [ 2] 	lda #hi(ser_buf)
c43b : 8541             [ 3] 	sta buf_hi
c43d : a9ff             [ 2] 	lda #255
c43f : 8542             [ 3] 	sta buf_sz
c441 : a90d             [ 2] 	lda #UTF_CR		; Line terminator is CR
c443 : 8543             [ 3] 	sta buf_ef
c445 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* io_get_ch
AS65 Assembler for R6502 [1.42].                                     Page   24
-------------------------------- bank\bank1.s --------------------------------

                             ;* Get a char (wait forever or just check)
                             ;* Input : C = 1 for synchronous, 0 for async
                             ;* Output : A = Byte code, C = 0 means A is inval
                             ;* Regs affected : P, A
                             ;****************************************
c446 :                       io_get_ch
c446 : 6c810b           [ 6] 	jmp (io_block+io_get_byte)
                             	
                             
                             ;****************************************
                             ;* io_put_ch
                             ;* Put a char
                             ;* Input : A = char
                             ;* Regs affected : P, A
                             ;****************************************
c449 :                       io_put_ch
c449 : 6c830b           [ 6] 	jmp (io_block+io_put_byte)
                             	
                             ;****************************************
                             ;* io_open_read
                             ;* Open for reading
                             ;* Input : X,A = pointer to filename (zero termin
                             ;* Output : C=0 success
                             ;* Regs affected : All
                             ;****************************************
c44c :                       io_open_read
c44c : 6c850b           [ 6] 	jmp (io_block+io_open_r)
                             	
                             ;****************************************
                             ;* io_open_write
                             ;* Open for reading
                             ;* Input : X,A = pointer to filename (zero termin
                             ;* Output : C=0 success
                             ;* Regs affected : All
                             ;****************************************
c44f :                       io_open_write
c44f : 6c870b           [ 6] 	jmp (io_block+io_open_w)
                             
                             ;****************************************
                             ;* io_close
                             ;* Close a file
                             ;* Input : 
                             ;* Output : C=0 success
                             ;* Regs affected : All
                             ;****************************************
c452 :                       io_close
c452 : 6c890b           [ 6] 	jmp (io_block+io_close_f)
                             	
                             ;****************************************
                             ;* io_delete
                             ;* Delete a file
                             ;* Input : 
                             ;* Output : C=0 success
                             ;* Regs affected : All
                             ;****************************************
c455 :                       io_delete
c455 : 6c8b0b           [ 6] 	jmp (io_block+io_del_f)
                             	
                             ;****************************************
                             ;* io_read_line
                             ;* Read a line, terminated by terminating char or
                             ;* Input : buf_(lo/hi/sz/ef) : Address, Max size,
AS65 Assembler for R6502 [1.42].                                     Page   25
-------------------------------- bank\bank1.s --------------------------------

                             ;* Output : Y = Line length C = Buffer limit reac
                             ;* Regs affected : None
                             ;****************************************
c458 :                       io_read_line
c458 : 48               [ 3] 	pha
                             
c459 : 08               [ 3] 	php					; Save echo state
                             	
c45a : a000             [ 2] 	ldy #0x00			; Starting at first byte
c45c :                       io_get_line_byte
c45c : 38               [ 2] 	sec					; Getting bytes synchronously
c45d : 2046c4           [ 6] 	jsr io_get_ch		; Get a byte
c460 : b027             [ 3] 	bcs io_get_line_done; Got nothing then finish
c462 : 28               [ 4] 	plp					; Get echo state
c463 : 08               [ 3] 	php					; Instantly save it back
c464 : 900c             [ 3] 	bcc io_skip_echo	; Carry not set = don't echo
c466 : c97f             [ 2] 	cmp #UTF_DEL		; Delete?
c468 : d005             [ 3] 	bne io_do_echo
c46a : c000             [ 2] 	cpy #0				; Already at beginning?
c46c : f004             [ 3] 	beq io_skip_echo	; Don't echo delete
c46e : 88               [ 2] 	dey					; Else decrement length
c46f :                       io_do_echo
c46f : 2049c4           [ 6] 	jsr io_put_ch		; Echo it
c472 :                       io_skip_echo
c472 : c920             [ 2] 	cmp #UTF_SPECIAL	; Special character?
c474 : 9007             [ 3] 	bcc io_skip_special	; Skip if so (don't add to b
c476 : c97f             [ 2] 	cmp #UTF_DEL		; Don't proces DEL either
c478 : f003             [ 3] 	beq io_skip_special
c47a : 9140             [ 5] 	sta (buf_lo),y		; Save it
c47c : c8               [ 2] 	iny					; Increase length
c47d :                       io_skip_special
c47d : c543             [ 3] 	cmp buf_ef			; Is it the terminating char?
c47f : f008             [ 3] 	beq io_get_line_done	; If yes then done
c481 : c442             [ 3] 	cpy buf_sz			; Reached the buffer max size?
c483 : d0d7             [ 3] 	bne io_get_line_byte	; No, get another byte
c485 : 28               [ 4] 	plp					; Remember to pull echo state off stack
c486 : 38               [ 2] 	sec					; Yes, set carry flag
c487 : 68               [ 4] 	pla
c488 : 60               [ 6] 	rts					; And done
c489 :                       io_get_line_done
c489 : a900             [ 2] 	lda #0
c48b : 9140             [ 5] 	sta (buf_lo),y		; Terminate with 0
c48d : 28               [ 4] 	plp					; Remember to pull echo state off stack
c48e : 18               [ 2] 	clc					; Clear carry flag
c48f : 68               [ 4] 	pla
c490 : 60               [ 6] 	rts					; Fin
                             
                             ;****************************************
                             ;* io_print_line
                             ;* Print a line (when data is not already in seri
                             ;* Input : X = Address Lo, A = Address Hi
                             ;* Output : Y=number chars output
                             ;* Regs affected : All
                             ;****************************************
c491 :                       io_print_line
c491 : 48               [ 3] 	pha
                             
c492 : 863d             [ 3] 	stx tmp_clo					; Store the string pointer
c494 : 853e             [ 3] 	sta tmp_chi					; lo and hi
c496 : a000             [ 2] 	ldy #0						; Start at the beginning!
c498 :                       io_print_line_byte
c498 : b13d             [ 5] 	lda (tmp_clo),y				; Copy byte to
AS65 Assembler for R6502 [1.42].                                     Page   26
-------------------------------- bank\bank1.s --------------------------------

c49a : f006             [ 3] 	beq io_print_done			; If zero then done - print
c49c : 2049c4           [ 6] 	jsr io_put_ch				; Transmit
c49f : c8               [ 2] 	iny
c4a0 : d0f6             [ 3] 	bne io_print_line_byte		; Carry on until zero fo
c4a2 :                       io_print_done
c4a2 : 68               [ 4] 	pla
c4a3 : 60               [ 6] 	rts
                             
                             
                             ;*** Null operation just clc and return ***
c4a4 :                       io_null_op
c4a4 : 18               [ 2] 	clc
c4a5 : 60               [ 6] 	rts
                             	
                             ;* IO devices defined here
c4a6 :                       io_devices
                             ;* Device zero is the serial port
                             ;* only offers get and put
c4a6 :                       io_device0					; Serial device, input = Ser, outp
c4a6 : 06c1                  	dw	_get_byte			; io_get_ch
c4a8 : 1ec1                  	dw	_put_byte			; io_put_ch
c4aa : a4c4                  	dw	io_null_op			; io_open_r
c4ac : a4c4                  	dw	io_null_op			; io_open_w
c4ae : a4c4                  	dw	io_null_op			; io_close_f
c4b0 : a4c4                  	dw	io_null_op			; io_del_f
c4b2 : a4c4                  	dw	io_null_op			; io_ext1
c4b4 : a4c4                  	dw	io_null_op			; io_ext2
                             ;* Device one is keyboard / screen
                             ;* only offers get and put
c4b6 :                       io_device1					; Default device, input = screen e
c4b6 : 36c1                  	dw	_gr_get_key			; io_get_ch
c4b8 : 4ec1                  	dw	_gr_put_byte		; io_put_ch
c4ba : a4c4                  	dw	io_null_op			; io_open_r
c4bc : a4c4                  	dw	io_null_op			; io_open_w
c4be : a4c4                  	dw	io_null_op			; io_close_f
c4c0 : a4c4                  	dw	io_null_op			; io_del_f
c4c2 : a4c4                  	dw	io_null_op			; io_ext1
c4c4 : a4c4                  	dw	io_null_op			; io_ext2
                             ;* Device two is the file system on SD card
                             ;* Offers all IO functions
c4c6 :                       io_device2					; SD device, input = SD, output = 
c4c6 : a6c0                  	dw	_fs_get_next_byte	; io_get_ch
c4c8 : eec0                  	dw	_fs_put_byte		; io_put_ch
c4ca : bec0                  	dw	_fs_open_read		; io_open_r
c4cc : d6c0                  	dw	_fs_open_write		; io_open_w
c4ce : 8ec0                  	dw	_fs_close			; io_close_f
c4d0 : 76c0                  	dw	_fs_delete			; io_del_f
c4d2 : a4c4                  	dw	io_null_op			; io_ext1
c4d4 : a4c4                  	dw	io_null_op			; io_ext2
                             
c4d6 :                       mod_sz_io_e
                             
                             
                             	include "kernel\vdp-low.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
AS65 Assembler for R6502 [1.42].                                     Page   27
-------------------------------- bank\bank1.s --------------------------------

                             ;*  VDP-LOW.S
                             ;*  Low level VDP routines which will always be p
                             ;*  every ROM bank.  This is to ensure if IRQ nee
                             ;*  no slow bank switching is needed, but also to
                             ;*	OS vectored access to VDP routines for M/C fro
                             ;*
                             ;************************************************
                             
                             ;****************************************
                             ;* vdp_wr_reg
                             ;* Write to Register A the value X
                             ;* Input : A - Register Number, X - Data
                             ;* Output : None
                             ;* Regs affected : P
                             ;****************************************
c4d6 :                       vdp_wr_reg
c4d6 : 8e0105           [ 4] 	stx VDP_MODE1
                             ; Extra nop for fast CPU
c4d9 : ea               [ 2] 	nop
c4da : ea               [ 2] 	nop
c4db : 0980             [ 2] 	ora #0x80
c4dd : 8d0105           [ 4] 	sta VDP_MODE1
c4e0 : 4980             [ 2] 	eor #0x80
c4e2 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* vdp_wr_addr
                             ;* Write to address in X (low) and A (high) - for
                             ;* Input : A - Address high byte, X - Address low
                             ;* Output : None
                             ;* Regs affected : P
                             ;****************************************
c4e3 :                       vdp_wr_addr
c4e3 : 8e0105           [ 4] 	stx VDP_MODE1
                             ; Extra nop for fast CPU
c4e6 : ea               [ 2] 	nop
c4e7 : ea               [ 2] 	nop
c4e8 : 0940             [ 2] 	ora #0x40		; Required by VDP
c4ea : 8d0105           [ 4] 	sta VDP_MODE1
c4ed : 4940             [ 2] 	eor #0x40		; Undo that bit
c4ef : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* vdp_mem_wait
                             ;* Delay some time before a memory access,
                             ;* taking in to account mode 9918 needs up
                             ;* to 3.1uS for text mode, 8uS for graphics
                             ;* I and II
                             ;* @ 5.35Mhz	= 16 cycles for 3.1uS
                             ;*				= 43 cycles for 8uS
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
c4f0 :                       vdp_mem_wait
c4f0 : da               [ 3] 	phx								; 3
c4f1 : a613             [ 3] 	ldx vdp_delay					; 3
c4f3 : f003             [ 3] 	beq vdp_mem_wait_end			; 3
c4f5 :                       vdp_mem_wait_loop
c4f5 : ca               [ 2] 	dex								; 2
c4f6 : d0fd             [ 3] 	bne	vdp_mem_wait_loop			; 3
AS65 Assembler for R6502 [1.42].                                     Page   28
-------------------------------- bank\bank1.s --------------------------------

c4f8 :                       vdp_mem_wait_end
c4f8 : fa               [ 4] 	plx								; 3
c4f9 : 60               [ 6] 	rts								; 6
                             	
                             ;****************************************
                             ;* vdp_rd_addr
                             ;* Set read address 
                             ;* Input : A - high, X - low 
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
c4fa :                       vdp_rd_addr
c4fa : 8e0105           [ 4] 	stx VDP_MODE1
                             ; These nops are needed for fast CPU
c4fd : ea               [ 2] 	nop
c4fe : ea               [ 2] 	nop
c4ff : 8d0105           [ 4] 	sta VDP_MODE1
c502 : 80ec             [ 4] 	bra vdp_mem_wait
                             	
                             ;****************************************
                             ;* vdp_rd_vram
                             ;* Read VRAM byte, result in A
                             ;* Input : None
                             ;* Output : A - Byte from VRAM
                             ;* Regs affected : P
                             ;****************************************
c504 :                       vdp_rd_vram
c504 : ad0005           [ 4] 	lda VDP_VRAM
c507 : 80e7             [ 4] 	bra vdp_mem_wait
                             	
                             ;****************************************
                             ;* vdp_wr_vram
                             ;* Write VRAM byte in A
                             ;* Input : A - Byte to write
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
c509 :                       vdp_wr_vram
c509 : 8d0005           [ 4] 	sta VDP_VRAM
c50c : 80e2             [ 4] 	bra vdp_mem_wait
                             	
                             ;****************************************
                             ;* vdp_poke
                             ;* Write VRAM byte in A, (YX)
                             ;* Input : A - Byte to write
                             ;*		   X = Low Address
                             ;*		   Y = High Address
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
c50e :                       vdp_poke
c50e : 48               [ 3] 	pha
c50f : 98               [ 2] 	tya
c510 : 78               [ 2] 	sei
c511 : 20e3c4           [ 6] 	jsr vdp_wr_addr
c514 : 68               [ 4] 	pla
c515 : 2009c5           [ 6] 	jsr vdp_wr_vram
c518 : 58               [ 2] 	cli
c519 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* vdp_peek
AS65 Assembler for R6502 [1.42].                                     Page   29
-------------------------------- bank\bank1.s --------------------------------

                             ;* Get VRAM byte in (AX)
                             ;*		   X = Low Address
                             ;*		   A = High Address
                             ;* Output : A = byte read
                             ;* Regs affected : None
                             ;****************************************
c51a :                       vdp_peek
c51a : 78               [ 2] 	sei
c51b : 20fac4           [ 6] 	jsr vdp_rd_addr
c51e : 2004c5           [ 6] 	jsr vdp_rd_vram
c521 : 58               [ 2] 	cli
c522 : 60               [ 6] 	rts
                             
                             	include "kernel\snd-low.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  SND-LOW.S
                             ;*  Low level sound routines which will always be
                             ;*  in every ROM bank.  Mainly to provide fast OS
                             ;*	access to VDP routines for M/C from BASIC
                             ;*
                             ;************************************************
                             
                             ;****************************************
                             ;* snd_set
                             ;* Set AY register X to value Y
                             ;* Input : X = Reg no, Y = Value
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
c523 :                       snd_set
c523 : 48               [ 3] 	pha
                             
c524 : a9ff             [ 2] 	lda #0xff				; Set Port A to output
c526 : 8d8304           [ 4] 	sta IO_1 + DDRA
                             
c529 : 8e8104           [ 4] 	stx SND_ADBUS			; Put X on the sound bus (X = re
                             
c52c : ad8004           [ 4] 	lda SND_MODE			; Need to preserve contents of ot
c52f : 29bd             [ 2] 	and #SND_DESELECT_MASK	; Mask off mode bits
c531 : 0942             [ 2] 	ora #SND_SELSETADDR		; Select AY mode to latch a
c533 : 8d8004           [ 4] 	sta SND_MODE			; This write will process the dat
                             
c536 : 29bd             [ 2] 	and #SND_DESELECT_MASK	; Mask off mode bits
c538 : 8d8004           [ 4] 	sta SND_MODE			; This write will deselect the AY
                             	
c53b : 8c8104           [ 4] 	sty SND_ADBUS			; Put Y on the sound bus (Y = va
c53e : 0902             [ 2] 	ora #SND_SELWRITE		; Select mode for writing dat
c540 : 8d8004           [ 4] 	sta SND_MODE			; This write will process the dat
                             	
c543 : 29bd             [ 2] 	and #SND_DESELECT_MASK	; Mask off mode bits
c545 : 8d8004           [ 4] 	sta SND_MODE			; This write will deselect the AY
                             
c548 : 68               [ 4] 	pla
                             	
c549 : 60               [ 6] 	rts
AS65 Assembler for R6502 [1.42].                                     Page   30
-------------------------------- bank\bank1.s --------------------------------

                             
                             ;****************************************
                             ;* snd_get
                             ;* Get AY register X to Y
                             ;* Input : X = Reg no
                             ;* Output : Y = Value
                             ;* Regs affected : None
                             ;****************************************
c54a :                       snd_get
c54a : 48               [ 3] 	pha
                             
c54b : a9ff             [ 2] 	lda #0xff				; Set Port A to output
c54d : 8d8304           [ 4] 	sta IO_1 + DDRA
                             
c550 : 8e8104           [ 4] 	stx SND_ADBUS			; Put X on the sound bus (X = re
                             
c553 : ad8004           [ 4] 	lda SND_MODE			; Need to preserve contents of ot
c556 : 29bd             [ 2] 	and #SND_DESELECT_MASK	; Mask off mode bits
c558 : 0942             [ 2] 	ora #SND_SELSETADDR		; Select AY mode to latch a
c55a : 8d8004           [ 4] 	sta SND_MODE			; This write will process the dat
                             
c55d : 29bd             [ 2] 	and #SND_DESELECT_MASK	; Mask off mode bits
c55f : 8d8004           [ 4] 	sta SND_MODE			; This write will deselect the AY
                             
c562 : a900             [ 2] 	lda #0x00				; Set Port A to input
c564 : 8d8304           [ 4] 	sta IO_1 + DDRA
                             
c567 : ad8004           [ 4] 	lda SND_MODE			; Need to preserve contents of ot
c56a : 29bd             [ 2] 	and #SND_DESELECT_MASK	; Mask off mode bits
c56c : 0940             [ 2] 	ora #SND_SELREAD		; Select mode for reading data
c56e : 8d8004           [ 4] 	sta SND_MODE			; This write will process the dat
                             
c571 : ac8104           [ 4] 	ldy SND_ADBUS			; Get value in to Y
                             	
c574 : 29bd             [ 2] 	and #SND_DESELECT_MASK	; Mask off mode bits
c576 : 8d8004           [ 4] 	sta SND_MODE			; This write will deselect the AY
                             
c579 : 68               [ 4] 	pla
                             	
c57a : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* snd_get_joy0
                             ;* Return value of joystick 0
                             ;* Input : None
                             ;* Output : Y = Value
                             ;* Regs affected : X
                             ;****************************************
c57b :                       snd_get_joy0
c57b : a20f             [ 2] 	ldx #SND_REG_IOB		; Joystick is plugged in to IO
c57d : 204ac5           [ 6] 	jsr snd_get				; Get IOB, result in Y
c580 : 60               [ 6] 	rts
                             
                             	include "kernel\main.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
AS65 Assembler for R6502 [1.42].                                     Page   31
-------------------------------- bank\bank1.s --------------------------------

                             ;*  MAIN.S
                             ;*  This is where the main user program is execut
                             ;*  the 'kernel' once the system is initialised a
                             ;*  Today, main does very little - first shows th
                             ;*  boot up message, and then passes control to d
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
c581 :                       main
                             	_println msg_hello_world
                             
                             
c58e :                       infinity
c58e : 2046c0           [ 6] 	jsr _df_pg_dflat
c591 : 4c8ec5           [ 3] 	jmp infinity
                             
c594 :                       msg_hello_world
                             	;* build.s is generate by the assemble.bat file
                             	;* all it does is echo an assembler line to
                             	;* including the build date in the message.
                             	include "kernel\build.s"
c594 : 4275696c64203a..       db "Build : 25/10/2020\r" 
c5a7 : 424243202d2031..       db "BBC - 128K Breadboard Computer\r" 
c5c6 : 42792040363530..       db "By @6502Nerd (Dolo Miah)\r" 
c5df : 436f7079726967..       db "Copyright (c) 2015-20\r\r",0 
                             
                             
                             	include "kernel\irq.s"
                             	
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  IRQ.S
                             ;*	This is the IRQ handler - handles both the ver
                             ;*  blank interrupt from the VDP as well as softw
                             ;*  
                             ;*  As the handler has to be in every bank and it
                             ;*  accesses the VDP, then low level VDP routines
                             ;*  bundled in this file to ensure they are alway
                             ;*  without a bank switch being needed (which is 
                             ;************************************************
                             
                             ;* Obviously this can only be done with
                             ;* interrupts disabled!
c5f7 :                       init_irq
                             	; Core IRQ handler
c5f7 : a931             [ 2] 	lda #lo(irq)
c5f9 : 8502             [ 3] 	sta int_irq
c5fb : a9c6             [ 2] 	lda #hi(irq)
c5fd : 8503             [ 3] 	sta int_irq+1
                             	
                             	; Core BRK handler
c5ff : a95f             [ 2] 	lda #lo(irq_brk)
c601 : 8504             [ 3] 	sta int_brk
AS65 Assembler for R6502 [1.42].                                     Page   32
-------------------------------- bank\bank1.s --------------------------------

c603 : a9c6             [ 2] 	lda #hi(irq_brk)
c605 : 8505             [ 3] 	sta int_brk+1
                             
                             	; User handlers for VDP, PIA0, PIA1 interrupts
c607 : a930             [ 2] 	lda #lo(null_handler)
c609 : 8506             [ 3] 	sta int_uservdp
c60b : a9c6             [ 2] 	lda #hi(null_handler)
c60d : 8507             [ 3] 	sta int_uservdp+1
                             
c60f : a930             [ 2] 	lda #lo(null_handler)
c611 : 8508             [ 3] 	sta int_usercia0
c613 : a9c6             [ 2] 	lda #hi(null_handler)
c615 : 8509             [ 3] 	sta int_usercia0+1
                             
c617 : a930             [ 2] 	lda #lo(null_handler)
c619 : 850a             [ 3] 	sta int_usercia1
c61b : a9c6             [ 2] 	lda #hi(null_handler)
c61d : 850b             [ 3] 	sta int_usercia1+1
                             
c61f : 60               [ 6] 	rts
                             
                             ;* Calls the master IRQ handler
c620 :                       call_irq_master
c620 : 6c0200           [ 6] 	jmp (int_irq)
                             	
                             ;* Calls the BRK handler
c623 :                       call_irq_brk
c623 : 6c0400           [ 6] 	jmp (int_brk)
                             
                             ;* Call the userVDP handler
c626 :                       call_irq_uservdp
c626 : 6c0600           [ 6] 	jmp (int_uservdp)
                             	
                             ;* Call the user CIA0 handler
c629 :                       call_irq_usercia0
c629 : 6c0800           [ 6] 	jmp (int_usercia0)
                             
                             ;* Call the user CIA1 handler
c62c :                       call_irq_usercia1
c62c : 6c0a00           [ 6] 	jmp (int_usercia1)
                             	
                             ;* null interrupt
c62f :                       null_irq
c62f : 40               [ 6] 	rti
                             
                             ;* null handler
c630 :                       null_handler
c630 : 60               [ 6] 	rts
                             	
                             
                             ;* Master IRQ handler
c631 :                       irq
                             	_pushAXY
                             
                             
                             	; Check if IRQ or BRK
                             	; load P from stack in to A
c634 : ba               [ 2] 	tsx
c635 : bd0401           [ 4] 	lda 0x104,x
                             	; BRK bit set?
c638 : 2910             [ 2] 	and #0x10
c63a : d0e7             [ 3] 	bne call_irq_brk
AS65 Assembler for R6502 [1.42].                                     Page   33
-------------------------------- bank\bank1.s --------------------------------

                             	
c63c : 18               [ 2] 	clc						; Standard behaviour
                             	
                             	;* Try PIA1 first for rapid Timer handling
c63d : ad8d04           [ 4] 	lda IO_1 + IFR
c640 : 1003             [ 3] 	bpl irq_check_vdp
c642 : 202cc6           [ 6] 	jsr call_irq_usercia1	; Call user cia1 handler
                             
                             	;* Try VDP next
c645 :                       irq_check_vdp	
c645 : ad0105           [ 4] 	lda VDP_STATUS			; Read status register
c648 : 1009             [ 3] 	bpl	irq_check_cia0		; Skip if not VBLANK
c64a : 2026c6           [ 6] 	jsr call_irq_uservdp	; Call use VDP handler
c64d : 20acc6           [ 6] 	jsr int_vdp_handler		; Call  OS VDP handler
c650 : 208ac6           [ 6] 	jsr int_kb_handler		; Call OS cia0 handler (keyb
                             
                             	;* Try VIA0 last as it's keyboard (low speed)
c653 :                       irq_check_cia0
c653 : ad0d04           [ 4] 	lda IO_0 + IFR
c656 : 1003             [ 3] 	bpl irq_fin
c658 : 2029c6           [ 6] 	jsr call_irq_usercia0	; Call user cia0 handler
                             
c65b :                       irq_fin
                             	_pullAXY
                             
c65e : 40               [ 6] 	rti
                             	
                             ;* Handle BRK
c65f :                       irq_brk
                             	; Handle BRK
                             	; Get PCL,H minus 2 gives the BRK instruction ad
c65f : 38               [ 2] 	sec
c660 : bd0501           [ 4] 	lda 0x0105,x
c663 : e902             [ 2] 	sbc #2
c665 : 85ab             [ 3] 	sta df_brkpc
c667 : bd0601           [ 4] 	lda 0x0106,x
c66a : e900             [ 2] 	sbc #0
c66c : 85ac             [ 3] 	sta df_brkpc+1
                             	; Get the byte pointed to by old PC
                             	; which is 1 on from the BRK
c66e : a001             [ 2] 	ldy #1
c670 : b1ab             [ 5] 	lda (df_brkpc),y
c672 : 85ad             [ 3] 	sta df_brkval
c674 : 85a6             [ 3] 	sta errno
                             	; now update the return address
c676 : a5a9             [ 3] 	lda df_pc
c678 : 9d0501           [ 5] 	sta 0x105,x
c67b : a5aa             [ 3] 	lda df_pc+1
c67d : 9d0601           [ 5] 	sta 0x106,x
                             	
                             	_pullAXY
                             
                             	; Save the registers in temp area
c683 : 858e             [ 3] 	sta num_a
c685 : 868f             [ 3] 	stx num_a+1
c687 : 8490             [ 3] 	sty num_a+2
                             	; when RTI occurs:
                             	;  will return to error handler
                             	;  df_brkval will contain signature
c689 : 40               [ 6] 	rti
                             	
                             ;****************************************
AS65 Assembler for R6502 [1.42].                                     Page   34
-------------------------------- bank\bank1.s --------------------------------

                             ;* int_kb_handler
                             ;* Keyboard interrupt handler
                             ;****************************************
c68a :                       int_kb_handler	
c68a : a533             [ 3] 	lda kb_deb				; If keyboard pressed is debounce 
c68c : d00d             [ 3] 	bne int_skip_scan		; If not zero, then don't che
c68e : ad0d04           [ 4] 	lda IO_0 + IFR			; Check status register CIA0
c691 : 2901             [ 2] 	and #IFR_CA2			; Keyboard pressed?
c693 : f00c             [ 3] 	beq int_keys_up
c695 :                       int_do_read
c695 : 8538             [ 3] 	sta kb_pressed			; Put non-zero in to this flag
c697 : a537             [ 3] 	lda kb_debounce			; Set debounce
c699 : 8533             [ 3] 	sta kb_deb
c69b :                       int_skip_scan
c69b : a901             [ 2] 	lda #IFR_CA2			; Clear CA2
c69d : 8d0d04           [ 4] 	sta IO_0 + IFR
c6a0 : 60               [ 6] 	rts
c6a1 :                       int_keys_up					; No key pressed
c6a1 : 642f             [ 3] 	stz kb_raw				; Using 65c02 stz opcode
c6a3 : 6430             [ 3] 	stz kb_last
c6a5 : 6431             [ 3] 	stz kb_code
c6a7 : 6433             [ 3] 	stz kb_deb
c6a9 : 6434             [ 3] 	stz kb_rep
c6ab : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* int_vdp_handler
                             ;* VDP interrupt handler
                             ;****************************************
c6ac :                       int_vdp_handler
c6ac : 20d7c6           [ 6] 	jsr update_timers	; If it is then update system 
c6af : a50f             [ 3] 	lda vdp_curoff		; Is cursor enabled?
c6b1 : d023             [ 3] 	bne int_vdp_fin		; Skip if so
c6b3 : a910             [ 2] 	lda #VDP_FLASH		; Check bit 5 of low timer
c6b5 : 250c             [ 3] 	and vdp_cnt
c6b7 : c510             [ 3] 	cmp vdp_curstat		; Same as curent state?
c6b9 : f01b             [ 3] 	beq int_vdp_fin		; If so no change required
c6bb : 8510             [ 3] 	sta vdp_curstat		; Save new state
                             
c6bd : 18               [ 2] 	clc					; Add offset for cursor address in vram
c6be : a528             [ 3] 	lda gr_scrngeom+gr_cur_ptr
c6c0 : 6525             [ 3] 	adc gr_scrngeom+gr_cur_off
c6c2 : aa               [ 2] 	tax
c6c3 : a529             [ 3] 	lda gr_scrngeom+gr_cur_ptr+1
c6c5 : 6900             [ 2] 	adc #0
                             
c6c7 : 20e3c4           [ 6] 	jsr vdp_wr_addr
                             	
c6ca : a50c             [ 3] 	lda vdp_cnt			; Use counter to determine normal/
c6cc : 0a               [ 2] 	asl a				; Move bit 4 to bit 7 to create inverse
c6cd : 0a               [ 2] 	asl a
c6ce : 0a               [ 2] 	asl a
c6cf : 2980             [ 2] 	and #0x80			; Only top bit is what we want
c6d1 : 4511             [ 3] 	eor vdp_curval		; EOR top bit with what is under
c6d3 : 2009c5           [ 6] 	jsr vdp_wr_vram
c6d6 :                       int_vdp_fin	
c6d6 : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* update_timers
                             ;* Update 24 bit timer and debounce counters
AS65 Assembler for R6502 [1.42].                                     Page   35
-------------------------------- bank\bank1.s --------------------------------

                             ;****************************************
c6d7 :                       update_timers
c6d7 : e60c             [ 5] 	inc vdp_cnt
c6d9 : d006             [ 3] 	bne inc_kb_timers
c6db : e60d             [ 5] 	inc vdp_cnt_hi
c6dd : d002             [ 3] 	bne inc_kb_timers
c6df : e60e             [ 5] 	inc vdp_cnt_hi2
c6e1 :                       inc_kb_timers
c6e1 : a633             [ 3] 	ldx kb_deb			; Is debounce 0?
c6e3 : f002             [ 3] 	beq skip_kb_deb
c6e5 : c633             [ 5] 	dec kb_deb
c6e7 :                       skip_kb_deb
c6e7 : a634             [ 3] 	ldx kb_rep			; Is repeat timer 0?
c6e9 : f002             [ 3] 	beq skip_kb_rep
c6eb : c634             [ 5] 	dec kb_rep
c6ed :                       skip_kb_rep
c6ed : 60               [ 6] 	rts
                             	
                             
                             	include "utils\misc.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  MISC.S
                             ;*  Miscellaneous module for commmon utility func
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             
                             ;****************************************
                             ;* long_delay
                             ;* Long delay (X decremented every 0.125ms)
                             ;* Input : X = number of 0.125ms ticks to wait (m
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
c6ee :                       long_delay
c6ee : 08               [ 3] 	php
                             	_pushAXY
                             
                             	
c6f2 : a000             [ 2] 	ldy #0x00
c6f4 :                       long_delay_1
c6f4 : ea               [ 2] 	nop
c6f5 : ea               [ 2] 	nop
c6f6 : ea               [ 2] 	nop
c6f7 : ea               [ 2] 	nop
c6f8 : 88               [ 2] 	dey
c6f9 : d0f9             [ 3] 	bne long_delay_1
c6fb : ca               [ 2] 	dex
c6fc : d0f6             [ 3] 	bne long_delay_1
                             
                             	_pullAXY
                             
c701 : 28               [ 4] 	plp
AS65 Assembler for R6502 [1.42].                                     Page   36
-------------------------------- bank\bank1.s --------------------------------

                             	
c702 : 60               [ 6] 	rts
                             
                             
                             	include "utils\utils.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  UTILS.S
                             ;*  This module implements various utility functi
                             ;*  converting from ASCII to binary form for numb
                             ;*  vice-versa to allow humans to actually be abl
                             ;*  and read numbers in their prefered form!
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             
c703 :                       jsrPrintA
c703 : 48               [ 3] 	pha
c704 : da               [ 3] 	phx
c705 : 2022c7           [ 6] 	jsr str_a_to_x
c708 : 2049c4           [ 6] 	jsr io_put_ch
c70b : 8a               [ 2] 	txa
c70c : 2049c4           [ 6] 	jsr io_put_ch
c70f : fa               [ 4] 	plx
c710 : 68               [ 4] 	pla
c711 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* util_clr_mem
                             ;* Clear a block of main ram
                             ;* Input : X, A = Block start, Y = Block size
                             ;* Regs affected : P
                             ;****************************************
c712 :                       util_clr_mem
c712 : 48               [ 3] 	pha
c713 : 5a               [ 3] 	phy
c714 : 8639             [ 3] 	stx tmp_alo
c716 : 853a             [ 3] 	sta tmp_ahi
c718 : a900             [ 2] 	lda #0
c71a :                       mem_clr_byte
c71a : 88               [ 2] 	dey
c71b : 9139             [ 5] 	sta (tmp_alo),y
c71d : d0fb             [ 3] 	bne mem_clr_byte
c71f : 7a               [ 4] 	ply
c720 : 68               [ 4] 	pla
c721 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* str_a_to_x
                             ;* Convert accumulator to hex string
                             ;* Input : A = Byte to convert
                             ;* Output : A = High Char, X = Low Char
                             ;* Regs affected : P
                             ;****************************************
AS65 Assembler for R6502 [1.42].                                     Page   37
-------------------------------- bank\bank1.s --------------------------------

c722 :                       str_a_to_x
c722 : 48               [ 3] 	pha					; Save the byte using later on
c723 : 290f             [ 2] 	and #0x0f			; Mask low nibble
c725 : 18               [ 2] 	clc
c726 : 6930             [ 2] 	adc #'0'			; Convert to UTF
c728 : c93a             [ 2] 	cmp #('9'+1)		; If A greater than '9' then
c72a : 9002             [ 3] 	bcc skip_a_f_1		; skip a-f adjustment
c72c : 6926             [ 2] 	adc #0x26			; Add 27 (6+C) to get in to A-F rang
c72e :                       skip_a_f_1
c72e : aa               [ 2] 	tax					; Low char is in X
c72f : 68               [ 4] 	pla					; Get byte back
c730 : 4a               [ 2] 	lsr a				; Make high nibble low
c731 : 4a               [ 2] 	lsr a
c732 : 4a               [ 2] 	lsr a
c733 : 4a               [ 2] 	lsr a
c734 : 18               [ 2] 	clc
c735 : 6930             [ 2] 	adc #'0'			; Convert to UTF
c737 : c93a             [ 2] 	cmp #('9'+1)		; If A greater than '9' then
c739 : 9002             [ 3] 	bcc skip_a_f_2		; skip a-f adjustment
c73b : 6926             [ 2] 	adc #0x26			; Add 27 (6+C) to get in to A-F rang
c73d :                       skip_a_f_2
                             
c73d : 18               [ 2] 	clc					; No error
c73e : 60               [ 6] 	rts					; A high nibble
                             
                             ;****************************************
                             ;* str_x_to_a
                             ;* Convert hex string to accumulator
                             ;* Input : A = High Char, X = Low Char
                             ;* Output : A = Value
                             ;* Regs affected : P
                             ;****************************************
c73f :                       str_x_to_a
c73f : 0920             [ 2] 	ora #0x20			; Make alpha in to lower case
c741 : 38               [ 2] 	sec					; Process high char in A
c742 : e930             [ 2] 	sbc #'0'			; Convert to hex nibble
c744 : c90a             [ 2] 	cmp #10				; If A < 10 then
c746 : 9002             [ 3] 	bcc skip_x_f_1		; skip a-f adjustment
c748 : e927             [ 2] 	sbc #0x27			; Sub 7 to get in to A-F range
c74a :                       skip_x_f_1
c74a : c910             [ 2] 	cmp #0x10			; Nibble should be <= 0x0f
c74c : b01d             [ 3] 	bcs	str_x_to_a_err	; Error if not
                             
c74e : 0a               [ 2] 	asl a				; This is the high nibble
c74f : 0a               [ 2] 	asl a
c750 : 0a               [ 2] 	asl a
c751 : 0a               [ 2] 	asl a
c752 : 48               [ 3] 	pha					; Save the high nibble
c753 : 8a               [ 2] 	txa					; Now process the low char in X
c754 : 0920             [ 2] 	ora #0x20			; Make alpha in to lower case
c756 : 38               [ 2] 	sec
c757 : e930             [ 2] 	sbc #'0'			; Convert to hex nibble
c759 : c90a             [ 2] 	cmp #10				; If A < 10 then
c75b : 9002             [ 3] 	bcc skip_x_f_2		; skip a-f adjustment
c75d : e927             [ 2] 	sbc #0x27			; Sub 7 to get in to A-F range
c75f :                       skip_x_f_2
c75f : c910             [ 2] 	cmp #0x10			; Nibble should be <= 0x0f
c761 : b007             [ 3] 	bcs	str_x_to_a_errl	; Error if not
                             
c763 : 858e             [ 3] 	sta num_a			; Store low nibble in temp
c765 : 68               [ 4] 	pla					; Get high nibble
c766 : 058e             [ 3] 	ora num_a			; OR with low nibble
AS65 Assembler for R6502 [1.42].                                     Page   38
-------------------------------- bank\bank1.s --------------------------------

                             
c768 : 18               [ 2] 	clc					; No error
c769 : 60               [ 6] 	rts					; A contains value
                             
c76a :                       str_x_to_a_errl
c76a : 68               [ 4] 	pla
c76b :                       str_x_to_a_err
                             	SWBRK CMD_ERR_VAL
                             
                             
                             ;****************************************
                             ;* con_n_to_a
                             ;* Convert numeric string to accumulator (unsigne
                             ;* Input : Pointer to string (X=L, A=H), Y = Sour
                             ;* Output : num_a, num_a+1 contains word, X=numbe
                             ;* A = Source type detected
                             ;* Regs affected : CS = Error
                             ;****************************************
c76d :                       con_n_to_a
c76d : 869a             [ 3] 	stx num_tmp
c76f : 859b             [ 3] 	sta num_tmp+1
c771 : 648e             [ 3] 	stz num_a
c773 : 648f             [ 3] 	stz num_a+1
c775 : c000             [ 2] 	cpy #NUM_ANY
c777 : f014             [ 3] 	beq con_n_to_a_detect
c779 : 88               [ 2] 	dey
c77a : d003             [ 3] 	bne con_n_not_dec
c77c :                       con_dec_jmp
c77c : 4c10c8           [ 3] 	jmp con_dec_to_a_int
c77f :                       con_n_not_dec
c77f : 88               [ 2] 	dey
c780 : d003             [ 3] 	bne con_n_not_hex
c782 :                       con_hex_jmp
c782 : 4ca7c7           [ 3] 	jmp con_hex_to_a_int
c785 :                       con_n_not_hex
c785 : 88               [ 2] 	dey
c786 : d003             [ 3] 	bne con_n_err
c788 :                       con_bin_jmp
c788 : 4ce6c7           [ 3] 	jmp con_bin_to_a_int
c78b :                       con_n_err
c78b : 38               [ 2] 	sec
c78c : 60               [ 6] 	rts
c78d :                       con_n_to_a_detect
c78d : b29a             [ 5] 	lda (num_tmp)
c78f : c930             [ 2] 	cmp #'0'
c791 : d0e9             [ 3] 	bne con_dec_jmp
c793 : a001             [ 2] 	ldy #1
c795 : b19a             [ 5] 	lda (num_tmp),y
c797 : 0920             [ 2] 	ora #0x20
c799 : c978             [ 2] 	cmp #'x'
c79b : f0e5             [ 3] 	beq con_hex_jmp
c79d : c962             [ 2] 	cmp #'b'
c79f : f0e7             [ 3] 	beq con_bin_jmp
c7a1 : 80d9             [ 3] 	bra con_dec_jmp
                             
                             ;****************************************
                             ;* con_hex_to_a
                             ;* Convert hex string to accumulator (unsigned)
                             ;* Input : Pointer to string (X=L, A=H)
                             ;* Output : num_a, num_a+1 contains word, X=numbe
                             ;* Regs affected : CS = Error
                             ;****************************************
AS65 Assembler for R6502 [1.42].                                     Page   39
-------------------------------- bank\bank1.s --------------------------------

c7a3 :                       con_hex_to_a
c7a3 : 869a             [ 3] 	stx num_tmp
c7a5 : 859b             [ 3] 	sta num_tmp+1
c7a7 :                       con_hex_to_a_int
c7a7 : a205             [ 2] 	ldx #5			; > 4 digits will cause error
c7a9 : a002             [ 2] 	ldy #2			; start at first digit
c7ab :                       con_hex_digit
c7ab : b19a             [ 5] 	lda (num_tmp),y
c7ad : 0920             [ 2] 	ora #0x20					; Make alpha in to lower case
c7af : 38               [ 2] 	sec							; Process high char in A
c7b0 : e930             [ 2] 	sbc #'0'					; Convert to hex nibble
c7b2 : c90a             [ 2] 	cmp #10						; If A < 10 then
c7b4 : 9002             [ 3] 	bcc con_hex_skip_x_f_1		; skip a-f adjustment
c7b6 : e927             [ 2] 	sbc #0x27					; Sub 7 to get in to A-F range
c7b8 :                       con_hex_skip_x_f_1
c7b8 : c910             [ 2] 	cmp #0x10					; Nibble should be <= 0x0f
c7ba : b01c             [ 3] 	bcs	con_hex_done			; Potentially done if not
c7bc : 48               [ 3] 	pha
                             	; make room for lo nibble
c7bd : 068e             [ 5] 	asl num_a
c7bf : 268f             [ 5] 	rol num_a+1
c7c1 : 068e             [ 5] 	asl num_a
c7c3 : 268f             [ 5] 	rol num_a+1
c7c5 : 068e             [ 5] 	asl num_a
c7c7 : 268f             [ 5] 	rol num_a+1
c7c9 : 068e             [ 5] 	asl num_a
c7cb : 268f             [ 5] 	rol num_a+1
                             	; save in low nibble
c7cd : 68               [ 4] 	pla
c7ce : 058e             [ 3] 	ora num_a
c7d0 : 858e             [ 3] 	sta num_a
c7d2 : c8               [ 2] 	iny
c7d3 : ca               [ 2] 	dex
c7d4 : d0d5             [ 3] 	bne con_hex_digit
                             	; if got to a 5th digit then error
c7d6 :                       con_hex_err
c7d6 : 38               [ 2] 	sec
c7d7 : 60               [ 6] 	rts
                             	; found a non-hex digit
c7d8 :                       con_hex_done
                             	; if no digits processed then error
c7d8 : c002             [ 2] 	cpy #2
c7da : f0fa             [ 3] 	beq con_hex_err
                             	; move y to x for digits processed
c7dc : 98               [ 2] 	tya
c7dd : aa               [ 2] 	tax
c7de : a902             [ 2] 	lda #NUM_HEX
c7e0 : 18               [ 2] 	clc
c7e1 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* con_bin_to_a
                             ;* Convert hex string to accumulator (unsigned)
                             ;* Input : Pointer to string (X=L, A=H)
                             ;* Output : num_a, num_a+1 contains word, X=numbe
                             ;* Regs affected : CS = Error
                             ;****************************************
c7e2 :                       con_bin_to_a
c7e2 : 869a             [ 3] 	stx num_tmp
c7e4 : 859b             [ 3] 	sta num_tmp+1
c7e6 :                       con_bin_to_a_int
c7e6 : a002             [ 2] 	ldy #2
AS65 Assembler for R6502 [1.42].                                     Page   40
-------------------------------- bank\bank1.s --------------------------------

c7e8 : a211             [ 2] 	ldx #17						; Max 16 binary digits allowed
c7ea :                       con_bin_digit
c7ea : b19a             [ 5] 	lda (num_tmp),y
c7ec : c930             [ 2] 	cmp #'0'
c7ee : 9010             [ 4] 	bcc con_bin_done
c7f0 : c932             [ 2] 	cmp #'1'+1
c7f2 : b00c             [ 4] 	bcs con_bin_done
                             	; sets C if '1' else resets C
c7f4 : 69cf             [ 2] 	adc #0xff-'0'
                             	; shift in digit
c7f6 : 268e             [ 5] 	rol num_a
c7f8 : 268f             [ 5] 	rol num_a+1
c7fa : c8               [ 2] 	iny
c7fb : ca               [ 2] 	dex
c7fc : d0ec             [ 3] 	bne con_bin_digit
                             	; on the 17th digit is too much, error
c7fe : 800a             [ 4] 	bra con_bin_err
c800 :                       con_bin_done
                             	; didn't process any digit = error
c800 : c002             [ 2] 	cpy #2
c802 : f006             [ 3] 	beq con_bin_err
                             	; put digits processed in to X
c804 : 98               [ 2] 	tya
c805 : aa               [ 2] 	tax
c806 : a903             [ 2] 	lda #NUM_BIN
c808 : 18               [ 2] 	clc
c809 : 60               [ 6] 	rts
c80a :                       con_bin_err
c80a : 38               [ 2] 	sec
c80b : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* con_d_to_a
                             ;* Convert decimal string to accumulator (SIGNED)
                             ;* Input : Pointer to string (X=L, A=H)
                             ;* Output : num_a, num_a+1 contains word, X=numbe
                             ;* Regs affected : CS = Error
                             ;****************************************
c80c :                       con_dec_to_a
c80c : 869a             [ 3] 	stx num_tmp
c80e : 859b             [ 3] 	sta num_tmp+1
c810 :                       con_dec_to_a_int
c810 : a000             [ 2] 	ldy #0
                             	; Detect if leading minus sign
c812 : b29a             [ 5] 	lda (num_tmp)
c814 : c92d             [ 2] 	cmp #'-'
c816 : d001             [ 3] 	bne str_d_find_end
                             	; skip over minus if found
c818 : c8               [ 2] 	iny
c819 :                       str_d_find_end
c819 : b19a             [ 5] 	lda (num_tmp),y
c81b : c930             [ 2] 	cmp #'0'
c81d : 9007             [ 3] 	bcc str_d_found_end
c81f : c93a             [ 2] 	cmp #'9'+1
c821 : b003             [ 3] 	bcs str_d_found_end
c823 : c8               [ 2] 	iny
c824 : 80f3             [ 3] 	bra str_d_find_end
c826 :                       str_d_found_end
c826 : c006             [ 2] 	cpy #6				; Biggest int is 6 chars
c828 : b04e             [ 3] 	bcs str_d_error		; e.g. -32767
c82a : 849d             [ 3] 	sty num_tmp+3
c82c : 649c             [ 3] 	stz num_tmp+2
AS65 Assembler for R6502 [1.42].                                     Page   41
-------------------------------- bank\bank1.s --------------------------------

c82e : 648e             [ 3] 	stz num_a
c830 : 648f             [ 3] 	stz num_a+1
c832 :                       str_d_process_digit
c832 : 88               [ 2] 	dey
c833 : 3026             [ 3] 	bmi str_d_digits_done
                             
c835 : b19a             [ 5] 	lda (num_tmp),y
                             
c837 : c92d             [ 2] 	cmp #'-'			; Got to minus sign?
c839 : f020             [ 3] 	beq str_d_digits_done ; also done
                             
c83b : 38               [ 2] 	sec
c83c : e930             [ 2] 	sbc #'0'
                             	; Convert digit to number
                             	; and then offset in to
                             	; look up table of powers
c83e : 18               [ 2] 	clc
c83f : 0a               [ 2] 	asl a
c840 : 659c             [ 3] 	adc num_tmp+2
                             	; X contains index to powers
c842 : aa               [ 2] 	tax
c843 : a58e             [ 3] 	lda num_a
c845 : 7d7ac8           [ 4] 	adc str_d_powers,x
c848 : 858e             [ 3] 	sta num_a
c84a : a58f             [ 3] 	lda num_a+1
c84c : 7d7bc8           [ 4] 	adc str_d_powers+1,x
c84f : 858f             [ 3] 	sta num_a+1
c851 : b025             [ 3] 	bcs str_d_error
                             	; Move to next power of 10 index
c853 : a59c             [ 3] 	lda num_tmp+2
c855 : 6914             [ 2] 	adc #20
c857 : 859c             [ 3] 	sta num_tmp+2
c859 : 80d7             [ 3] 	bra str_d_process_digit
c85b :                       str_d_digits_done
                             	; check if minus
c85b : b29a             [ 5] 	lda (num_tmp)
c85d : c92d             [ 2] 	cmp #'-'
c85f : d011             [ 3] 	bne str_d_skip_neg
c861 : a69d             [ 3] 	ldx num_tmp+3		; Must have >= 2 chars
c863 : e002             [ 2] 	cpx #2				; else it's an error
c865 : 9011             [ 3] 	bcc str_d_error
c867 : a68e             [ 3] 	ldx num_a
c869 : a58f             [ 3] 	lda num_a+1
c86b : 20dec8           [ 6] 	jsr twos_complement
c86e : 868e             [ 3] 	stx num_a
c870 : 858f             [ 3] 	sta num_a+1
c872 :                       str_d_skip_neg
c872 : a69d             [ 3] 	ldx num_tmp+3
c874 : a901             [ 2] 	lda #NUM_DEC
c876 : 18               [ 2] 	clc
c877 : 60               [ 6] 	rts
c878 :                       str_d_error
c878 : 38               [ 2] 	sec
c879 : 60               [ 6] 	rts
                             
c87a :                       str_d_powers
c87a : 00000100020003..      	dw	0, 1, 2, 3, 4, 5, 6, 7, 8, 9
c88e : 00000a0014001e..      	dw	0, 10, 20, 30, 40, 50, 60, 70, 80, 90
c8a2 : 00006400c8002c..      	dw	0, 100, 200, 300, 400, 500, 600, 700, 800, 90
c8b6 : 0000e803d007b8..      	dw	0, 1000, 2000, 3000, 4000, 5000, 6000, 7000, 
c8ca : 00001027204e30..      	dw	0, 10000, 20000, 30000, 40000, 50000, 60000, 
                             	
AS65 Assembler for R6502 [1.42].                                     Page   42
-------------------------------- bank\bank1.s --------------------------------

                             
                             ;****************************************
                             ;* twos_complement
                             ;* Twos complement of X,A (X=low)
                             ;* Input : X = Low byte, A = High Byte to convert
                             ;* Output : X,A in 2's complement
                             ;* Regs affected : P
                             ;****************************************
c8de :                       twos_complement
c8de : 49ff             [ 2] 	eor #0xff
c8e0 : 48               [ 3] 	pha
c8e1 : 8a               [ 2] 	txa
c8e2 : 49ff             [ 2] 	eor #0xff
c8e4 : aa               [ 2] 	tax
c8e5 : 68               [ 4] 	pla
c8e6 : e8               [ 2] 	inx
c8e7 : d001             [ 3] 	bne twos_complement_skip_X
c8e9 : 1a               [ 2] 	inc a
c8ea :                       twos_complement_skip_X
c8ea : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* hex_to_bcd
                             ;* Convert accumulator,X to BCD
                             ;* Input : X = Low byte, A = High Byte to convert
                             ;* Output : 3 bytes of num_a is updated
                             ;* Regs affected : P
                             ;****************************************
c8eb :                       hex_to_bcd
c8eb : 08               [ 3] 	php
c8ec : 48               [ 3] 	pha
c8ed : da               [ 3] 	phx
                             
c8ee : 869a             [ 3] 	stx num_tmp
c8f0 : 859b             [ 3] 	sta num_tmp+1
c8f2 : c980             [ 2] 	cmp #0x80			; Negative?
c8f4 : 9003             [ 3] 	bcc hex_to_bcd_skip_neg
c8f6 : 20dec8           [ 6] 	jsr twos_complement
c8f9 :                       hex_to_bcd_skip_neg
c8f9 : 648e             [ 3] 	stz num_a
c8fb : 648f             [ 3] 	stz num_a+1
c8fd : 6490             [ 3] 	stz num_a+2
c8ff : 6491             [ 3] 	stz num_a+3
c901 : a210             [ 2] 	ldx #16
c903 : f8               [ 2] 	sed
c904 :                       bin_to_bcd_bit
c904 : 069a             [ 5] 	asl num_tmp
c906 : 269b             [ 5] 	rol num_tmp+1
c908 : a58e             [ 3] 	lda num_a
c90a : 658e             [ 3] 	adc num_a
c90c : 858e             [ 3] 	sta num_a
c90e : a58f             [ 3] 	lda num_a+1
c910 : 658f             [ 3] 	adc num_a+1
c912 : 858f             [ 3] 	sta num_a+1
c914 : a590             [ 3] 	lda num_a+2
c916 : 6590             [ 3] 	adc num_a+2
c918 : 8590             [ 3] 	sta num_a+2
c91a : ca               [ 2] 	dex
c91b : d0e7             [ 3] 	bne bin_to_bcd_bit
                             	
c91d : fa               [ 4] 	plx
AS65 Assembler for R6502 [1.42].                                     Page   43
-------------------------------- bank\bank1.s --------------------------------

c91e : 68               [ 4] 	pla
c91f : 28               [ 4] 	plp
c920 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* bcd_to_str
                             ;* Convert num_buf to chars
                             ;* Input : num_a in BCD format
                             ;* Output : num_buf in ASCII 6 digits
                             ;* Output is big endian, input is not
                             ;* Regs affected : P
                             ;****************************************
c921 :                       bcd_to_str
c921 : 48               [ 3] 	pha
c922 : da               [ 3] 	phx
c923 : 5a               [ 3] 	phy
                             
c924 : a205             [ 2] 	ldx #5						; Index in to string
c926 : a000             [ 2] 	ldy #0						; Current BCD digit
c928 :                       bcd_str
c928 : b98e00           [ 4] 	lda num_a,y
                             	; Convert 1s digit of byte
c92b : 48               [ 3] 	pha
c92c : 290f             [ 2] 	and #0xf
c92e : 18               [ 2] 	clc
c92f : 6930             [ 2] 	adc #0x30
c931 : 959e             [ 4] 	sta num_buf,x
                             	; Convert 10s digit of byte
c933 : 68               [ 4] 	pla
c934 : 4a               [ 2] 	lsr a
c935 : 4a               [ 2] 	lsr a
c936 : 4a               [ 2] 	lsr a
c937 : 4a               [ 2] 	lsr a
c938 : 18               [ 2] 	clc
c939 : 6930             [ 2] 	adc #0x30					; Convert to ASCII
c93b : 959d             [ 4] 	sta num_buf-1,x
c93d : ca               [ 2] 	dex
c93e : ca               [ 2] 	dex
c93f : c8               [ 2] 	iny
c940 : c003             [ 2] 	cpy #3						; 3 BCD digits max
c942 : d0e4             [ 3] 	bne bcd_str
                             
c944 : 7a               [ 4] 	ply
c945 : fa               [ 4] 	plx
c946 : 68               [ 4] 	pla
c947 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* out_bcd
                             ;* Output a bcd string in num_buf
                             ;* Input : num_buf has the ASCII
                             ;* Input : C=1 print leading zeros else not
                             ;* Output : num_buf in ASCII 6 digits
                             ;* Output is big endian, input is not, Y=digits p
                             ;* Regs affected : P
                             ;****************************************
c948 :                       out_bcd
c948 : 48               [ 3] 	pha
c949 : da               [ 3] 	phx
c94a : 08               [ 3] 	php
c94b : a000             [ 2] 	ldy #0						; How many digits printed
c94d : a200             [ 2] 	ldx #0						; Index in to string
AS65 Assembler for R6502 [1.42].                                     Page   44
-------------------------------- bank\bank1.s --------------------------------

c94f :                       out_bcd_digit
c94f : b59e             [ 4] 	lda num_buf,x
c951 : c000             [ 2] 	cpy #0						; If not in leading zero mode
c953 : d008             [ 3] 	bne out_bcd_print			; No then go print
                             
c955 : c930             [ 2] 	cmp #'0'					; else check if zero
c957 : d004             [ 3] 	bne out_bcd_print			; No then go print
                             
c959 : 28               [ 4] 	plp
c95a : 08               [ 3] 	php
c95b : 9004             [ 3] 	bcc out_bcd_next			; If C=0 go to next digit, el
c95d :                       out_bcd_print
c95d : c8               [ 2] 	iny
c95e : 2049c4           [ 6] 	jsr io_put_ch
c961 :                       out_bcd_next
c961 : e8               [ 2] 	inx
c962 : e006             [ 2] 	cpx #6
c964 : d0e9             [ 3] 	bne out_bcd_digit
c966 : c000             [ 2] 	cpy #0						; If nothing printed
c968 : d006             [ 3] 	bne out_bcd_fin
c96a : a930             [ 2] 	lda #'0'					; Need to put out 1 zero
c96c : 2049c4           [ 6] 	jsr io_put_ch
c96f : c8               [ 2] 	iny
c970 :                       out_bcd_fin
c970 : 28               [ 4] 	plp
c971 : fa               [ 4] 	plx
c972 : 68               [ 4] 	pla
c973 : 18               [ 2] 	clc
c974 : 60               [ 6] 	rts
                             	
                             	
                             ;****************************************
                             ;* print_a_to_d
                             ;* Convert X,A to decimal string
                             ;* Input : X,A = number Low,High
                             ;* Input : C=1 print leading zeros else not
                             ;* Output : num_buf in ASCII max 6 digits
                             ;*          Y=digits printed including sign
                             ;* Output is big endian, input is not
                             ;* Regs affected : P
                             ;****************************************
c975 :                       print_a_to_d
c975 : 08               [ 3] 	php
c976 : 8980             [ 2] 	bit #0x80					; Check if sign bit is set
c978 : 1014             [ 3] 	bpl print_a_to_d_skip_neg	; Skip if not (postive
c97a : 20dec8           [ 6] 	jsr twos_complement			; Flip from 2s complement
c97d : a92d             [ 2] 	lda #'-'
c97f : 2049c4           [ 6] 	jsr io_put_ch
c982 : 20ebc8           [ 6] 	jsr hex_to_bcd				; Convert to BCD
c985 : 2021c9           [ 6] 	jsr bcd_to_str				; Convert BCD to string
c988 : 28               [ 4] 	plp							; Leading zeros preference
c989 : 2048c9           [ 6] 	jsr out_bcd
c98c : c8               [ 2] 	iny							; Account for sign
c98d : 60               [ 6] 	rts
c98e :                       print_a_to_d_skip_neg
c98e : 20ebc8           [ 6] 	jsr hex_to_bcd				; Convert to BCD
c991 : 2021c9           [ 6] 	jsr bcd_to_str				; Convert BCD to string
c994 : 28               [ 4] 	plp							; Leading zeros preference
c995 : 4c48c9           [ 3] 	jmp out_bcd					; Print +ve string
                             
                             
                             ;* Reset vector points here - 6502 starts here
AS65 Assembler for R6502 [1.42].                                     Page   45
-------------------------------- bank\bank1.s --------------------------------

c998 :                       init
                             ;	jmp init_test
                             	; First clear ram
                             ;	sei					; No need as disabled on startup
c998 : 4ccec9           [ 3] 	jmp init_ram		; jmp not jsr to ram initialiser
c99b :                       init_2					; init_ram will jump back to here
c99b : a2ff             [ 2] 	ldx #0xff			; Initialise stack pointer
c99d : 9a               [ 2] 	txs
                             ;	cld					; No need as disabled on startup
                             	
c99e : 20a4c9           [ 6] 	jsr kernel_init
                             
c9a1 : 4c81c5           [ 3] 	jmp main
                             
c9a4 :                       kernel_init
c9a4 : 20f7c5           [ 6] 	jsr init_irq		; Initialise IRQ handling
c9a7 : 207ec1           [ 6] 	jsr _init_acia		; initialise the serial chip
                             	
c9aa : 2096c1           [ 6] 	jsr _init_cia0		; initialise cia 0
c9ad : 20aec1           [ 6] 	jsr _init_cia1		; initialise cia 1
                             
c9b0 :                       kernel_test
c9b0 : 20f6c1           [ 6] 	jsr _init_snd		; initialise the sound chip
c9b3 : 200ec2           [ 6] 	jsr _init_keyboard	; initialise keyboard timer s
c9b6 : 20eec3           [ 6] 	jsr _vdp_init		; initialise vdp
c9b9 : a900             [ 2] 	lda #0				; Default = 40 column mode
c9bb : 2066c1           [ 6] 	jsr _gr_init_screen
c9be : 2006c4           [ 6] 	jsr io_init			; Set default input/output device
c9c1 : 20dec1           [ 6] 	jsr _init_sdcard	; initialise the sd card interf
c9c4 : 20c6c1           [ 6] 	jsr _init_fs		; initialise the filesystem
c9c7 : 640c             [ 3] 	stz vdp_cnt
c9c9 : 202ec0           [ 6] 	jsr _df_init		; Initialise interpreter
                             
c9cc : 58               [ 2] 	cli					; irq interrupts enable
                             
c9cd : 60               [ 6] 	rts
                             
                             	
                             ;* Initialises RAM, skipping pages 4-8 which are 
                             ;* Zeroes all addressable RAM in the default bank
c9ce :                       init_ram
c9ce : 6400             [ 3] 	stz 0x00			; Start at page 0
c9d0 : 6401             [ 3] 	stz 0x01
c9d2 : a002             [ 2] 	ldy #0x02			; But Y initially at 2 to not overwr
c9d4 : a200             [ 2] 	ldx #0x00			; Page counter starts at zero
c9d6 :                       init_ram_1
c9d6 : e004             [ 2] 	cpx	#4				; Page <4 is ok
c9d8 : 9006             [ 3] 	bcc init_ram_fill
c9da : e008             [ 2] 	cpx #8				; Page >=8 is ok
c9dc : b002             [ 3] 	bcs init_ram_fill
c9de : 800a             [ 3] 	bra init_ram_skip
c9e0 :                       init_ram_fill
c9e0 : a900             [ 2] 	lda #0				; Normal RAM filled with zero
c9e2 : e0c0             [ 2] 	cpx #0xc0			; but page 0xC0-0xFF copied from ROM
c9e4 : 9002             [ 3] 	bcc init_ram_zero
c9e6 : b100             [ 5] 	lda (0x00),y		; Read from ROM area
c9e8 :                       init_ram_zero
c9e8 : 9100             [ 5] 	sta (0x00),y		; Write byte to RAM (zero or copy 
c9ea :                       init_ram_skip
c9ea : c8               [ 2] 	iny
c9eb : d0e9             [ 3] 	bne init_ram_1		; Do a whole page
c9ed : e601             [ 5] 	inc 0x01			; Increase page pointer
AS65 Assembler for R6502 [1.42].                                     Page   46
-------------------------------- bank\bank1.s --------------------------------

c9ef : e8               [ 2] 	inx					; Reduce page count
c9f0 : e000             [ 2] 	cpx #0x00			; Do all pages until page 0xff done 
c9f2 : d0e2             [ 3] 	bne init_ram_1
                             	
c9f4 : 4c9bc9           [ 3] 	jmp init_2			; Carry on initialisation
                             
                             ; 6502 Non-maskable interrupt come here
c9f7 :                       nmi
c9f7 : 40               [ 6] 	rti
                             
c9f8 :                       mod_sz_kernel_e
                             
                             
                             	
                             ; Bank specific code goes here
                             	include "utils\intmath.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  INTMATH.S
                             ;*  Core module for integer maths supported by df
                             ;*  Now supports signed integers in 2s complement
                             ;*  Uses the intmath registers: num_a, num_b, num
                             ;*  Most inputs are through num_a and num_b, with
                             ;*  num_a
                             ;*  Operations: add, sub, swap, 8 bit mult, mult,
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             
                             ;****************************************
                             ;* Add : A + B result in A
                             ;****************************************
c9f8 :                       int_add
c9f8 : 18               [ 2] 	clc
c9f9 : a58e             [ 3] 	lda num_a
c9fb : 6592             [ 3] 	adc num_b
c9fd : 858e             [ 3] 	sta num_a
c9ff : a58f             [ 3] 	lda num_a+1
ca01 : 6593             [ 3] 	adc num_b+1
ca03 : 858f             [ 3] 	sta num_a+1
ca05 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* Sub : A - B result in A
                             ;****************************************
ca06 :                       int_sub
ca06 : 38               [ 2] 	sec
ca07 : a58e             [ 3] 	lda num_a
ca09 : e592             [ 3] 	sbc num_b
ca0b : 858e             [ 3] 	sta num_a
ca0d : a58f             [ 3] 	lda num_a+1
ca0f : 6593             [ 3] 	adc num_b+1
ca11 : 858f             [ 3] 	sta num_a+1
ca13 : 60               [ 6] 	rts
AS65 Assembler for R6502 [1.42].                                     Page   47
-------------------------------- bank\bank1.s --------------------------------

                             	
                             ;****************************************
                             ;* Swp : A <-> B 
                             ;****************************************
ca14 :                       int_swp
ca14 : a58e             [ 3] 	lda num_a
ca16 : a692             [ 3] 	ldx num_b
ca18 : 8592             [ 3] 	sta num_b
ca1a : 868e             [ 3] 	stx num_a
ca1c : a58f             [ 3] 	lda num_a+1
ca1e : a693             [ 3] 	ldx num_b+1
ca20 : 8593             [ 3] 	sta num_b+1
ca22 : 868f             [ 3] 	stx num_a+1
ca24 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* Mult : A * B result in A
                             ;* B assumed to be an 8 bit quantity 
                             ;****************************************
ca25 :                       int_fast_mult
                             	_cpyZPWord num_a,num_tmp
                             
ca2d : 648e             [ 3] 	stz num_a
ca2f : 648f             [ 3] 	stz num_a+1
ca31 : a008             [ 2] 	ldy #8
ca33 :                       int_fast_mult_cycle
ca33 : 4692             [ 5] 	lsr num_b
ca35 : 900d             [ 3] 	bcc int_fast_mult_next
ca37 : 18               [ 2] 	clc
ca38 : a58e             [ 3] 	lda num_a
ca3a : 659a             [ 3] 	adc num_tmp
ca3c : 858e             [ 3] 	sta num_a
ca3e : a58f             [ 3] 	lda num_a+1
ca40 : 659b             [ 3] 	adc num_tmp+1
ca42 : 858f             [ 3] 	sta num_a+1
ca44 :                       int_fast_mult_next
ca44 : 069a             [ 5] 	asl num_tmp
ca46 : 269b             [ 5] 	rol num_tmp+1
ca48 : 88               [ 2] 	dey
ca49 : d0e8             [ 3] 	bne int_fast_mult_cycle
ca4b : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* Mult : A * B result in A
                             ;****************************************
ca4c :                       int_mult
                             	_cpyZPWord num_a,num_tmp
                             
ca54 : 648e             [ 3] 	stz num_a
ca56 : 648f             [ 3] 	stz num_a+1
ca58 : a010             [ 2] 	ldy #16
ca5a :                       int_mult_cycle
ca5a : 4693             [ 5] 	lsr num_b+1
ca5c : 6692             [ 5] 	ror num_b
ca5e : 900d             [ 3] 	bcc int_mult_next
ca60 : 18               [ 2] 	clc
ca61 : a58e             [ 3] 	lda num_a
ca63 : 659a             [ 3] 	adc num_tmp
ca65 : 858e             [ 3] 	sta num_a
ca67 : a58f             [ 3] 	lda num_a+1
ca69 : 659b             [ 3] 	adc num_tmp+1
ca6b : 858f             [ 3] 	sta num_a+1
AS65 Assembler for R6502 [1.42].                                     Page   48
-------------------------------- bank\bank1.s --------------------------------

ca6d :                       int_mult_next
ca6d : 069a             [ 5] 	asl num_tmp
ca6f : 269b             [ 5] 	rol num_tmp+1
ca71 : 88               [ 2] 	dey
ca72 : d0e6             [ 3] 	bne int_mult_cycle
ca74 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Div : A / B result in A, remainder X
                             ;****************************************
ca75 :                       int_div
                             	; adjust signs
ca75 : 649a             [ 3] 	stz num_tmp				; Assume all +ve
ca77 : a58f             [ 3] 	lda num_a+1				; Check A hi
ca79 : 100f             [ 3] 	bpl int_div_skip_negA
ca7b : e69a             [ 5] 	inc num_tmp				; Record sign flip
ca7d : 38               [ 2] 	sec						; 2's complement A
ca7e : a900             [ 2] 	lda #0					; by 0-A
ca80 : e58e             [ 3] 	sbc num_a				; A is now +ve
ca82 : 858e             [ 3] 	sta num_a
ca84 : a900             [ 2] 	lda #0
ca86 : e58f             [ 3] 	sbc num_a+1
ca88 : 858f             [ 3] 	sta num_a+1	
ca8a :                       int_div_skip_negA
ca8a : a593             [ 3] 	lda num_b+1				; Check B hi
ca8c : 100f             [ 3] 	bpl int_div_skip_negB
ca8e : e69a             [ 5] 	inc num_tmp				; Record sign flip
ca90 : 38               [ 2] 	sec						; 2's complement B
ca91 : a900             [ 2] 	lda #0					; by 0-B
ca93 : e592             [ 3] 	sbc num_b				; B is now +ve
ca95 : 8592             [ 3] 	sta num_b
ca97 : a900             [ 2] 	lda #0
ca99 : e593             [ 3] 	sbc num_b+1
ca9b : 8593             [ 3] 	sta num_b+1
ca9d :                       int_div_skip_negB			; num_tmp bit 0=1 for result 
                             	; x is the remainder
ca9d : 6496             [ 3] 	stz num_x
ca9f : 6497             [ 3] 	stz num_x+1
                             	; 16 bit division
caa1 : a010             [ 2] 	ldy #16
caa3 :                       int_div_cycle
                             	; shift a left 1 bit
caa3 : 068e             [ 5] 	asl num_a
caa5 : 268f             [ 5] 	rol num_a+1
                             	; shift in to remainder
caa7 : 2696             [ 5] 	rol num_x
caa9 : 2697             [ 5] 	rol num_x+1
                             	; try and subtract b from remainder
caab : 38               [ 2] 	sec
caac : a596             [ 3] 	lda num_x
caae : e592             [ 3] 	sbc num_b
cab0 : aa               [ 2] 	tax
cab1 : a597             [ 3] 	lda num_x+1
cab3 : e593             [ 3] 	sbc num_b+1
cab5 : 9006             [ 3] 	bcc int_div_skip
                             	; so b did fit in to remainder, save it
cab7 : 8696             [ 3] 	stx num_x
cab9 : 8597             [ 3] 	sta num_x+1
cabb : e68e             [ 5] 	inc num_a
cabd :                       int_div_skip
                             	; carry on for 16 bits
cabd : 88               [ 2] 	dey
AS65 Assembler for R6502 [1.42].                                     Page   49
-------------------------------- bank\bank1.s --------------------------------

cabe : d0e3             [ 3] 	bne int_div_cycle
                             	; result in a, remainder in x
                             	; check num_tmp bit 0
cac0 : a59a             [ 3] 	lda num_tmp
cac2 : 2901             [ 2] 	and #1
cac4 : f00d             [ 3] 	beq int_div_noflip
cac6 : 38               [ 2] 	sec						; 2's complement A
cac7 : a900             [ 2] 	lda #0					; by 0-A
cac9 : e58e             [ 3] 	sbc num_a				; A is now +ve
cacb : 858e             [ 3] 	sta num_a
cacd : a900             [ 2] 	lda #0
cacf : e58f             [ 3] 	sbc num_a+1
cad1 : 858f             [ 3] 	sta num_a+1	
cad3 :                       int_div_noflip
cad3 : 60               [ 6] 	rts
                             	
                             
                             	include "dflat\dflat.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  DFLAT.S
                             ;*  This is the main controller code file for dfl
                             ;*  This file includes all the required dflat sou
                             ;*  needed:
                             ;*  - error.s is the error handling module
                             ;*  - var.s is the variable handling module
                             ;*  - tokenise.s is the tokenisation module
                             ;*  - progedit.s is the program editing module
                             ;*  - runtime.s is the runtime module
                             ;*  - stack.s is the stack handling module
                             ;*  The above modules include further source file
                             ;*  needed.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
                             ;	include "dflat\error.s"  ** included in the mai
                             	include "dflat\var.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  VAR.S
                             ;*  This module handles all the variable manageme
                             ;*  When a new variable is detected during tokeni
                             ;*  is added to the variable tables.  Any subsequ
                             ;*  that variable is tokenised as an index in to 
                             ;*  table.  There are two variable tables:
                             ;*  Variable name table (VNT) keeps track of vari
                             ;*  Variable value table (VVT) maintains variable
AS65 Assembler for R6502 [1.42].                                     Page   50
-------------------------------- bank\bank1.s --------------------------------

                             ;*  including type, dimension (if array) and of c
                             ;*  actual values.  For an array, the value is a 
                             ;*  memory grabbed using the 'malloc' function (s
                             ;*  This approach to variable managemet is direct
                             ;*  Atari 8 bit.  The disadvantage is that during
                             ;*  session you may end up having a much larger v
                             ;*  table than you need.  Why?  Well because say 
                             ;*  %a as a new variable, but then later change i
                             ;*  In this case %a remains in the variable table
                             ;*  only ever adds to the table!  However it is e
                             ;*  solved - when you save and then reload from n
                             ;*  program, the variable table is built up as th
                             ;*  is loaded.
                             ;*  The VNT grows down from the top of free memor
                             ;*  the VVT growing down from just below the VNT.
                             ;*
                             ;************************************************
                             
                             
                             	; ROM code
                             	code  
                             
                             ;****************************************
                             ;* Find VVT slot given VVT index
                             ;* A = index
                             ;* Return : df_tmpptra
                             ;* CC = No error
                             ;****************************************
cad4 :                       df_var_addr
                             	; save index and multiply by 8
cad4 : 64d5             [ 3] 	stz df_tmpptra+1
                             
cad6 : 0a               [ 2] 	asl a
cad7 : 26d5             [ 5] 	rol df_tmpptra+1
                             
cad9 : 0a               [ 2] 	asl a
cada : 26d5             [ 5] 	rol df_tmpptra+1
                             
cadc : 0a               [ 2] 	asl a
cadd : 26d5             [ 5] 	rol df_tmpptra+1
cadf : 85d4             [ 3] 	sta df_tmpptra
                             
                             	; add in vvt start offset
                             	_addZPWord df_tmpptra,df_vvtstrt
                             
caee : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* Find a variable
                             ;* CC if found, A has index
                             ;****************************************
caef :                       df_var_find
                             	; start at the beginning of the vnt table
                             	_cpyZPWord df_vntstrt,df_tmpptra
                             
                             	; start at index 0
caf7 : 64d6             [ 3] 	stz df_tmpptrb
caf9 :                       df_var_match_vnt
                             	; If reached the var count then not found
caf9 : a5ba             [ 3] 	lda df_varcnt
cafb : c5d6             [ 3] 	cmp df_tmpptrb
cafd : f03c             [ 4] 	beq df_var_find_no_vnt
AS65 Assembler for R6502 [1.42].                                     Page   51
-------------------------------- bank\bank1.s --------------------------------

                             	; match each char in buffer with vnt
caff : a4c5             [ 3] 	ldy df_linoff
cb01 :                       df_var_match_vnt_sym
cb01 : b90009           [ 4] 	lda df_linbuff,y
cb04 : d2d4             [ 5] 	cmp (df_tmpptra)
cb06 : d01f             [ 3] 	bne df_var_vnt_sym_nomatch
                             	; if single char match then increment
                             	; source and search
cb08 : c8               [ 2] 	iny
                             	_incZPWord df_tmpptra
                             
                             	; if more chars in vnt entry then continue
cb0f : b2d4             [ 5] 	lda (df_tmpptra)
cb11 : d0ee             [ 3] 	bne df_var_match_vnt_sym
                             	; if no more chars in vnt entry but
                             	; but chars in buffer then try next vnt
cb13 : b90009           [ 4] 	lda df_linbuff,y
                             	; check for valid alpha-numeric
cb16 : 20b7cd           [ 6] 	jsr df_tk_isalphanum
cb19 : 9002             [ 3] 	bcc df_var_check_type
                             	; if there is a valid alpha-num then no match
cb1b : 800a             [ 3] 	bra df_var_vnt_sym_nomatch
cb1d :                       df_var_check_type
                             	; if not alpha-num then check for type
                             	; string or int postfix didn't match with VNT
cb1d : c925             [ 2] 	cmp #'%'
cb1f : f006             [ 3] 	beq df_var_vnt_sym_nomatch
cb21 : c924             [ 2] 	cmp #'$'
cb23 : f002             [ 3] 	beq df_var_vnt_sym_nomatch
                             	; ok, all good got a match
cb25 : 8020             [ 3] 	bra df_var_find_true
cb27 :                       df_var_vnt_sym_nomatch
                             	; find the zero terminator
cb27 : b2d4             [ 5] 	lda (df_tmpptra)
cb29 : f008             [ 3] 	beq	df_var_vnt_entry_end
                             	_incZPWord df_tmpptra
                             
cb31 : 80f4             [ 3] 	bra df_var_vnt_sym_nomatch
cb33 :                       df_var_vnt_entry_end
                             	; increment index
cb33 : e6d6             [ 5] 	inc df_tmpptrb
                             	; check if got to the end of the VNT
cb35 : a5ba             [ 3] 	lda df_varcnt
cb37 : c5d6             [ 3] 	cmp df_tmpptrb
cb39 : d004             [ 3] 	bne df_var_match_next_vnt
                             	; if at end then no matches found
cb3b :                       df_var_find_no_vnt
cb3b : a900             [ 2] 	lda #0
cb3d : 38               [ 2] 	sec
cb3e : 60               [ 6] 	rts
cb3f :                       df_var_match_next_vnt
                             	; skip over zero terminator
                             	_incZPWord df_tmpptra
                             
cb45 : 80b2             [ 4] 	bra df_var_match_vnt
cb47 :                       df_var_find_true
                             	; Got a match
cb47 : a5d6             [ 3] 	lda df_tmpptrb
cb49 : 84c5             [ 3] 	sty df_linoff
cb4b : 18               [ 2] 	clc
cb4c : 60               [ 6] 	rts
                             
AS65 Assembler for R6502 [1.42].                                     Page   52
-------------------------------- bank\bank1.s --------------------------------

                             	
                             ;****************************************
                             ;* General block move
                             ;* tmpptra = start of old block
                             ;* tmpptrb = block length
                             ;* tmpptrc = start of new block
                             ;****************************************
cb4d :                       df_var_block_move
                             	; if block len = 0 then move nothing
cb4d : a5d6             [ 3] 	lda df_tmpptrb
cb4f : d006             [ 3] 	bne df_var_block_move_do
cb51 : a5d7             [ 3] 	lda df_tmpptrb+1
cb53 : d002             [ 3] 	bne df_var_block_move_do
                             	; damn zero block length
cb55 : 18               [ 2] 	clc
cb56 : 60               [ 6] 	rts
cb57 :                       df_var_block_move_do
cb57 : a200             [ 2] 	ldx #0					; Bytes transferred counter hi
cb59 : a000             [ 2] 	ldy #0					; Bytes transferred counter lo
                             	; if tmpptrc < tmpptra then move from
                             	; old start to new start else
                             	; move from old end to new end
cb5b : 38               [ 2] 	sec
cb5c : a5d4             [ 3] 	lda df_tmpptra
cb5e : e5d8             [ 3] 	sbc df_tmpptrc
cb60 : a5d5             [ 3] 	lda df_tmpptra+1
cb62 : e5d9             [ 3] 	sbc df_tmpptrc+1
cb64 : 901d             [ 3] 	bcc df_var_end_to_end
                             	; ok going from start to start c++ = a++
cb66 :                       df_var_start_to_start_byte
cb66 : b2d4             [ 5] 	lda (df_tmpptra)
cb68 : 92d8             [ 5] 	sta (df_tmpptrc)
                             	_incZPWord df_tmpptra
                             
                             	_incZPWord df_tmpptrc
                             
cb76 : c8               [ 2] 	iny
cb77 : d001             [ 3] 	bne df_start_to_start_nowrap
cb79 : e8               [ 2] 	inx
cb7a :                       df_start_to_start_nowrap
cb7a : c4d6             [ 3] 	cpy df_tmpptrb
cb7c : d0e8             [ 3] 	bne df_var_start_to_start_byte
cb7e : e4d7             [ 3] 	cpx df_tmpptrb+1
cb80 : d0e4             [ 3] 	bne df_var_start_to_start_byte
                             	; done
cb82 : 60               [ 6] 	rts
cb83 :                       df_var_end_to_end
                             	; going end to end
                             	; need to adjust ptrc to be end
                             	; c = c + (b-a)
                             	; first copy b
                             	_cpyZPWord df_tmpptrb,df_tmpptrd
                             
                             	; do d-a, result in d
                             	_subZPWord df_tmpptrd,df_tmpptra
                             
                             	; now c + d, result in c
                             	_addZPWord df_tmpptrc, df_tmpptrd
                             
                             	; ok do the copy from end c-- = d--
cba5 :                       df_var_end_to_end_byte
cba5 : b2d6             [ 5] 	lda (df_tmpptrb)
AS65 Assembler for R6502 [1.42].                                     Page   53
-------------------------------- bank\bank1.s --------------------------------

cba7 : 92d8             [ 5] 	sta (df_tmpptrc)
                             	_decZPWord df_tmpptrc
                             
                             	_decZPWord df_tmpptrb
                             
cbc7 : c8               [ 2] 	iny
cbc8 : d001             [ 3] 	bne df_end_to_end_nowrap
cbca : e8               [ 2] 	inx
cbcb :                       df_end_to_end_nowrap
cbcb : c4d6             [ 3] 	cpy df_tmpptrb
cbcd : d0d6             [ 3] 	bne df_var_end_to_end_byte
cbcf : e4d7             [ 3] 	cpx df_tmpptrb+1
cbd1 : d0d2             [ 3] 	bne df_var_end_to_end_byte
                             	; done
cbd3 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* Insert a variable name in to vnt
                             ;* X = number of bytes to make room
                             ;* Requires a block move of everything
                             ;* from vvt start to vnt end
                             ;* ptrb is vnt free entry
                             ;* ptrc is vvt free entry
                             ;****************************************
cbd4 :                       df_var_insert_space
                             	; *** REMEMBER TO DO A SPACE CHECK EVENTUALLY! *
                             	
                             
                             	; Start from current vvt start
                             	_cpyZPWord df_vvtstrt,df_tmpptra
                             
                             
                             	; Length = vvt end - vvt start
                             	_cpyZPWord df_vvtend,df_tmpptrb
                             
                             	_subZPWord df_tmpptrb,df_vvtstrt
                             
                             
                             	; *vvt move* vnt size + vt size
cbf1 : 8a               [ 2] 	txa
cbf2 : 18               [ 2] 	clc
cbf3 : 6908             [ 2] 	adc #DFVVT_SZ
cbf5 : 85da             [ 3] 	sta df_tmpptrd
cbf7 : 64db             [ 3] 	stz df_tmpptrd+1
                             
                             	; New block start = vvt start - size
                             	_cpyZPWord df_vvtstrt,df_tmpptrc
                             
                             	_subZPWord df_tmpptrc,df_tmpptrd
                             
                             
                             	; vvt start = new block start
                             	_cpyZPWord df_tmpptrc,df_vvtstrt
                             
                             
                             	; Do a block move of vvt, save X first
cc16 : da               [ 3] 	phx
cc17 : 204dcb           [ 6] 	jsr df_var_block_move
cc1a : fa               [ 4] 	plx
                             	
                             	;*******************
                             	
AS65 Assembler for R6502 [1.42].                                     Page   54
-------------------------------- bank\bank1.s --------------------------------

                             	; *vnt move* vnt move size is just var name leng
cc1b : 86da             [ 3] 	stx df_tmpptrd
cc1d : 64db             [ 3] 	stz df_tmpptrd+1
                             
                             	; start from current vnt start
                             	_cpyZPWord df_vntstrt,df_tmpptra
                             
                             
                             	; Length = vnt end - vnt start
                             	_cpyZPWord df_vntend,df_tmpptrb
                             
                             	_subZPWord df_tmpptrb,df_vntstrt
                             
                             
                             	; New block start = vnt start - size
                             	_cpyZPWord df_vntstrt,df_tmpptrc
                             
                             	_subZPWord df_tmpptrc,df_tmpptrd
                             
                             
                             	; vnt start = same, vvt end = same
                             	_cpyZPWord df_tmpptrc,df_vntstrt
                             
                             	_cpyZPWord df_tmpptrc,df_vvtend
                             
                             	
                             	; Do a block move of vnt
cc61 : 204dcb           [ 6] 	jsr df_var_block_move
                             
                             	; ** SOME DEBUG PRINTING
                             
                             	; Copy done increment variable count
cc64 : e6ba             [ 5] 	inc df_varcnt
cc66 : 18               [ 2] 	clc
cc67 : 60               [ 6] 	rts
                             	
                             	
                             ;****************************************
                             ;* Analyse variable name
                             ;* Return type in A
                             ;* NOT C = It is a variable
                             ;* C = It is not a variable
                             ;* X = Length including pre-fixes
                             ;* Y = Offset to next char after var name
                             ;****************************************
cc68 :                       df_var_analyse
                             	; Default type is INT
cc68 : a901             [ 2] 	lda #DFVVT_INT
cc6a : 85d4             [ 3] 	sta df_tmpptra
                             	
                             	; start at the current buffer position
cc6c : a4c5             [ 3] 	ldy df_linoff
                             	
                             	; check for PROC prefix
cc6e : b90009           [ 4] 	lda df_linbuff,y
cc71 : c95f             [ 2] 	cmp #'_'
                             	; if it is not proc then get the name
cc73 : d005             [ 3] 	bne df_var_not_proc
                             	; else set type to PROC
cc75 : a940             [ 2] 	lda #DFVVT_PROC
cc77 : 85d4             [ 3] 	sta df_tmpptra
                             	; skip over prefix
AS65 Assembler for R6502 [1.42].                                     Page   55
-------------------------------- bank\bank1.s --------------------------------

cc79 : c8               [ 2] 	iny
cc7a :                       df_var_not_proc
                             	; found the actual number of alpha nums
cc7a : a2ff             [ 2] 	ldx #0xff
                             	; go back on pos on index as loop always does in
cc7c : 88               [ 2] 	dey
cc7d :                       df_var_type_countlen
                             	; count alpha nums
cc7d : c8               [ 2] 	iny
cc7e : e8               [ 2] 	inx
cc7f : b90009           [ 4] 	lda df_linbuff,y
                             	; first char has to be alpha, rest can be alpha-
cc82 : e000             [ 2] 	cpx #0
cc84 : d007             [ 3] 	bne df_var_type_countlen_alphanum
cc86 : 20a6cd           [ 6] 	jsr df_tk_isalpha
cc89 : b0f2             [ 3] 	bcs df_var_type_countlen
cc8b : 8005             [ 3] 	bra df_var_type_countlen_done
cc8d :                       df_var_type_countlen_alphanum
cc8d : 20b7cd           [ 6] 	jsr df_tk_isalphanum
cc90 : b0eb             [ 3] 	bcs df_var_type_countlen
cc92 :                       df_var_type_countlen_done
cc92 : e000             [ 2] 	cpx #0
cc94 : d00a             [ 3] 	bne df_var_analyse_chk_post
                             	; if zero alphanums error but not fatal
cc96 :                       df_var_analyse_err
                             	; If already prefix of PROC then fatal error
cc96 : a5d4             [ 3] 	lda df_tmpptra
cc98 : c940             [ 2] 	cmp #DFVVT_PROC
cc9a : f002             [ 3] 	beq df_var_analyse_fatal_err
cc9c : 38               [ 2] 	sec
cc9d : 60               [ 6] 	rts
cc9e :                       df_var_analyse_fatal_err
                             	SWBRK DFERR_SYNTAX
                             
cca0 :                       df_var_analyse_chk_post
                             	; first see if the char is % or $
                             	; but cannot already have PROC prefix
cca0 : c925             [ 2] 	cmp #'%'
cca2 : d00d             [ 3] 	bne df_var_analyse_chk_dollar
cca4 : a6d4             [ 3] 	ldx df_tmpptra
cca6 : e040             [ 2] 	cpx #DFVVT_PROC
cca8 : f0f4             [ 3] 	beq df_var_analyse_fatal_err
                             	; Set to INT type although it is the default alr
ccaa : a901             [ 2] 	lda #DFVVT_INT
ccac : 85d4             [ 3] 	sta df_tmpptra
                             	; advance the buffer index
ccae : c8               [ 2] 	iny
ccaf : 800f             [ 3] 	bra df_var_analyse_chk_arry
ccb1 :                       df_var_analyse_chk_dollar
                             	; now see if the char is $
                             	; but cannot already have PROC prefix
ccb1 : c924             [ 2] 	cmp #'$'
ccb3 : d00b             [ 3] 	bne df_var_analyse_chk_arry
ccb5 : a6d4             [ 3] 	ldx df_tmpptra
ccb7 : e040             [ 2] 	cpx #DFVVT_PROC
ccb9 : f0e3             [ 3] 	beq df_var_analyse_fatal_err
                             	; Set to STRING type
ccbb : a904             [ 2] 	lda #DFVVT_STR
ccbd : 85d4             [ 3] 	sta df_tmpptra
                             	; advance the buffer index
ccbf : c8               [ 2] 	iny
ccc0 :                       df_var_analyse_chk_arry
AS65 Assembler for R6502 [1.42].                                     Page   56
-------------------------------- bank\bank1.s --------------------------------

                             	; Check for array type vs PROC
ccc0 : b90009           [ 4] 	lda df_linbuff,y
ccc3 : c95b             [ 2] 	cmp #'['
ccc5 : d00a             [ 3] 	bne df_var_not_arry
                             	; array and proc type not compatible
ccc7 : a5d4             [ 3] 	lda df_tmpptra
ccc9 : c940             [ 2] 	cmp #DFVVT_PROC
cccb : f0d1             [ 3] 	beq df_var_analyse_fatal_err
cccd : 0980             [ 2] 	ora #DFVVT_ARRY
cccf : 85d4             [ 3] 	sta df_tmpptra
ccd1 :                       df_var_not_arry
                             	; Ok got everything
                             	; calculate length from y
                             	; y is next char after var name
ccd1 : 98               [ 2] 	tya
ccd2 : 38               [ 2] 	sec
ccd3 : e5c5             [ 3] 	sbc df_linoff			; where we started
                             	; put len in X
ccd5 : aa               [ 2] 	tax
                             	; put type in A
ccd6 : a5d4             [ 3] 	lda df_tmpptra
ccd8 : 18               [ 2] 	clc
ccd9 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Find or create a variable
                             ;* If found then type needs to match mask
                             ;* Not a fatal error because could be part
                             ;* of a trial of different parsing options
                             ;****************************************
ccda :                       df_var_findcreate
                             	; save mask
ccda : 48               [ 3] 	pha
                             	; save mask zero state
ccdb : c900             [ 2] 	cmp #0
ccdd : 08               [ 3] 	php
ccde : 20efca           [ 6] 	jsr df_var_find
cce1 : b011             [ 3] 	bcs df_var_findcreate_create
                             	; If found then check type with mask
                             	; save var index in X
cce3 : aa               [ 2] 	tax
                             	; restore mask state
cce4 : 28               [ 4] 	plp
                             	; don't check mask if zero
cce5 : f009             [ 3] 	beq df_var_findcreate_found
cce7 : 20d4ca           [ 6] 	jsr df_var_addr
                             	; restore mask
ccea : 68               [ 4] 	pla
cceb : 32d4             [ 5] 	and (df_tmpptra)
                             	; but if mask is non zero then and must be non z
cced : f018             [ 4] 	beq df_var_findcreate_err
ccef : 48               [ 3] 	pha
ccf0 :                       df_var_findcreate_found
                             	; discard mask
ccf0 : 68               [ 4] 	pla	
ccf1 : 8a               [ 2] 	txa					; Put index in A
ccf2 : 18               [ 2] 	clc
ccf3 : 60               [ 6] 	rts
ccf4 :                       df_var_findcreate_create
                             	; find type (A) and length (X)
ccf4 : 2068cc           [ 6] 	jsr df_var_analyse
                             	; keep A temporarily
AS65 Assembler for R6502 [1.42].                                     Page   57
-------------------------------- bank\bank1.s --------------------------------

ccf7 : 85d4             [ 3] 	sta df_tmpptra
                             	; if not a variable then return with C=1
ccf9 : b00a             [ 4] 	bcs df_var_findcreate_errp
                             	; check if mask needs to be applied
ccfb : 28               [ 4] 	plp
ccfc : f00b             [ 4] 	beq df_var_analyse_okp
                             	; else pop the mask and check
ccfe : 68               [ 4] 	pla
ccff : 25d4             [ 3] 	and df_tmpptra
                             	; mask match is ok
cd01 : d007             [ 3] 	bne df_var_analyse_ok
                             	; else return not found
cd03 : 8002             [ 3] 	bra df_var_findcreate_err
cd05 :                       df_var_findcreate_errp
cd05 : 68               [ 4] 	pla
cd06 : 68               [ 4] 	pla
cd07 :                       df_var_findcreate_err
cd07 : 38               [ 2] 	sec
cd08 : 60               [ 6] 	rts
cd09 :                       df_var_analyse_okp
cd09 : 68               [ 4] 	pla
cd0a :                       df_var_analyse_ok
cd0a : a5d4             [ 3] 	lda df_tmpptra
                             	; extra space for zero terminator
cd0c : e8               [ 2] 	inx
                             	; save data in reverse order to when needed
                             	; by the initialise section y,x,a
cd0d : 5a               [ 3] 	phy
cd0e : da               [ 3] 	phx
cd0f : 48               [ 3] 	pha
                             	; insert space of X bytes
cd10 : 20d4cb           [ 6] 	jsr df_var_insert_space
cd13 : 9002             [ 3] 	bcc df_var_initialise_var
                             	; error inserting space
                             	SWBRK DFERR_RUNTIME
                             
                             
                             	
cd17 :                       df_var_initialise_var
                             	; vvt entry = vvt end - 8
cd17 : 38               [ 2] 	sec
cd18 : a5b8             [ 3] 	lda df_vvtend
cd1a : e908             [ 2] 	sbc #8
cd1c : 85d4             [ 3] 	sta df_tmpptra
cd1e : a5b9             [ 3] 	lda df_vvtend+1
cd20 : e900             [ 2] 	sbc #0
cd22 : 85d5             [ 3] 	sta df_tmpptra+1
                             	
cd24 : 68               [ 4] 	pla						; Get type back
cd25 : 92d4             [ 5] 	sta (df_tmpptra)		; put type in vvt slot
cd27 : a900             [ 2] 	lda #0					; zero the rest
cd29 : a007             [ 2] 	ldy #7
cd2b :                       df_var_zero_vnt
cd2b : 91d4             [ 5] 	sta (df_tmpptra),y
cd2d : 88               [ 2] 	dey
cd2e : d0fb             [ 3] 	bne df_var_zero_vnt
                             
cd30 : fa               [ 4] 	plx						; Get back variable name length
cd31 : 86d6             [ 3] 	stx df_tmpptrb
                             	; vnt entry = vnt end - var name length
cd33 : 38               [ 2] 	sec
cd34 : a5b4             [ 3] 	lda df_vntend
AS65 Assembler for R6502 [1.42].                                     Page   58
-------------------------------- bank\bank1.s --------------------------------

cd36 : e5d6             [ 3] 	sbc df_tmpptrb
cd38 : 85d4             [ 3] 	sta df_tmpptra
cd3a : a5b5             [ 3] 	lda df_vntend+1
cd3c : e900             [ 2] 	sbc #0
cd3e : 85d5             [ 3] 	sta df_tmpptra+1
                             
cd40 : ca               [ 2] 	dex						; Copy one less from input buff
cd41 : a4c5             [ 3] 	ldy df_linoff			; Start at var name beginning
                             	; copy variable name to vnt slot
cd43 :                       df_var_findcreate_copy
cd43 : b90009           [ 4] 	lda df_linbuff,y
cd46 : 92d4             [ 5] 	sta (df_tmpptra)
cd48 : c8               [ 2] 	iny
                             	_incZPWord df_tmpptra
                             
cd4f : ca               [ 2] 	dex
cd50 : d0f1             [ 3] 	bne df_var_findcreate_copy
                             	; put in zero terminator
cd52 : a900             [ 2] 	lda #0
cd54 : 92d4             [ 5] 	sta (df_tmpptra)
                             
cd56 : 7a               [ 4] 	ply						; Get back y
                             	; move offset to reflect comsumed chars
cd57 : 84c5             [ 3] 	sty df_linoff
                             	; index of new variable 1 less than count
cd59 : a5ba             [ 3] 	lda df_varcnt
cd5b : 3a               [ 2] 	dec a
                             	
cd5c : 18               [ 2] 	clc
cd5d : 60               [ 6] 	rts
                             	
                             
                             	include "dflat\tokenise.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  TOKENISE.S
                             ;*  Controlling module for tokenisation.  Basical
                             ;*  module is given a raw input buffer, which it 
                             ;*  attempt to tokenise fully.  Any syntax errors
                             ;*  thrown at the first point of detection.  If a
                             ;*  well, the parsed input will be in a tokenised
                             ;*  which can be executed in immediate mode or sa
                             ;*  line number order to memory.
                             ;*  dflat syntax is very simple - every statement
                             ;*  with a keyword.  The only exception is assign
                             ;*  procedure invocation - but even these scenari
                             ;*  tokenised so during runtime we just execute t
                             ;*  The raw buffer is consumed one byte at a time
                             ;*  tokenised buffer is written one byte at a tim
                             ;*  syntax means there is no need to undo reads o
                             ;*  or tokenised buffer.  The only refinement is 
                             ;*  allowed to peek a character in the raw buffer
                             ;*  consuming it.
                             ;*
                             ;************************************************
                             
AS65 Assembler for R6502 [1.42].                                     Page   59
-------------------------------- bank\bank1.s --------------------------------

                             	; ROM code
                             	code  
                             
cd5e :                       mod_sz_tokenise_s
                             
                             
                             ;****************************************
                             ;* df_tk_peek_buf
                             ;* Return next char in A but no change to pointer
                             ;****************************************
cd5e :                       df_tk_peek_buf
cd5e : a4c5             [ 3] 	ldy df_linoff
cd60 : b90009           [ 4] 	lda df_linbuff,y
cd63 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* df_tk_get_buf
                             ;* Return next char in A and inc pointer
                             ;* Don't advance if null char found and Z=1
                             ;****************************************
cd64 :                       df_tk_get_buf
cd64 : a4c5             [ 3] 	ldy df_linoff
cd66 : b90009           [ 4] 	lda df_linbuff,y
cd69 : f003             [ 3] 	beq df_tk_get_buf_null
cd6b : c8               [ 2] 	iny
cd6c : 84c5             [ 3] 	sty df_linoff
cd6e :                       df_tk_get_buf_null
cd6e : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* df_tk_put_tok
                             ;* Put A in token buffer and inc pointer
                             ;****************************************
cd6f :                       df_tk_put_tok
cd6f : a4c6             [ 3] 	ldy df_tokoff
cd71 : 998009           [ 5] 	sta df_tokbuff,y
cd74 : c8               [ 2] 	iny
cd75 : 84c6             [ 3] 	sty df_tokoff
cd77 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* df_tk_isdigit
                             ;* Check char in A for number 0-9
                             ;* Return: CC = False, CS = True
                             ;****************************************
cd78 :                       df_tk_isdigit
cd78 : c930             [ 2] 	cmp #'0'
cd7a : 9006             [ 3] 	bcc df_tk_isdigit_false
cd7c : c93a             [ 2] 	cmp #'9'+1
cd7e : b002             [ 3] 	bcs df_tk_isdigit_false
cd80 : 38               [ 2] 	sec
cd81 : 60               [ 6] 	rts
cd82 :                       df_tk_isdigit_false
cd82 : 18               [ 2] 	clc
cd83 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* df_tk_isbin
                             ;* Check char in A for binary digit
                             ;* Return: CC = False, CS = True
                             ;****************************************
cd84 :                       df_tk_isbin
AS65 Assembler for R6502 [1.42].                                     Page   60
-------------------------------- bank\bank1.s --------------------------------

cd84 : c930             [ 2] 	cmp #'0'
cd86 : f006             [ 3] 	beq df_tk_isbin_true
cd88 : c931             [ 2] 	cmp #'1'
cd8a : f002             [ 3] 	beq df_tk_isbin_true
cd8c : 18               [ 2] 	clc
cd8d : 60               [ 6] 	rts
cd8e :                       df_tk_isbin_true
cd8e : 38               [ 2] 	sec
cd8f : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* df_tk_ishex
                             ;* Check char in A for number 0-9, A-F, a-f
                             ;* Return: CC = False, CS = True
                             ;****************************************
cd90 :                       df_tk_ishex
cd90 : 48               [ 3] 	pha
cd91 : 2078cd           [ 6] 	jsr df_tk_isdigit
cd94 : b00b             [ 3] 	bcs df_tk_ishex_truep
cd96 : 0920             [ 2] 	ora #0x20
cd98 : c961             [ 2] 	cmp #'a'
cd9a : 9007             [ 3] 	bcc df_tk_ishex_false
cd9c : c967             [ 2] 	cmp #'f'+1
cd9e : b003             [ 3] 	bcs df_tk_ishex_false
cda0 :                       df_tk_ishex_true
cda0 : 38               [ 2] 	sec
cda1 :                       df_tk_ishex_truep
cda1 : 68               [ 4] 	pla
cda2 : 60               [ 6] 	rts
cda3 :                       df_tk_ishex_false
cda3 : 18               [ 2] 	clc
cda4 : 68               [ 4] 	pla
cda5 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* df_tk_isalpha
                             ;* Check next char in A alpha a-z, A-Z
                             ;* Return: CC = False, CS = True
                             ;****************************************
cda6 :                       df_tk_isalpha
cda6 : 48               [ 3] 	pha
cda7 : 0920             [ 2] 	ora #0x20					; Convert to lower case for checki
cda9 : c961             [ 2] 	cmp #'a'
cdab : 9007             [ 3] 	bcc df_tk_isalpha_false
cdad : c97b             [ 2] 	cmp #'z'+1
cdaf : b003             [ 3] 	bcs df_tk_isalpha_false
cdb1 : 68               [ 4] 	pla
cdb2 : 38               [ 2] 	sec
cdb3 : 60               [ 6] 	rts
cdb4 :                       df_tk_isalpha_false
cdb4 : 68               [ 4] 	pla
cdb5 : 18               [ 2] 	clc
cdb6 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* df_tk_isalphanum
                             ;* Check next char A for a-z,A-Z,0-9
                             ;* Return: CC = False, CS = True
                             ;****************************************
cdb7 :                       df_tk_isalphanum
cdb7 : 20a6cd           [ 6] 	jsr df_tk_isalpha
cdba : 9001             [ 3] 	bcc df_tk_try_digit
AS65 Assembler for R6502 [1.42].                                     Page   61
-------------------------------- bank\bank1.s --------------------------------

cdbc : 60               [ 6] 	rts
cdbd :                       df_tk_try_digit
cdbd : 2078cd           [ 6] 	jsr df_tk_isdigit
cdc0 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* df_tk_isproc
                             ;* Check next char A for _
                             ;* Return: CC = False, CS = True
                             ;****************************************
cdc1 :                       df_tk_isproc
cdc1 : c95f             [ 2] 	cmp #'_'
cdc3 : f002             [ 3] 	beq df_tk_isproc_true
cdc5 : 18               [ 2] 	clc
cdc6 : 60               [ 6] 	rts
cdc7 :                       df_tk_isproc_true
cdc7 : 38               [ 2] 	sec
cdc8 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* df_tk_skip_ws
                             ;* Skip ws in linbuff
                             ;* Return: linoff updated to next non-ws, A = cha
                             ;****************************************
cdc9 :                       df_tk_skip_ws
cdc9 :                       df_tk_ws_loop1
cdc9 : 205ecd           [ 6] 	jsr df_tk_peek_buf
cdcc : 20e6cd           [ 6] 	jsr df_tk_isws
cdcf : 9007             [ 3] 	bcc df_tk_ws_done
cdd1 : e6c5             [ 5] 	inc df_linoff
cdd3 : 206fcd           [ 6] 	jsr df_tk_put_tok
cdd6 : 80f1             [ 3] 	bra df_tk_ws_loop1
cdd8 :                       df_tk_ws_done
cdd8 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* df_tk_skip_ws
                             ;* Skip ws in linbuff
                             ;* Return: linoff updated to next non-ws, A = cha
                             ;****************************************
cdd9 :                       df_tk_strip_ws
cdd9 :                       df_tk_sws_loop1
cdd9 : 205ecd           [ 6] 	jsr df_tk_peek_buf
cddc : 20e6cd           [ 6] 	jsr df_tk_isws
cddf : 90f7             [ 3] 	bcc df_tk_ws_done
cde1 : e6c5             [ 5] 	inc df_linoff
cde3 : 80f4             [ 3] 	bra df_tk_sws_loop1
cde5 :                       df_tk_sws_done
cde5 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* df_tk_isws
                             ;* Check char is ws (only space is counted)
                             ;* Return: CC = False, CS = True
                             ;****************************************
cde6 :                       df_tk_isws
cde6 : c920             [ 2] 	cmp #' '
cde8 : d002             [ 3] 	bne df_tk_isws_false
cdea : 38               [ 2] 	sec
cdeb : 60               [ 6] 	rts
cdec :                       df_tk_isws_false	
cdec : 18               [ 2] 	clc
AS65 Assembler for R6502 [1.42].                                     Page   62
-------------------------------- bank\bank1.s --------------------------------

cded : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Find a character expected ignoring ws
                             ;* Input A = expected char
                             ;* CC = found, CS = Error
                             ;****************************************
cdee :                       df_tk_expect
cdee : 48               [ 3] 	pha
                             	; skip ws
cdef : 20c9cd           [ 6] 	jsr df_tk_skip_ws
                             	; peek the buffer
cdf2 : 68               [ 4] 	pla
cdf3 : a4c5             [ 3] 	ldy df_linoff
cdf5 : d90009           [ 4] 	cmp df_linbuff,y
                             	; if not expected char then error
cdf8 : d002             [ 3] 	bne df_tk_expecterr
cdfa : 18               [ 2] 	clc
cdfb : 60               [ 6] 	rts
cdfc :                       df_tk_expecterr
cdfc : 38               [ 2] 	sec
cdfd : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Find a character expected ignoring ws
                             ;* Input A = expected char
                             ;* Tokenises the character as well
                             ;* CC = found, CS = Error
                             ;****************************************
cdfe :                       df_tk_expect_tok
cdfe : 20eecd           [ 6] 	jsr df_tk_expect
ce01 : b007             [ 3] 	bcs df_tk_expecttokret
ce03 : 2064cd           [ 6] 	jsr df_tk_get_buf
ce06 : 206fcd           [ 6] 	jsr df_tk_put_tok
ce09 : 18               [ 2] 	clc
ce0a :                       df_tk_expecttokret
ce0a : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Find a character expected ignoring ws
                             ;* Input A = expected char
                             ;* Tokenises the character as well
                             ;* FATAL IF NOT FOUND
                             ;****************************************
ce0b :                       df_tk_expect_tok_err
ce0b : 20fecd           [ 6] 	jsr df_tk_expect_tok
ce0e : b002             [ 3] 	bcs df_tk_expect_tok_fatal
ce10 : 18               [ 2] 	clc
ce11 : 60               [ 6] 	rts
ce12 :                       df_tk_expect_tok_fatal
                             	SWBRK DFERR_SYNTAX
                             
                             
                             ;****************************************
                             ;* Tokenise a constant number
                             ;****************************************
ce14 :                       df_tk_num
                             	; X,A = address, linbuff must be on page boundar
ce14 : 18               [ 2] 	clc
ce15 : a900             [ 2] 	lda #lo(df_linbuff)
ce17 : 65c5             [ 3] 	adc df_linoff
ce19 : aa               [ 2] 	tax
AS65 Assembler for R6502 [1.42].                                     Page   63
-------------------------------- bank\bank1.s --------------------------------

ce1a : a909             [ 2] 	lda #hi(df_linbuff)
ce1c : 6900             [ 2] 	adc #0
ce1e : a000             [ 2] 	ldy #0				; any numeric format
ce20 : 206dc7           [ 6] 	jsr con_n_to_a
ce23 : b033             [ 3] 	bcs df_tk_num_err
                             	; A = format
                             	; X = how many digits processed
                             	; Jump over that many chars
ce25 : a8               [ 2] 	tay
ce26 : 18               [ 2] 	clc
ce27 : 8a               [ 2] 	txa
ce28 : 65c5             [ 3] 	adc df_linoff
ce2a : 85c5             [ 3] 	sta df_linoff
                             	; Now tokenise an integer
ce2c : 98               [ 2] 	tya
ce2d : c901             [ 2] 	cmp #NUM_DEC
ce2f : d004             [ 3] 	bne df_tk_num_hexbin
ce31 : a909             [ 2] 	lda #DFTK_INTDEC	; decimal always an int
ce33 : 8014             [ 3] 	bra df_tk_num_put
ce35 :                       df_tk_num_hexbin
ce35 : 18               [ 2] 	clc
ce36 : 6904             [ 2] 	adc #4				; Default to BYT
ce38 : c907             [ 2] 	cmp #NUM_BIN+4
ce3a : f009             [ 3] 	beq df_tk_num_bin
ce3c : e004             [ 2] 	cpx #4				; 4 chars processed = byte
ce3e : f009             [ 3] 	beq df_tk_num_put
ce40 :                       df_tk_num_makeint
ce40 : 18               [ 2] 	clc
ce41 : 6904             [ 2] 	adc #4				; now make INT
ce43 : 8004             [ 3] 	bra df_tk_num_put
ce45 :                       df_tk_num_bin
ce45 : e00a             [ 2] 	cpx #0x0a			; 10 chars processed = byte
ce47 : d0f7             [ 3] 	bne df_tk_num_makeint
ce49 :                       df_tk_num_put
ce49 : 206fcd           [ 6] 	jsr df_tk_put_tok
ce4c : a58e             [ 3] 	lda num_a
ce4e : 206fcd           [ 6] 	jsr df_tk_put_tok
ce51 : a58f             [ 3] 	lda num_a+1
ce53 : 206fcd           [ 6] 	jsr df_tk_put_tok
ce56 : 18               [ 2] 	clc
ce57 : 60               [ 6] 	rts
ce58 :                       df_tk_num_err
ce58 : 38               [ 2] 	sec
ce59 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Tokenise a constant char
                             ;****************************************
ce5a :                       df_tk_char
                             	; skip the first quote
ce5a : 2064cd           [ 6] 	jsr df_tk_get_buf
                             	; put in the token
ce5d : a900             [ 2] 	lda #DFTK_CHR
ce5f : 206fcd           [ 6] 	jsr df_tk_put_tok
                             	; get the char value and save
ce62 : 2064cd           [ 6] 	jsr df_tk_get_buf
ce65 : 206fcd           [ 6] 	jsr df_tk_put_tok
                             	; always put two bytes in, even for a BYTE type
ce68 : a900             [ 2] 	lda #0
ce6a : 206fcd           [ 6] 	jsr df_tk_put_tok
                             	; next byte must be single quote
ce6d : 2064cd           [ 6] 	jsr df_tk_get_buf
AS65 Assembler for R6502 [1.42].                                     Page   64
-------------------------------- bank\bank1.s --------------------------------

ce70 : c927             [ 2] 	cmp #0x27
ce72 : d002             [ 3] 	bne df_tk_char_err
ce74 : 18               [ 2] 	clc
ce75 : 60               [ 6] 	rts
ce76 :                       df_tk_char_err
ce76 : 38               [ 2] 	sec
ce77 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Tokenise a constant string
                             ;****************************************
ce78 :                       df_tk_str
                             	; skip the first quote
ce78 : 2064cd           [ 6] 	jsr df_tk_get_buf
                             	; put in the token
ce7b : a910             [ 2] 	lda #DFTK_STRLIT
ce7d : 206fcd           [ 6] 	jsr df_tk_put_tok
ce80 :                       df_tk_str_ch
                             	; copy string chars in to token buffer
                             	; until another quote or end of line
ce80 : 2064cd           [ 6] 	jsr df_tk_get_buf
ce83 : c900             [ 2] 	cmp #0
ce85 : f010             [ 3] 	beq df_tk_str_err
ce87 : c922             [ 2] 	cmp #0x22
ce89 : f005             [ 3] 	beq df_tk_str_don
ce8b : 206fcd           [ 6] 	jsr df_tk_put_tok
ce8e : 80f0             [ 3] 	bra df_tk_str_ch
ce90 :                       df_tk_str_don
                             	; zero terminated strings
ce90 : a900             [ 2] 	lda #0
ce92 : 206fcd           [ 6] 	jsr df_tk_put_tok
ce95 : 18               [ 2] 	clc
ce96 : 60               [ 6] 	rts
ce97 :                       df_tk_str_err
                             	SWBRK DFERR_SYNTAX
                             
                             	
                             ;****************************************
                             ;* Tokenise a constant (num, string, char)
                             ;****************************************
ce99 :                       df_tk_const
ce99 : 20c9cd           [ 6] 	jsr df_tk_skip_ws
                             	; Check what constant it is
ce9c : 205ecd           [ 6] 	jsr df_tk_peek_buf
                             	; Minus symbol could be start of a number
ce9f : c92d             [ 2] 	cmp #'-'
cea1 : f005             [ 3] 	beq df_tk_const_try_num
cea3 : 2078cd           [ 6] 	jsr df_tk_isdigit
cea6 : 9003             [ 3] 	bcc df_tk_const_try_str
cea8 :                       df_tk_const_try_num
cea8 : 4c14ce           [ 3] 	jmp df_tk_num
ceab :                       df_tk_const_try_str
                             	; check for double quote
ceab : c922             [ 2] 	cmp #0x22
cead : d003             [ 3] 	bne df_tk_const_try_char
ceaf : 4c78ce           [ 3] 	jmp df_tk_str
ceb2 :                       df_tk_const_try_char
                             	; check for single apostrophe
ceb2 : c927             [ 2] 	cmp #0x27
ceb4 : d003             [ 3] 	bne df_tk_const_err
ceb6 : 4c5ace           [ 3] 	jmp df_tk_char
ceb9 :                       df_tk_const_err
AS65 Assembler for R6502 [1.42].                                     Page   65
-------------------------------- bank\bank1.s --------------------------------

                             	SWBRK DFERR_SYNTAX
                             
                             	
                             ;****************************************
                             ;* Tokenise a variable - A = mask
                             ;* Return : A = variable index
                             ;****************************************
cebb :                       df_tk_var
                             	; Find or create variable, index in A
cebb : 20dacc           [ 6] 	jsr df_var_findcreate
cebe : 9001             [ 3] 	bcc df_tk_var_cont
cec0 : 60               [ 6] 	rts
cec1 :                       df_tk_var_cont
                             	; Save variable index for later
cec1 : 48               [ 3] 	pha
                             	; Put VAR escape in token buffer
cec2 : a911             [ 2] 	lda #DFTK_VAR					
cec4 : 206fcd           [ 6] 	jsr df_tk_put_tok
                             	; Get variable index and put in token buffer
cec7 : 68               [ 4] 	pla
cec8 : 48               [ 3] 	pha
cec9 : 206fcd           [ 6] 	jsr df_tk_put_tok
                             	; count of any array indices
cecc :                       df_tk_var_ck
                             	; check if array procesing needed
cecc : a95b             [ 2] 	lda #'['
cece : 20fecd           [ 6] 	jsr df_tk_expect_tok
ced1 : b003             [ 3] 	bcs df_tk_var_noarry
                             	; process numeric expression in bracket
ced3 : 2063cf           [ 6] 	jsr df_tk_narry
ced6 :                       df_tk_var_noarry
                             	; restore var index
ced6 : 68               [ 4] 	pla
ced7 : 18               [ 2] 	clc
ced8 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Tokenise a parameter in proc definition
                             ;* Return : A = variable index
                             ;****************************************
ced9 :                       df_tk_parm
                             	; if preceeding with non-local qualifier DFTK_VA
ced9 : 205ecd           [ 6] 	jsr df_tk_peek_buf
cedc : c926             [ 2] 	cmp #DFTK_VARPARM
cede : d006             [ 3] 	bne df_tk_parm_skip_var
                             	; get the qualifier and put in token buffer
cee0 : 2064cd           [ 6] 	jsr df_tk_get_buf
cee3 : 206fcd           [ 6] 	jsr df_tk_put_tok	
cee6 :                       df_tk_parm_skip_var
                             	; don't have a certain type of var
cee6 : a900             [ 2] 	lda #0
cee8 : 4cbbce           [ 3] 	jmp df_tk_var
                             	
                             	
                             ;****************************************
                             ;* Tokenise a variable to localise
                             ;* Return : A = variable index
                             ;****************************************
ceeb :                       df_tk_localvar
                             	; Find or create variable, index in A
ceeb : 20dacc           [ 6] 	jsr df_var_findcreate
ceee : 9001             [ 3] 	bcc df_tk_localvar_cont
AS65 Assembler for R6502 [1.42].                                     Page   66
-------------------------------- bank\bank1.s --------------------------------

cef0 : 60               [ 6] 	rts
cef1 :                       df_tk_localvar_cont
                             	; Save variable index for later
cef1 : 48               [ 3] 	pha
                             	; Put VAR escape in token buffer
cef2 : a911             [ 2] 	lda #DFTK_VAR					
cef4 : 206fcd           [ 6] 	jsr df_tk_put_tok
                             	; Get variable index and put in token buffer
cef7 : 68               [ 4] 	pla
cef8 : 206fcd           [ 6] 	jsr df_tk_put_tok
cefb : 18               [ 2] 	clc
cefc : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Tokenise call or def of proc
                             ;* Mode : A = 0 means def, else call
                             ;****************************************
cefd :                       df_tk_proc
cefd : 85de             [ 3] 	sta df_procmode
ceff : 20c9cd           [ 6] 	jsr df_tk_skip_ws
                             	; Find or create proc, index in A
cf02 : a940             [ 2] 	lda #DFVVT_PROC
cf04 : 20dacc           [ 6] 	jsr df_var_findcreate
cf07 : b058             [ 3] 	bcs df_tk_proc_err
                             	; Save variable index for later
cf09 : 48               [ 3] 	pha
                             	; Put PROC escape in token buffer
cf0a : a912             [ 2] 	lda #DFTK_PROC					
cf0c : 206fcd           [ 6] 	jsr df_tk_put_tok
                             	; Get variable index and put in token buffer
cf0f : 68               [ 4] 	pla
cf10 : 48               [ 3] 	pha
cf11 : 206fcd           [ 6] 	jsr df_tk_put_tok
                             
                             	; initially assume no args
cf14 : 64df             [ 3] 	stz df_procargs
                             	
                             	; Must have an open bracket
cf16 : a928             [ 2] 	lda #'('
cf18 : 200bce           [ 6] 	jsr df_tk_expect_tok_err
                             	; if immediately followed by close bracket then 
cf1b : 205ecd           [ 6] 	jsr df_tk_peek_buf
cf1e : c929             [ 2] 	cmp #')'
cf20 : f028             [ 3] 	beq df_tk_proc_noparm
                             	; else tokenise parm variables
cf22 :                       df_tk_proc_parms
cf22 : 20c9cd           [ 6] 	jsr df_tk_skip_ws
                             	; call appropriate routine for mode
cf25 : a5de             [ 3] 	lda df_procmode
cf27 : d005             [ 3] 	bne df_tk_proc_call
                             	; tokenise parameter variable in def mode
cf29 : 20d9ce           [ 6] 	jsr df_tk_parm
cf2c : 8003             [ 3] 	bra df_tk_proc_skip_call
cf2e :                       df_tk_proc_call
                             	; tokenise expression in call mode
cf2e : 20e4cf           [ 6] 	jsr df_tk_expression
cf31 :                       df_tk_proc_skip_call
cf31 : b02d             [ 3] 	bcs df_tk_proc_errp
                             	; increment number of args
cf33 : e6df             [ 5] 	inc df_procargs
                             	; what is next non ws char
cf35 : 20c9cd           [ 6] 	jsr df_tk_skip_ws
AS65 Assembler for R6502 [1.42].                                     Page   67
-------------------------------- bank\bank1.s --------------------------------

cf38 : c92c             [ 2] 	cmp #','
cf3a : f006             [ 3] 	beq df_tk_proc_comma
cf3c : c929             [ 2] 	cmp #')' 
cf3e : d020             [ 3] 	bne df_tk_proc_errp
cf40 : 8008             [ 3] 	bra df_tk_proc_noparm
                             	; comma found, more parms to process
cf42 :                       df_tk_proc_comma
cf42 : 2064cd           [ 6] 	jsr df_tk_get_buf
cf45 : 206fcd           [ 6] 	jsr df_tk_put_tok
cf48 : 80d8             [ 3] 	bra df_tk_proc_parms
cf4a :                       df_tk_proc_noparm
                             	; consume the close bracket
cf4a : 2064cd           [ 6] 	jsr df_tk_get_buf
cf4d : 206fcd           [ 6] 	jsr df_tk_put_tok
                             	
                             	; restore var index
cf50 : 68               [ 4] 	pla
                             	; update arg count if def mode
cf51 : a6de             [ 3] 	ldx df_procmode
cf53 : d009             [ 3] 	bne df_tk_proc_skip_args
                             	; get address of proc
cf55 : 20d4ca           [ 6] 	jsr df_var_addr
                             	; put arg count in dim2
cf58 : a004             [ 2] 	ldy #DFVVT_DIM2
cf5a : a5df             [ 3] 	lda df_procargs
cf5c : 91d4             [ 5] 	sta (df_tmpptra),y
cf5e :                       df_tk_proc_skip_args	
cf5e : 18               [ 2] 	clc
cf5f : 60               [ 6] 	rts
cf60 :                       df_tk_proc_errp
cf60 : 68               [ 4] 	pla
cf61 :                       df_tk_proc_err
                             	SWBRK DFERR_SYNTAX
                             
                             
                             ;****************************************
                             ;* Parse array index
                             ;****************************************
cf63 :                       df_tk_narry
                             	; if array open bracket encountered
                             	; then tokenise a numeric expression
cf63 : 20e4cf           [ 6] 	jsr df_tk_expression
                             	; If a comma is next, then another expression
cf66 : a92c             [ 2] 	lda #','
cf68 : 20fecd           [ 6] 	jsr df_tk_expect_tok
cf6b : b003             [ 3] 	bcs df_tk_narry_end
cf6d : 20e4cf           [ 6] 	jsr df_tk_expression
cf70 :                       df_tk_narry_end
                             	; after the second dimension, must be close sq b
cf70 : a95d             [ 2] 	lda #']'
cf72 : 200bce           [ 6] 	jsr df_tk_expect_tok_err
cf75 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Parse bracket
                             ;****************************************
cf76 :                       df_tk_nbrkt
                             	; if  open bracket encountered
                             	; then tokenise a numeric expression
cf76 : 20e4cf           [ 6] 	jsr df_tk_expression
cf79 : a929             [ 2] 	lda #')'
cf7b : 200bce           [ 6] 	jsr df_tk_expect_tok_err
AS65 Assembler for R6502 [1.42].                                     Page   68
-------------------------------- bank\bank1.s --------------------------------

cf7e : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* Parse call to numeric proc
                             ;****************************************
cf7f :                       df_tk_nterm_proc
                             	; call mode
cf7f : a901             [ 2] 	lda #1
cf81 : 20fdce           [ 6] 	jsr df_tk_proc
cf84 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Parse numeric term
                             ;****************************************
cf85 :                       df_tk_nterm
                             	; skip any ws first, copying in to tokbuff
                             	; A containts the non-ws char
cf85 : 20c9cd           [ 6] 	jsr df_tk_skip_ws
cf88 : c900             [ 2] 	cmp #0
cf8a : d002             [ 3] 	bne df_tk_nterm_cont
cf8c : 38               [ 2] 	sec
cf8d : 60               [ 6] 	rts
cf8e :                       df_tk_nterm_cont
                             	; if open bracket then process it
cf8e : c928             [ 2] 	cmp #'('
cf90 : d00a             [ 3] 	bne df_tk_nterm_tryfn
                             	; get the bracket and put in token buffer
cf92 : 2064cd           [ 6] 	jsr df_tk_get_buf
cf95 : 206fcd           [ 6] 	jsr df_tk_put_tok
                             	; go process the open bracket
cf98 : 2076cf           [ 6] 	jsr df_tk_nbrkt
cf9b : 60               [ 6] 	rts
cf9c :                       df_tk_nterm_tryfn
cf9c : 48               [ 3] 	pha
                             	; try decoding a built-in function
cf9d : a902             [ 2] 	lda #DFTK_FN
cf9f : 20afd0           [ 6] 	jsr df_tk_matchtok
cfa2 : b00d             [ 3] 	bcs df_tk_nterm_try_proc
                             	; pull old A in to Y but don't use
cfa4 : 7a               [ 4] 	ply
                             	; restore A and put the token with MSB set
cfa5 : 8a               [ 2] 	txa
cfa6 : 0980             [ 2] 	ora #0x80
cfa8 : 206fcd           [ 6] 	jsr df_tk_put_tok
cfab : 208ad0           [ 6] 	jsr df_tk_exec_parser 
cfae : b01b             [ 3] 	bcs df_tk_nterm_err
cfb0 : 60               [ 6] 	rts
cfb1 :                       df_tk_nterm_try_proc
cfb1 : 68               [ 4] 	pla
                             	; if it's not a func then try proc
cfb2 : 20c1cd           [ 6] 	jsr df_tk_isproc
cfb5 : 9006             [ 3] 	bcc df_tk_nterm_try_var
cfb7 : 207fcf           [ 6] 	jsr df_tk_nterm_proc
cfba : b00f             [ 3] 	bcs df_tk_nterm_err
cfbc : 60               [ 6] 	rts
cfbd :                       df_tk_nterm_try_var
                             	; Non-zero mask means var must be this type
cfbd : a900             [ 2] 	lda #0
cfbf : 20bbce           [ 6] 	jsr df_tk_var
cfc2 : b001             [ 3] 	bcs df_tk_nterm_try_const
cfc4 : 60               [ 6] 	rts
cfc5 :                       df_tk_nterm_try_const
AS65 Assembler for R6502 [1.42].                                     Page   69
-------------------------------- bank\bank1.s --------------------------------

                             	; Try decoding a constant
cfc5 : 2099ce           [ 6] 	jsr df_tk_const
cfc8 : b001             [ 3] 	bcs df_tk_nterm_err
cfca : 60               [ 6] 	rts
cfcb :                       df_tk_nterm_err
                             	SWBRK DFERR_SYNTAX
                             
                             
                             ;****************************************
                             ;* Parse numeric operator
                             ;****************************************
cfcd :                       df_tk_nop
cfcd : 20c9cd           [ 6] 	jsr df_tk_skip_ws
cfd0 : c900             [ 2] 	cmp #0
cfd2 : f00e             [ 3] 	beq df_tk_nop_false
                             	; must be an operator token for numeric
cfd4 : a90c             [ 2] 	lda #DFTK_OP | DFTK_STROP
cfd6 : 20afd0           [ 6] 	jsr df_tk_matchtok
cfd9 : b007             [ 3] 	bcs df_tk_nop_false
                             	; got a token
cfdb : 0980             [ 2] 	ora #DFTK_TOKEN
cfdd : 206fcd           [ 6] 	jsr df_tk_put_tok
cfe0 : 18               [ 2] 	clc
cfe1 : 60               [ 6] 	rts
cfe2 :                       df_tk_nop_false
cfe2 : 38               [ 2] 	sec
cfe3 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Parse numeric expression
                             ;****************************************
cfe4 :                       df_tk_expression
                             	; Tokenise a numeric term
cfe4 : 2085cf           [ 6] 	jsr df_tk_nterm
                             	; Try and tokenise a numeric operator
cfe7 : 20cdcf           [ 6] 	jsr df_tk_nop
                             	; If an operator was tokenised
                             	; then loop back for another term
cfea : 90f8             [ 3] 	bcc df_tk_expression
                             	; If no operator was found then
                             	; expression is done
cfec : 18               [ 2] 	clc
cfed : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Check end of statement
                             ;****************************************
cfee :                       df_tk_isEOS
cfee : a93a             [ 2] 	lda #':'
cff0 : 20fecd           [ 6] 	jsr df_tk_expect_tok
cff3 : 9002             [ 3] 	bcc df_tk_eos
cff5 : 18               [ 2] 	clc
cff6 : 60               [ 6] 	rts
cff7 :                       df_tk_eos
                             	; this is the position of the next statement
cff7 : a5c6             [ 3] 	lda df_tokoff
                             	; put it in the last statement offset slot
cff9 : a4c8             [ 3] 	ldy df_nxtstidx
cffb : 998009           [ 5] 	sta df_tokbuff,y
cffe : 38               [ 2] 	sec
cfff : 60               [ 6] 	rts
                             	
AS65 Assembler for R6502 [1.42].                                     Page   70
-------------------------------- bank\bank1.s --------------------------------

                             	
                             ;****************************************
                             ;* Parse user defined proc
                             ;****************************************
d000 :                       df_tk_parse_user_proc
                             	; put proc token in as a call
d000 : a981             [ 2] 	lda #0x81
d002 : 206fcd           [ 6] 	jsr df_tk_put_tok
d005 : a901             [ 2] 	lda #1
d007 : 20fdce           [ 6] 	jsr df_tk_proc
d00a : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* Parse a command
                             ;* Do not fatal error if this fails
                             ;****************************************
d00b :                       df_tk_parse_command
                             	; only looking for keywords
d00b : a901             [ 2] 	lda #DFTK_KW
d00d : 20afd0           [ 6] 	jsr df_tk_matchtok
                             	; if didn't find regular keywords then try non f
d010 : b010             [ 3] 	bcs df_tk_parse_command_err
                             	; if match then store token in the line buffer
                             	; Set MSB
d012 : 0980             [ 2] 	ora #0x80
d014 : 206fcd           [ 6] 	jsr df_tk_put_tok
                             	; call the parser to do tokenise based on the st
d017 : a5cc             [ 3] 	lda df_symoff
d019 : 208ad0           [ 6] 	jsr df_tk_exec_parser
d01c : b004             [ 3] 	bcs df_tk_parse_command_err
                             	; [1] ignore white space but keep it
d01e : 20c9cd           [ 6] 	jsr df_tk_skip_ws
                             	; No error in parsing this command
d021 :                       df_tk_parse_command_done
d021 : 18               [ 2] 	clc
d022 :                       df_tk_parse_command_err
d022 : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* lexer
                             ;****************************************
d023 :                       df_lexer_line
                             	; start at the beginning of the line buffer
d023 : 64c5             [ 3] 	stz df_linoff
                             	; start at the beginning of the tokenised buffer
d025 : 64c6             [ 3] 	stz df_tokoff
                             	; set current line to the token buffer
d027 : a980             [ 2] 	lda #lo(df_tokbuff)
d029 : 85cf             [ 3] 	sta df_currlin
d02b : a909             [ 2] 	lda #hi(df_tokbuff)
d02d : 85d0             [ 3] 	sta df_currlin+1
                             	; Set the line length to 0
d02f : a900             [ 2] 	lda #0
d031 : 206fcd           [ 6] 	jsr df_tk_put_tok
                             	
                             	; any leading white space, ignore and discard
d034 : 20d9cd           [ 6] 	jsr df_tk_strip_ws
                             
                             	; if peek next character is a number then assume
                             	; else assume a statement
AS65 Assembler for R6502 [1.42].                                     Page   71
-------------------------------- bank\bank1.s --------------------------------

d037 : 2078cd           [ 6] 	jsr df_tk_isdigit
d03a : 9005             [ 3] 	bcc df_lexer_skip_lnum
                             	; if line number then capture the line number an
d03c : 208fd0           [ 6] 	jsr df_tk_linenum
d03f : 8008             [ 3] 	bra df_tk_body
d041 :                       df_lexer_skip_lnum
                             	; if no line number then zero out the line numbe
                             	; line zero will indicate an immediate mode comm
d041 : a900             [ 2] 	lda #0
d043 : 206fcd           [ 6] 	jsr df_tk_put_tok				; Line num low byte
d046 : 206fcd           [ 6] 	jsr df_tk_put_tok				; Line num high byte
d049 :                       df_tk_body
                             	; Offset for next statement
d049 : a5c6             [ 3] 	lda df_tokoff
d04b : 85c8             [ 3] 	sta df_nxtstidx
d04d : a900             [ 2] 	lda #0
d04f : 206fcd           [ 6] 	jsr df_tk_put_tok				; Offset to next statement
                             	; [1] capture white space from line buffer in to
d052 : 20c9cd           [ 6] 	jsr df_tk_skip_ws
                             	; If next non ws is zero then this is an empty l
                             	; so return with length zero but line number fil
                             	; token buffer
d055 : c900             [ 2] 	cmp #0
d057 : f02d             [ 3] 	beq df_tk_line_empty
                             	; if next char is _ then parse a user defined pr
d059 : 20c1cd           [ 6] 	jsr df_tk_isproc
d05c : 9005             [ 3] 	bcc df_tk_try_command
d05e : 2000d0           [ 6] 	jsr df_tk_parse_user_proc
d061 : 800c             [ 3] 	bra df_tk_done
d063 :                       df_tk_try_command
                             	; try  a keyword
d063 : 200bd0           [ 6] 	jsr df_tk_parse_command
d066 : b002             [ 3] 	bcs	df_tk_try_assign
d068 : 8005             [ 3] 	bra df_tk_done
d06a :                       df_tk_try_assign
                             	; nothing but to try an assignment operation
d06a : 2069d4           [ 6] 	jsr df_tk_assign
d06d : b019             [ 3] 	bcs	df_tk_parseerror
d06f :                       df_tk_done
                             	; put statement index stuff here in case of mult
                             	; check for : and if present tokenise plus updat
                             	; then go back to try and process another statem
d06f : 20eecf           [ 6] 	jsr df_tk_isEOS
d072 : b0d5             [ 3] 	bcs df_tk_body
                             	; if not at end of line, then must be error
d074 : 205ecd           [ 6] 	jsr df_tk_peek_buf
d077 : c900             [ 2] 	cmp #0
d079 : d00d             [ 3] 	bne df_tk_parseerror
                             	; Get line length length
d07b : a4c6             [ 3] 	ldy df_tokoff
                             	; ensure there is always a zero after the last t
d07d : a900             [ 2] 	lda #0
d07f : 998009           [ 5] 	sta df_tokbuff,y
                             	; save the line length
d082 : 98               [ 2] 	tya
d083 : 8d8009           [ 4] 	sta df_tokbuff
d086 :                       df_tk_line_empty
d086 : 18               [ 2] 	clc
d087 : 60               [ 6] 	rts
d088 :                       df_tk_parseerror
                             	SWBRK DFERR_SYNTAX
                             
AS65 Assembler for R6502 [1.42].                                     Page   72
-------------------------------- bank\bank1.s --------------------------------

                             
                             ;****************************************
                             ;* df_tk_parsestatement
                             ;* Execute parse routine for this statement
                             ;* Input: df_tokoff is the token found
                             ;* Return: CC = Parsed ok, CS = Error
                             ;****************************************
d08a :                       df_tk_exec_parser
d08a : 0a               [ 2] 	asl a
d08b : aa               [ 2] 	tax
d08c : 7c01d3           [ 6] 	jmp (df_tk_tokenjmp,x)
                             	
                             
                             ;****************************************
                             ;* df_tk_linenum
                             ;* Tokenise line number
                             ;****************************************
d08f :                       df_tk_linenum
                             	; Convert line number to 16 bit number
                             	; Save the line number
                             	; Increment the buffer pointer
d08f : 18               [ 2] 	clc
d090 : a900             [ 2] 	lda #lo(df_linbuff)
d092 : 65c5             [ 3] 	adc df_linoff
d094 : aa               [ 2] 	tax
d095 : a909             [ 2] 	lda #hi(df_linbuff)
d097 : 6900             [ 2] 	adc #0
d099 : a001             [ 2] 	ldy #1			; Decimal format only
d09b : 206dc7           [ 6] 	jsr con_n_to_a
d09e : 18               [ 2] 	clc
d09f : 8a               [ 2] 	txa
d0a0 : 65c5             [ 3] 	adc df_linoff
d0a2 : 85c5             [ 3] 	sta df_linoff
                             	; Now save line number
d0a4 : a58e             [ 3] 	lda num_a
d0a6 : 206fcd           [ 6] 	jsr df_tk_put_tok
d0a9 : a58f             [ 3] 	lda num_a+1
d0ab : 206fcd           [ 6] 	jsr df_tk_put_tok
d0ae : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* df_tk_matchtok
                             ;* Try and find a token match against the table d
                             ;* Input:
                             ;*			Current df_linbuff and df_linoff
                             ;* Return: 	CC = No Error, CS = Error
                             ;*			df_linoff points to next char if CC else unc
                             ;****************************************
d0af :                       df_tk_matchtok
                             	; save the mask to check types against
d0af : 48               [ 3] 	pha
                             	; Start at token symbols beginning
d0b0 : a92a             [ 2] 	lda #lo(df_tokensyms)
d0b2 : 85ca             [ 3] 	sta df_symtab
d0b4 : a9d1             [ 2] 	lda #hi(df_tokensyms)
d0b6 : 85cb             [ 3] 	sta df_symtab+1
d0b8 : 64cc             [ 3] 	stz df_symoff
d0ba :                       df_tk_checknexttok
                             	; check this token type first
d0ba : 68               [ 4] 	pla
d0bb : 48               [ 3] 	pha
d0bc : a6cc             [ 3] 	ldx df_symoff
AS65 Assembler for R6502 [1.42].                                     Page   73
-------------------------------- bank\bank1.s --------------------------------

d0be : 3ddfd3           [ 4] 	and df_tk_tokentype,x
d0c1 : f030             [ 3] 	beq df_tk_symnomatch
                             	; Special check for operator token
                             	; because of order of precedence fudge
                             	; ******FIX THIS ONE DAY!!!!!!******
                             	; if parm and token type = DFTK_OP then ok
                             	; if parm and token type <> DFTK_OP then not ok
d0c3 : bddfd3           [ 4] 	lda df_tk_tokentype,x
d0c6 : 2908             [ 2] 	and #DFTK_OP
d0c8 : f009             [ 3] 	beq df_tk_matchtok_skip_op
d0ca : 68               [ 4] 	pla
d0cb : 48               [ 3] 	pha
d0cc : 2908             [ 2] 	and #DFTK_OP
d0ce : 3ddfd3           [ 4] 	and df_tk_tokentype,x
d0d1 : f020             [ 3] 	beq df_tk_symnomatch	
d0d3 :                       df_tk_matchtok_skip_op
                             	; From the line buffer current pointer
                             	; Check for a token match
d0d3 : a4c5             [ 3] 	ldy df_linoff
d0d5 :                       df_tk_checktokch
                             	; Get symtable char
                             	; and mask off MSB
d0d5 : b2ca             [ 5] 	lda (df_symtab)
                             	; Save the value and mask off MSB
d0d7 : 48               [ 3] 	pha
d0d8 : 297f             [ 2] 	and #0x7f
                             	; Compare with current line buffer char
d0da : d90009           [ 4] 	cmp df_linbuff,y
                             	; If chars not match then this symbol fails
d0dd : d013             [ 3] 	bne df_tk_symnomatchp
                             	; If match and symbol has MSB then
                             	; all of the symbol matched
d0df : 68               [ 4] 	pla 
d0e0 : 3030             [ 4] 	bmi df_tk_symfound
                             	; else more chars to match
                             	; so increment line buffer pointers
                             	_incZPWord df_symtab
                             
d0e8 : c8               [ 2] 	iny
d0e9 : b90009           [ 4] 	lda df_linbuff,y
d0ec : c92e             [ 2] 	cmp #'.'
d0ee : f022             [ 4] 	beq df_tk_symfound
d0f0 : 80e3             [ 3] 	bra df_tk_checktokch
d0f2 :                       df_tk_symnomatchp
d0f2 : 68               [ 4] 	pla
d0f3 :                       df_tk_symnomatch
                             	; Increment symbol counter to next symbol
d0f3 : e6cc             [ 5] 	inc df_symoff
d0f5 :                       df_tk_symnextentry
d0f5 : b2ca             [ 5] 	lda (df_symtab)
                             	; End of symbol is MSB
d0f7 : 3008             [ 4] 	bmi  df_tk_foundsymend
                             	_incZPWord df_symtab
                             
d0ff : 80f4             [ 3] 	bra df_tk_symnextentry
d101 :                       df_tk_foundsymend
                             	; Increment char to point to new symbol
                             	; for matching with line buffer
                             	_incZPWord df_symtab
                             
                             	; If next char is not zero then
                             	; try and match with line buffer
AS65 Assembler for R6502 [1.42].                                     Page   74
-------------------------------- bank\bank1.s --------------------------------

d107 : b2ca             [ 5] 	lda (df_symtab)
d109 : d0af             [ 4] 	bne df_tk_checknexttok
                             	; else symbol table exhausted
                             	; so no match found
                             	; Zero symbol counter
d10b : 64cc             [ 3] 	stz df_symoff
                             	; pop mask off stack
d10d : 68               [ 4] 	pla	
d10e : a900             [ 2] 	lda #0
                             	; Set C to indicate error (no match)
d110 : 38               [ 2] 	sec
d111 : 60               [ 6] 	rts
d112 :                       df_tk_symfound
                             	; Full match with keyword in symtable but
                             	; if matching with something that ended in alpha
                             	; then check the next buffer char is not alphanu
                             	; as this could be part of a variable name
                             	; Point to next buffer char in any case
d112 : c8               [ 2] 	iny
                             	; First mask off MSB
d113 : 297f             [ 2] 	and #0x7f
                             	; Then check if alpha
d115 : 20a6cd           [ 6] 	jsr df_tk_isalpha
                             	; if not alpha then we're definitely done
d118 : 9008             [ 3] 	bcc df_tk_symfound_final
                             	; else check buffer
d11a : b90009           [ 4] 	lda df_linbuff,y
                             	; if it is an alphanum then
d11d : 20b7cd           [ 6] 	jsr df_tk_isalphanum
                             	; do not count as a match
d120 : b0d1             [ 4] 	bcs df_tk_symnomatch
d122 :                       df_tk_symfound_final
                             	; pop mask off stack
d122 : 68               [ 4] 	pla
                             	; Save line buffer pointer (points to next char)
                             	; Clear C to indicate success (match)
d123 : 84c5             [ 3] 	sty df_linoff
d125 : a5cc             [ 3] 	lda df_symoff
d127 : aa               [ 2] 	tax
d128 : 18               [ 2] 	clc
d129 : 60               [ 6] 	rts
                             
                             	include "dflat\tksymtab.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  TKSYMTAB.S
                             ;*  Runtime token jump table.
                             ;*  dflat uses four key tables to tokenise and ru
                             ;*  - df_tokensyms    - table of token symbols
                             ;*  - df_tk_tokentype - table of token types
                             ;*  - df_tk_tokenjmp  - table of tokenising routi
                             ;*  - df_rt_tokenjmp  - table of runtime routines
                             ;*  The key is the token symbols.  When a line is
                             ;*  in to the raw (untokenised) buffer, df_tokens
                             ;*  used to identify tokens.  The position of the
                             ;*  token is used to then look up type and jump v
AS65 Assembler for R6502 [1.42].                                     Page   75
-------------------------------- bank\bank1.s --------------------------------

                             ;*  in the other tables.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
                             ; Statement Token table
                             ; keywords
d12a :                       df_tokensyms
d12a : 80                    	db	0x80						; Implicit numeric assign
d12b : 80                    	db	0x80						; Implicit call procedure
d12c : bb                    	db	";"+0x80					; Comment
d12d : 7072696e746cee        	db	"printl",'n'+0x80			; println exprlist
d134 : 7072696e7461f4        	db	"printa",'t'+0x80			; printat x,y,exprlist
d13b : 7072696ef4            	db	"prin",'t'+0x80				; print exprlist
d140 : 6465e6                	db	"de",'f'+0x80				; def_subname
d143 : 656e646465e6          	db	"endde",'f'+0x80			; enddef
d149 : 7265747572ee          	db	"retur",'n'+0x80			; return
d14f : 61626f72f4            	db	"abor",'t'+0x80				; abort
d154 : 6c6f6361ec            	db	"loca",'l'+0x80				; local varlist
d159 : 6469ed                	db	"di",'m'+0x80				; dim varlist
d15c : 7265706561f4          	db	"repea",'t'+0x80			; repeat
d162 : 756e7469ec            	db	"unti", 'l'+0x80			; until condition
d167 : 666ff2                	db	"fo",'r'+0x80				; for var=start,end,incremen
d16a : 6e6578f4              	db	"nex",'t'+0x80				; next
d16e : 7768696ce5            	db	"whil",'e'+0x80				; while condition
d173 : 77656ee4              	db	"wen",'d'+0x80				; wend
d177 : 69e6                  	db	"i",'f'+0x80				; if condition
d179 : 656c73e5              	db	"els",'e'+0x80				; else
d17d : 656e6469e6            	db	"endi",'f'+0x80				; endif
d182 : 656c69e6              	db	"eli",'f'+0x80				; elif condition
d186 : 646174e1              	db	"dat",'a'+0x80				; data
d18a : ae                    	db	'.'+0x80					; assembler command
d18b : 7275ee                	db	"ru",'n'+0x80				; run
d18e : 6c6973f4              	db	"lis",'t'+0x80				; list _proc-|*|line,line
d192 : 696e7075f4            	db	"inpu",'t'+0x80				; input var
d197 : 6d6f64e5              	db	"mod",'e'+0x80				; mode n
d19b : 706c6ff4              	db	"plo",'t'+0x80				; plot x,y,char|string
d19f : 637572736ff2          	db	"curso",'r'+0x80			; cursor n
d1a5 : 636cf3                	db	"cl",'s'+0x80				; cls
d1a8 : 76706f6be5            	db	"vpok",'e'+0x80				; vpoke addr,val
d1ad : 7365747664f0          	db	"setvd",'p'+0x80			; setvdp reg,val
d1b3 : 636f6c6f75f2          	db	"colou",'r'+0x80			; colour reg,val
d1b9 : 73707269746570..      	db	"spritepa",'t'+0x80			; spritepat patnum,arra
d1c2 : 73707269746570..      	db	"spritepo",'s'+0x80			; spritepos sprnum,x,y
d1cb : 73707269746563..      	db	"spriteco",'l'+0x80			; spritecol sprnum,col
d1d4 : 7370726974656e..      	db	"spritenm",'e'+0x80			; spritenme sprnum,patn
d1dd : 7370726974e5          	db	"sprit",'e'+0x80			; sprite n,x,y,p,c
d1e3 : 706f6be5              	db	"pok",'e'+0x80				; poke a,v
d1e7 : 646f6be5              	db	"dok",'e'+0x80				; doke a,v
d1eb : 736f756ee4            	db	"soun",'d'+0x80				; sound
d1f0 : 6d757369e3            	db	"musi",'c'+0x80				; music
d1f5 : 706c61f9              	db	"pla",'y'+0x80				; play
d1f9 : 736176e5              	db	"sav",'e'+0x80				; save
d1fd : 6c6f61e4              	db	"loa",'d'+0x80				; load
d201 : 6469f2                	db	"di",'r'+0x80				; dir
d204 : 6465ec                	db 	"de",'l'+0x80				; del
d207 : 726561e4              	db	"rea",'d'+0x80				; read
d20b : 6e65f7                	db	"ne",'w'+0x80				; new
d20e : 72656e75ed            	db	"renu",'m'+0x80				; renum start,offset,incre
d213 : 776169f4              	db	"wai",'t'+0x80				; wait delay
AS65 Assembler for R6502 [1.42].                                     Page   76
-------------------------------- bank\bank1.s --------------------------------

d217 : 72657365f4            	db	"rese",'t'+0x80				; reset var
d21c : 68697265f3            	db	"hire",'s'+0x80				; hires col
d221 : 706f696ef4            	db	"poin",'t'+0x80				; point x,y,mode
d226 : 6c696ee5              	db	"lin",'e'+0x80				; line x0,y0,x1,y1
d22a : 68706c6ff4            	db	"hplo",'t'+0x80				; hplot x,y,char|string
d22f : 7069786d6f64e5        	db	"pixmod",'e'+0x80			; pixmode n
d236 : 7069786d6173eb        	db	"pixmas",'k'+0x80			; pixmask n
d23d : 706978636fec          	db	"pixco",'l'+0x80			; pixcol n
d243 : 626ff8                	db	"bo",'x'+0x80				; box x0,y0,x1,y1
d246 : 636972636ce5          	db	"circl",'e'+0x80			; circle x0,y0,r
d24c : 73686170e5            	db	"shap",'e'+0x80				; shape x,y,coords[]
d251 : 766c6f61e4            	db	"vloa",'d'+0x80				; vload addr,filename
d256 : 626c6f61e4            	db	"bloa",'d'+0x80				; bload mem,hrd,addr,filen
d25b : 62736176e5            	db	"bsav",'e'+0x80				; bsave mem,hdr,addr,len,f
d260 : 68696d65ed            	db	"hime",'m'+0x80				; himem addr
d265 : 6d6f6e69746ff2        	db	"monito",'r'+0x80			; monitor
d26c : 63686469f2            	db	"chdi",'r'+0x80				; chdir fname
                             ; Functions
d271 : 767065656ba8          	db	"vpeek",'('+0x80			; vpeek(x)
d277 : 7065656ba8            	db	"peek",'('+0x80				; peek(x)
d27c : 6465656ba8            	db	"deek",'('+0x80				; peek(x)
d281 : 737469636ba8          	db	"stick",'('+0x80			; stick(x)
d287 : 6b6579a8              	db	"key",'('+0x80				; key(x)
d28b : 636872a8              	db	"chr",'('+0x80				; chr(x)
d28f : 6c656674a8            	db	"left",'('+0x80				; left(x$,y)
d294 : 7269676874a8          	db	"right",'('+0x80			; right(x$,y)
d29a : 6d6964a8              	db	"mid",'('+0x80				; mid(x$,y)
d29e : 6c656ea8              	db	"len",'('+0x80				; len(x$)
d2a2 : 6d656da8              	db	"mem",'('+0x80				; mem(x)
d2a6 : 7363726ea8            	db	"scrn",'('+0x80				; scrn(x,y)
d2ab : 726e64a8              	db	"rnd",'('+0x80				; rnd(x)
d2af : 656c6170736564a8      	db	"elapsed",'('+0x80			; elapsed(var)
d2b7 : 63616c6ca8            	db	"call",'('+0x80				; call(addr,A,X,Y)
d2bc : 686578a8              	db	"hex",'('+0x80				; hex(x)
d2c0 : 617363a8              	db	"asc",'('+0x80				; asc(x$)
d2c4 : 76616ca8              	db	"val",'('+0x80				; val(x$)
d2c8 : 6d7362797465a8        	db	"msbyte",'('+0x80			; msbyte(x)
d2cf : 6c7362797465a8        	db	"lsbyte",'('+0x80			; lsbyte(x)
                             ; Numeric operators, in priority
d2d6 : aa                    	db	'*'+0x80					; Multiply
d2d7 : af                    	db 	'/'+0x80					; Divide
d2d8 : dc                    	db 	'\\'+0x80					; Modulus
d2d9 : 3cbc                  	db	'<','<'+0x80				; Shift left
d2db : 3ebe                  	db	'>','>'+0x80				; Shift right
d2dd : ab                    	db 	'+'+0x80					; Add
d2de : ad                    	db	'-'+0x80					; Subtract
                             ; Conditional operators, in priority
d2df : 616ee4                	db "an",'d'+0x80				; AND
d2e2 : 6ff2                  	db "o",'r'+0x80					; OR
d2e4 : 3cbd                  	db "<",'='+0x80					; Less than or equal
d2e6 : 3ebd                  	db ">",'='+0x80					; Greater than or equal
d2e8 : 3cbe                  	db "<",'>'+0x80					; Not equal
d2ea : bc                    	db '<'+0x80						; Less than
d2eb : be                    	db '>'+0x80						; Greater than
d2ec : 3dbd                  	db "=",'='+0x80					; Equality (always last)
                             ; String conditional operators, in priority
d2ee : 24ab                  	db "$",'+'+0x80					; String cat
d2f0 : 243cbd                	db "$<",'='+0x80				; Less than or equal
d2f3 : 243ebd                	db "$>",'='+0x80				; Greater than or equal
d2f6 : 243cbe                	db "$<",'>'+0x80				; Not equal
d2f9 : 24bc                  	db "$",'<'+0x80					; Less than
d2fb : 24be                  	db "$",'>'+0x80					; Greater than
AS65 Assembler for R6502 [1.42].                                     Page   77
-------------------------------- bank\bank1.s --------------------------------

d2fd : 243dbd                	db "$=",'='+0x80				; Equality (always last)
                             
d300 : 00                    	db  0
                             
                             
                             	
                             	
                             	include "dflat\tkjmptab.s"
                             ;************************************************
                             ;*
                             ;*	DOLO-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  full credit of my authorship please!
                             ;*
                             ;*  TKJUMPTAB.S
                             ;*  Runtime token jump table.
                             ;*  dflat uses four key tables to tokenise and ru
                             ;*  - df_tokensyms    - table of token symbols
                             ;*  - df_tk_tokentype - table of token types
                             ;*  - df_tk_tokenjmp  - table of tokenising routi
                             ;*  - df_rt_tokenjmp  - table of runtime routines
                             ;*  The key is the token symbols.  When a line is
                             ;*  in to the raw (untokenised) buffer, df_tokens
                             ;*  used to identify tokens.  The position of the
                             ;*  token is used to then look up type and jump v
                             ;*  in the other tables.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
                             ; Tokeniser jump table
                             ; In token order of df_tokensyms
d301 :                       df_tk_tokenjmp
d301 : 69d4                  	dw	df_tk_assign
d303 : 2fd5                  	dw	df_tk_callproc
d305 : 71d4                  	dw	df_tk_comment
d307 : ced4                  	dw	df_tk_println
d309 : c2d4                  	dw	df_tk_printat
d30b : ced4                  	dw	df_tk_print
d30d : 07d5                  	dw	df_tk_def
d30f : 68d5                  	dw	df_tk_enddef
d311 : 6ad5                  	dw	df_tk_return
d313 : 68d5                  	dw	df_tk_abort
d315 : f6d4                  	dw	df_tk_local
d317 : e5d4                  	dw	df_tk_dim
d319 : 68d5                  	dw	df_tk_repeat
d31b : 6ad5                  	dw	df_tk_until
d31d : 0dd5                  	dw	df_tk_for
d31f : 68d5                  	dw	df_tk_next
d321 : 6ad5                  	dw	df_tk_while
d323 : 68d5                  	dw	df_tk_wend
d325 : 6ad5                  	dw	df_tk_if
d327 : 68d5                  	dw	df_tk_else
d329 : 68d5                  	dw	df_tk_endif
d32b : 6ad5                  	dw	df_tk_elseif
d32d : ced4                  	dw	df_tk_data
d32f : f6f1                  	dw	df_tk_asm_parse_command
d331 : 68d5                  	dw	df_tk_run
AS65 Assembler for R6502 [1.42].                                     Page   78
-------------------------------- bank\bank1.s --------------------------------

d333 : a0d4                  	dw	df_tk_list
d335 : dcd4                  	dw	df_tk_input
d337 : 6ad5                  	dw	df_tk_mode
d339 : 7ad5                  	dw	df_tk_plot
d33b : 6ad5                  	dw	df_tk_cursor
d33d : 68d5                  	dw	df_tk_cls
d33f : 6ed5                  	dw	df_tk_vpoke
d341 : 6ed5                  	dw	df_tk_setvdp
d343 : 7ad5                  	dw	df_tk_colour
d345 : 6ed5                  	dw	df_tk_spritepat
d347 : 7ad5                  	dw	df_tk_spritepos
d349 : 6ed5                  	dw	df_tk_spritecol
d34b : 6ed5                  	dw	df_tk_spritenme
d34d : 92d5                  	dw	df_tk_sprite
d34f : 6ed5                  	dw	df_tk_poke
d351 : 6ed5                  	dw	df_tk_doke
d353 : 7ad5                  	dw	df_tk_sound
d355 : 86d5                  	dw	df_tk_music
d357 : 86d5                  	dw	df_tk_play
d359 : 6ad5                  	dw	df_tk_save
d35b : 6ad5                  	dw	df_tk_load
d35d : 68d5                  	dw	df_tk_dir
d35f : 6ad5                  	dw	df_tk_del
d361 : e5d4                  	dw	df_tk_read
d363 : 68d5                  	dw	df_tk_new
d365 : 7ad5                  	dw	df_tk_renum
d367 : 6ad5                  	dw	df_tk_wait
d369 : 31d5                  	dw	df_tk_reset
d36b : 6ad5                  	dw	df_tk_hires
d36d : 6ed5                  	dw	df_tk_point
d36f : 86d5                  	dw	df_tk_line
d371 : 7ad5                  	dw	df_tk_hplot
d373 : 6ad5                  	dw	df_tk_pixmode
d375 : 6ad5                  	dw	df_tk_pixmask
d377 : 6ad5                  	dw	df_tk_pixcol
d379 : 86d5                  	dw	df_tk_box
d37b : 7ad5                  	dw	df_tk_circle
d37d : 7ad5                  	dw	df_tk_shape
d37f : 6ed5                  	dw	df_tk_vload
d381 : 86d5                  	dw	df_tk_bload
d383 : 92d5                  	dw	df_tk_bsave
d385 : 6ad5                  	dw	df_tk_himem
d387 : 68d5                  	dw	df_tk_monitor
d389 : 6ad5                  	dw	df_tk_chdir
                             	
d38b : 3ad5                  	dw	df_tk_vpeek
d38d : 3ad5                  	dw	df_tk_peek
d38f : 3ad5                  	dw	df_tk_deek
d391 : 3ad5                  	dw	df_tk_stick
d393 : 3ad5                  	dw	df_tk_key
d395 : 3ad5                  	dw	df_tk_chr
d397 : 4ed5                  	dw	df_tk_left
d399 : 4ed5                  	dw	df_tk_right
d39b : 54d5                  	dw	df_tk_mid
d39d : 3ad5                  	dw	df_tk_len
d39f : 3ad5                  	dw	df_tk_mem
d3a1 : 4ed5                  	dw	df_tk_scrn
d3a3 : 3ad5                  	dw	df_tk_rnd
d3a5 : 43d5                  	dw	df_tk_elapsed
d3a7 : 5ad5                  	dw	df_tk_call
d3a9 : 3ad5                  	dw	df_tk_hex
d3ab : 3ad5                  	dw	df_tk_asc
AS65 Assembler for R6502 [1.42].                                     Page   79
-------------------------------- bank\bank1.s --------------------------------

d3ad : 3ad5                  	dw	df_tk_val
d3af : 3ad5                  	dw	df_tk_msbyte
d3b1 : 3ad5                  	dw	df_tk_lsbyte
                             	
d3b3 : 68d5                  	dw	df_tk_mult
d3b5 : 68d5                  	dw	df_tk_div
d3b7 : 68d5                  	dw	df_tk_mod
d3b9 : 68d5                  	dw	df_tk_asl
d3bb : 68d5                  	dw	df_tk_lsr
d3bd : 68d5                  	dw	df_tk_add
d3bf : 68d5                  	dw	df_tk_sub
                             	
d3c1 : 68d5                  	dw	df_tk_and
d3c3 : 68d5                  	dw	df_tk_or
d3c5 : 68d5                  	dw	df_tk_lte
d3c7 : 68d5                  	dw	df_tk_gte
d3c9 : 68d5                  	dw	df_tk_ne
d3cb : 68d5                  	dw	df_tk_lt
d3cd : 68d5                  	dw	df_tk_gt
d3cf : 68d5                  	dw	df_tk_eq
                             
d3d1 : 68d5                  	dw	df_tk_sadd
d3d3 : 68d5                  	dw	df_tk_slte
d3d5 : 68d5                  	dw	df_tk_sgte
d3d7 : 68d5                  	dw	df_tk_sne
d3d9 : 68d5                  	dw	df_tk_slt
d3db : 68d5                  	dw	df_tk_sgt
d3dd : 68d5                  	dw	df_tk_seq
                             
                             	
                             	
                             	
                             	
                             	
                             	include "dflat\tktyptab.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  RTJUMPTAB.S
                             ;*  Runtime token jump table.
                             ;*  dflat uses four key tables to tokenise and ru
                             ;*  - df_tokensyms    - table of token symbols
                             ;*  - df_tk_tokentype - table of token types
                             ;*  - df_tk_tokenjmp  - table of tokenising routi
                             ;*  - df_rt_tokenjmp  - table of runtime routines
                             ;*  The key is the token symbols.  When a line is
                             ;*  in to the raw (untokenised) buffer, df_tokens
                             ;*  used to identify tokens.  The position of the
                             ;*  token is used to then look up type and jump v
                             ;*  in the other tables.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
                             ; Tokeniser type table (is it a keyword, function
AS65 Assembler for R6502 [1.42].                                     Page   80
-------------------------------- bank\bank1.s --------------------------------

                             ; In token order of df_tokensyms
d3df :                       df_tk_tokentype
d3df : 01                    	db	DFTK_KW
d3e0 : 01                    	db	DFTK_KW
d3e1 : 01                    	db	DFTK_KW
d3e2 : 01                    	db	DFTK_KW
d3e3 : 01                    	db	DFTK_KW
d3e4 : 01                    	db	DFTK_KW
d3e5 : 01                    	db	DFTK_KW
d3e6 : 01                    	db	DFTK_KW
d3e7 : 01                    	db	DFTK_KW
d3e8 : 01                    	db	DFTK_KW
d3e9 : 01                    	db	DFTK_KW
d3ea : 01                    	db	DFTK_KW
d3eb : 01                    	db	DFTK_KW
d3ec : 01                    	db	DFTK_KW
d3ed : 01                    	db	DFTK_KW
d3ee : 01                    	db	DFTK_KW
d3ef : 01                    	db	DFTK_KW
d3f0 : 01                    	db	DFTK_KW
d3f1 : 01                    	db	DFTK_KW
d3f2 : 01                    	db	DFTK_KW
d3f3 : 01                    	db	DFTK_KW
d3f4 : 01                    	db	DFTK_KW
d3f5 : 01                    	db	DFTK_KW
d3f6 : 01                    	db	DFTK_KW
d3f7 : 01                    	db	DFTK_KW
d3f8 : 01                    	db	DFTK_KW
d3f9 : 01                    	db	DFTK_KW
d3fa : 01                    	db	DFTK_KW
d3fb : 01                    	db	DFTK_KW
d3fc : 01                    	db	DFTK_KW
d3fd : 01                    	db	DFTK_KW
d3fe : 01                    	db	DFTK_KW
d3ff : 01                    	db	DFTK_KW
d400 : 01                    	db	DFTK_KW
d401 : 01                    	db	DFTK_KW
d402 : 01                    	db	DFTK_KW
d403 : 01                    	db	DFTK_KW
d404 : 01                    	db	DFTK_KW
d405 : 01                    	db	DFTK_KW
d406 : 01                    	db	DFTK_KW
d407 : 01                    	db	DFTK_KW
d408 : 01                    	db	DFTK_KW
d409 : 01                    	db	DFTK_KW
d40a : 01                    	db	DFTK_KW
d40b : 01                    	db	DFTK_KW
d40c : 01                    	db	DFTK_KW
d40d : 01                    	db	DFTK_KW
d40e : 01                    	db	DFTK_KW
d40f : 01                    	db	DFTK_KW
d410 : 01                    	db	DFTK_KW
d411 : 01                    	db	DFTK_KW
d412 : 01                    	db	DFTK_KW
d413 : 01                    	db	DFTK_KW
d414 : 01                    	db	DFTK_KW
d415 : 01                    	db	DFTK_KW
d416 : 01                    	db	DFTK_KW
d417 : 01                    	db	DFTK_KW
d418 : 01                    	db	DFTK_KW
d419 : 01                    	db	DFTK_KW
d41a : 01                    	db	DFTK_KW
AS65 Assembler for R6502 [1.42].                                     Page   81
-------------------------------- bank\bank1.s --------------------------------

d41b : 01                    	db	DFTK_KW
d41c : 01                    	db	DFTK_KW
d41d : 01                    	db	DFTK_KW
d41e : 01                    	db	DFTK_KW
d41f : 01                    	db	DFTK_KW
d420 : 01                    	db	DFTK_KW
d421 : 01                    	db	DFTK_KW
d422 : 01                    	db	DFTK_KW
d423 : 01                    	db	DFTK_KW
                             
d424 : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
d425 : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
d426 : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
d427 : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
d428 : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
d429 : 42                    	db 	DFTK_FN | DFTK_STR
d42a : 42                    	db 	DFTK_FN | DFTK_STR
d42b : 42                    	db 	DFTK_FN | DFTK_STR
d42c : 42                    	db 	DFTK_FN | DFTK_STR
d42d : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
d42e : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
d42f : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
d430 : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
d431 : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
d432 : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
d433 : 42                    	db 	DFTK_FN | DFTK_STR
d434 : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
d435 : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
d436 : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
d437 : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
                             	;* Operators add the order of precedence (0=high
d438 : 38                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 0
d439 : 38                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 0
d43a : 38                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 0
d43b : 39                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 1
d43c : 39                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 1
d43d : 3a                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 2
d43e : 3a                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 2
                             
d43f : 3d                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 5
d440 : 3e                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 6
d441 : 3b                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 3
d442 : 3b                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 3
d443 : 3b                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 3
d444 : 3b                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 3
d445 : 3b                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 3
d446 : 3f                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 7
                             
d447 : 44                    	db 	DFTK_STROP | DFTK_STR
d448 : 4b                    	db 	DFTK_OP | DFTK_STR + 3
d449 : 4b                    	db 	DFTK_OP | DFTK_STR + 3
d44a : 4b                    	db 	DFTK_OP | DFTK_STR + 3
d44b : 4b                    	db 	DFTK_OP | DFTK_STR + 3
d44c : 4b                    	db 	DFTK_OP | DFTK_STR + 3
d44d : 4f                    	db 	DFTK_OP | DFTK_STR + 7
                             
                             	
                             	
                             	
                             	
                             
                             	include "dflat\toksubs.s"
AS65 Assembler for R6502 [1.42].                                     Page   82
-------------------------------- bank\bank1.s --------------------------------

                             ;************************************************
                             ;*
                             ;*	DOLO-1 HOMEBREW COMPUTER
                             ;*	Hardware and software design by Dolo Miah
                             ;*	Copyright 2014-18
                             ;*  Free to use for any non-commercial purpose su
                             ;*  full credit of original my authorship please!
                             ;*
                             ;*  TOKSUBS.S
                             ;*  Module that implements the tokenisation of ke
                             ;*  When a line is being parsed, the index of the
                             ;*  found in the symbol table is used to call a r
                             ;*  here.  The job of a routine here is then to f
                             ;*  parse the raw input e.g. a command that takes
                             ;*  parameters, need to do what it needs to ident
                             ;*  Despite the number of keywords in dflat, this
                             ;*  anywhere near the size of rtsubs.s (the runti
                             ;*  equivalent of this) because there is so much 
                             ;*  synactically.
                             ;*  The tokenised output is put in to its own buf
                             ;*  if the whole input was tokenised successfully
                             ;*  dflat will either try and execute (if in imme
                             ;*  mode), or save it to program memory in line n
                             ;*  order.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
                             
                             ;****************************************
                             ;* Parse assignment preamble
                             ;****************************************
d44e :                       df_tk_preassign
                             	; Put assignment token
                             	; assume its a numeric int for now
d44e : a980             [ 2] 	lda #0x80
d450 : 206fcd           [ 6] 	jsr df_tk_put_tok
                             	
                             	; first find or create a variable
d453 : a900             [ 2] 	lda #0	
d455 : 20bbce           [ 6] 	jsr df_tk_var
                             	; next char sound be =
d458 : a93d             [ 2] 	lda #'='
d45a : 200bce           [ 6] 	jsr df_tk_expect_tok_err
                             	; skip more ws
d45d : 20c9cd           [ 6] 	jsr df_tk_skip_ws
                             	; should not be at end of line
d460 : 205ecd           [ 6] 	jsr df_tk_peek_buf
d463 : f002             [ 3] 	beq df_tk_parse_ass_err
d465 : 18               [ 2] 	clc
d466 : 60               [ 6] 	rts
d467 :                       df_tk_parse_ass_err
d467 :                       df_tk_error
                             	SWBRK DFERR_SYNTAX
                             
                             
                             ;****************************************
                             ;* Parse numeric assignment
                             ;****************************************
d469 :                       df_tk_assign
AS65 Assembler for R6502 [1.42].                                     Page   83
-------------------------------- bank\bank1.s --------------------------------

d469 : 204ed4           [ 6] 	jsr df_tk_preassign
                             	; tokenise an expression (int or byte)
d46c : 20e4cf           [ 6] 	jsr df_tk_expression
d46f : 18               [ 2] 	clc
d470 : 60               [ 6] 	rts
                             
                             
d471 :                       df_tk_comment
                             	; copy all subsequent chars to token
d471 : 2064cd           [ 6] 	jsr df_tk_get_buf
d474 : f005             [ 3] 	beq df_tk_comment_done
d476 : 206fcd           [ 6] 	jsr df_tk_put_tok
d479 : 80f6             [ 3] 	bra df_tk_comment
d47b :                       df_tk_comment_done
d47b : 18               [ 2] 	clc
d47c : 60               [ 6] 	rts
                             
                             ; Utility to get procedure name with _
d47d :                       df_tk_listp_procname
                             	; try and find the first proc
d47d : a95f             [ 2] 	lda #'_'
d47f : 20fecd           [ 6] 	jsr df_tk_expect_tok
d482 : b01a             [ 3] 	bcs df_tk_listp_procname_err
                             	; now get first alpha then all alphanum
d484 : 205ecd           [ 6] 	jsr df_tk_peek_buf
d487 : 20a6cd           [ 6] 	jsr df_tk_isalpha
d48a : 9012             [ 3] 	bcc df_tk_listp_procname_err
d48c :                       df_tk_listp_procname_ch
d48c : 205ecd           [ 6] 	jsr df_tk_peek_buf
d48f : 20b7cd           [ 6] 	jsr df_tk_isalphanum
d492 : 9008             [ 3] 	bcc df_tk_listp_procname_ok
d494 : 2064cd           [ 6] 	jsr df_tk_get_buf
d497 : 206fcd           [ 6] 	jsr df_tk_put_tok
d49a : 80f0             [ 3] 	bra df_tk_listp_procname_ch
d49c :                       df_tk_listp_procname_ok
d49c : 18               [ 2] 	clc
d49d : 60               [ 6] 	rts
d49e :                       df_tk_listp_procname_err
d49e : 38               [ 2] 	sec
d49f : 60               [ 6] 	rts
                             
d4a0 :                       df_tk_list
d4a0 : 207dd4           [ 6] 	jsr df_tk_listp_procname
                             	; if not found try '*' or normal list
d4a3 : b007             [ 3] 	bcs df_tk_list_procs
                             	; the '-' allows to list to end
d4a5 : a92d             [ 2] 	lda #'-'
                             	; find and add if it exists
d4a7 : 20fecd           [ 6] 	jsr df_tk_expect_tok
d4aa : 8014             [ 3] 	bra df_tk_list_done
                             	; '*' means list procs
d4ac :                       df_tk_list_procs
                             	; try and find the first proc
d4ac : a92a             [ 2] 	lda #'*'
d4ae : 20fecd           [ 6] 	jsr df_tk_expect_tok
d4b1 : 900d             [ 3] 	bcc df_tk_list_done
                             	; else normal line number
d4b3 :                       df_tk_list_line
                             	; tokenise an expression
d4b3 : 20e4cf           [ 6] 	jsr df_tk_expression
                             	; if not at the end then keep going
d4b6 : a92c             [ 2] 	lda #','
AS65 Assembler for R6502 [1.42].                                     Page   84
-------------------------------- bank\bank1.s --------------------------------

d4b8 : 20fecd           [ 6] 	jsr df_tk_expect_tok
d4bb : b003             [ 3] 	bcs df_tk_list_done
                             	; else get the next expression
d4bd : 20e4cf           [ 6] 	jsr df_tk_expression	
d4c0 :                       df_tk_list_done
d4c0 : 18               [ 2] 	clc
d4c1 : 60               [ 6] 	rts
                             
d4c2 :                       df_tk_printat
                             	; Must get 2 parms for x,y
d4c2 : 206ed5           [ 6] 	jsr df_tk_2parms
                             	; if not at the end then keep going
d4c5 : a92c             [ 2] 	lda #','
d4c7 : 20fecd           [ 6] 	jsr df_tk_expect_tok
d4ca : 9002             [ 3] 	bcc df_tk_print
                             	; else done
d4cc : 18               [ 2] 	clc
d4cd : 60               [ 6] 	rts
d4ce :                       df_tk_data
d4ce :                       df_tk_println
d4ce :                       df_tk_print
d4ce :                       df_tk_asm_db
d4ce :                       df_tk_asm_dw
                             	; tokenise an expression
d4ce : 20e4cf           [ 6] 	jsr df_tk_expression
                             	; is there more to come?
d4d1 : a92c             [ 2] 	lda #','
d4d3 : 20fecd           [ 6] 	jsr df_tk_expect_tok
d4d6 : b002             [ 3] 	bcs df_tk_print_done
d4d8 : 80f4             [ 3] 	bra df_tk_print
d4da :                       df_tk_print_done
d4da : 18               [ 2] 	clc
d4db : 60               [ 6] 	rts
                             
d4dc :                       df_tk_input
d4dc : 20c9cd           [ 6] 	jsr df_tk_skip_ws
                             	; tokenise a variable
d4df : a900             [ 2] 	lda #0
d4e1 : 20bbce           [ 6] 	jsr df_tk_var
                             	; either cc or cs depending on error condition
d4e4 : 60               [ 6] 	rts
                             	
d4e5 :                       df_tk_read
d4e5 :                       df_tk_dim
d4e5 : 20c9cd           [ 6] 	jsr df_tk_skip_ws
                             	; tokenise a variable
d4e8 : a900             [ 2] 	lda #0
d4ea : 20bbce           [ 6] 	jsr df_tk_var
                             	; if not at the end then keep going
d4ed : a92c             [ 2] 	lda #','
d4ef : 20fecd           [ 6] 	jsr df_tk_expect_tok
d4f2 : 90f1             [ 3] 	bcc df_tk_dim
d4f4 : 18               [ 2] 	clc
d4f5 : 60               [ 6] 	rts
                             
d4f6 :                       df_tk_local
d4f6 : 20c9cd           [ 6] 	jsr df_tk_skip_ws
                             	; tokenise a variable
d4f9 : a900             [ 2] 	lda #0
d4fb : 20ebce           [ 6] 	jsr df_tk_localvar
                             	; if not at the end then keep going
d4fe : a92c             [ 2] 	lda #','
AS65 Assembler for R6502 [1.42].                                     Page   85
-------------------------------- bank\bank1.s --------------------------------

d500 : 20fecd           [ 6] 	jsr df_tk_expect_tok
d503 : 90f1             [ 4] 	bcc df_tk_local
d505 : 18               [ 2] 	clc
d506 : 60               [ 6] 	rts
                             
                             ; A = 0 : Def
                             ; A = 1 : Call
d507 :                       df_tk_def
d507 : a900             [ 2] 	lda #0
d509 : 20fdce           [ 6] 	jsr df_tk_proc
d50c : 60               [ 6] 	rts
                             
                             
                             ; syntax : for %a=1,10,1
d50d :                       df_tk_for
d50d : 20c9cd           [ 6] 	jsr df_tk_skip_ws
                             
                             	; tokenise the for variable
d510 : a901             [ 2] 	lda #DFVVT_INT
d512 : 20bbce           [ 6] 	jsr df_tk_var
                             
                             	; always expect '='
d515 : a93d             [ 2] 	lda #'='
d517 : 200bce           [ 6] 	jsr df_tk_expect_tok_err
                             
                             	; starting value
d51a : 20e4cf           [ 6] 	jsr df_tk_expression
                             	
                             	; always expect ',' separator
d51d : a92c             [ 2] 	lda #','
d51f : 200bce           [ 6] 	jsr df_tk_expect_tok_err
                             
                             	; ending value
d522 : 20e4cf           [ 6] 	jsr df_tk_expression
                             	
                             	; always expect ',' separator
d525 : a92c             [ 2] 	lda #','
d527 : 200bce           [ 6] 	jsr df_tk_expect_tok_err
                             	
                             	; step value
d52a : 20e4cf           [ 6] 	jsr df_tk_expression
d52d :                       df_tk_for_done
d52d : 18               [ 2] 	clc
d52e : 60               [ 6] 	rts
                             	
                             ; call to proc should not occur by itself
d52f :                       df_tk_callproc
d52f : 38               [ 2] 	sec
d530 : 60               [ 6] 	rts
                             
                             ; timer reset expects an int variable only
d531 :                       df_tk_reset
d531 : 20c9cd           [ 6] 	jsr df_tk_skip_ws
                             
                             	; tokenise a variable
d534 : a901             [ 2] 	lda #DFVVT_INT
d536 : 20bbce           [ 6] 	jsr df_tk_var
d539 : 60               [ 6] 	rts
                             
                             ; These functions expect 1 parmeter
d53a :                       df_tk_len
d53a :                       df_tk_chr
AS65 Assembler for R6502 [1.42].                                     Page   86
-------------------------------- bank\bank1.s --------------------------------

d53a :                       df_tk_key
d53a :                       df_tk_stick
d53a :                       df_tk_deek
d53a :                       df_tk_vpeek
d53a :                       df_tk_peek
d53a :                       df_tk_mem
d53a :                       df_tk_rnd
d53a :                       df_tk_hex
d53a :                       df_tk_asc
d53a :                       df_tk_val
d53a :                       df_tk_msbyte
d53a :                       df_tk_lsbyte
d53a : 20e4cf           [ 6] 	jsr df_tk_expression
d53d :                       df_tk_closebrkt
d53d : a929             [ 2] 	lda #')'
d53f : 200bce           [ 6] 	jsr df_tk_expect_tok_err
d542 : 60               [ 6] 	rts
                             
                             ; This function expects a variable only
d543 :                       df_tk_elapsed
d543 : 20c9cd           [ 6] 	jsr df_tk_skip_ws
                             
                             	; tokenise a variable
d546 : a901             [ 2] 	lda #DFVVT_INT
d548 : 20bbce           [ 6] 	jsr df_tk_var
                             	; must have close braket
d54b : 4c3dd5           [ 3] 	jmp df_tk_closebrkt
                             
                             ; These functions expect 2 parameters
d54e :                       df_tk_left
d54e :                       df_tk_right
d54e :                       df_tk_scrn
d54e : 206ed5           [ 6] 	jsr df_tk_2parms
d551 : 4c3dd5           [ 3] 	jmp df_tk_closebrkt
                             
                             ; These functions expect 3 parameters
d554 :                       df_tk_mid
d554 : 207ad5           [ 6] 	jsr df_tk_3parms
d557 : 4c3dd5           [ 3] 	jmp df_tk_closebrkt
                             
                             ; These functions expect 4 parameters
d55a :                       df_tk_call
d55a : 206ed5           [ 6] 	jsr df_tk_2parms
d55d : a92c             [ 2] 	lda #','
d55f : 200bce           [ 6] 	jsr df_tk_expect_tok_err
d562 : 206ed5           [ 6] 	jsr df_tk_2parms
d565 : 4c3dd5           [ 3] 	jmp df_tk_closebrkt
                             
                             ;all these commands require no parameters
d568 :                       df_tk_else
d568 :                       df_tk_endif
d568 :                       df_tk_enddef
d568 :                       df_tk_abort
d568 :                       df_tk_repeat
d568 :                       df_tk_next
d568 :                       df_tk_wend
d568 :                       df_tk_run
d568 :                       df_tk_add
d568 :                       df_tk_sadd
d568 :                       df_tk_dir
d568 :                       df_tk_cls
d568 :                       df_tk_new
AS65 Assembler for R6502 [1.42].                                     Page   87
-------------------------------- bank\bank1.s --------------------------------

d568 :                       df_tk_mult
d568 :                       df_tk_div
d568 :                       df_tk_mod
d568 :                       df_tk_asl
d568 :                       df_tk_lsr
d568 :                       df_tk_sub
d568 :                       df_tk_and
d568 :                       df_tk_or
d568 :                       df_tk_lte
d568 :                       df_tk_lt
d568 :                       df_tk_gte
d568 :                       df_tk_gt
d568 :                       df_tk_ne
d568 :                       df_tk_eq
d568 :                       df_tk_slte
d568 :                       df_tk_sgte
d568 :                       df_tk_sne
d568 :                       df_tk_slt
d568 :                       df_tk_sgt
d568 :                       df_tk_seq
d568 :                       df_tk_monitor
d568 : 18               [ 2] 	clc
d569 : 60               [ 6] 	rts
                             
                             ; These commands expect 1 parameter	
d56a :                       df_tk_while
d56a :                       df_tk_until
d56a :                       df_tk_if
d56a :                       df_tk_elseif
d56a :                       df_tk_wait
d56a :                       df_tk_cursor
d56a :                       df_tk_mode
d56a :                       df_tk_del
d56a :                       df_tk_chdir
d56a :                       df_tk_hires
d56a :                       df_tk_return
d56a :                       df_tk_load
d56a :                       df_tk_save
d56a :                       df_tk_pixmode
d56a :                       df_tk_pixmask
d56a :                       df_tk_pixcol
d56a :                       df_tk_himem
                             
d56a :                       df_tk_asm_org
d56a :                       df_tk_asm_opt
d56a :                       df_tk_asm_ds
                             
                             	; first parm
d56a : 20e4cf           [ 6] 	jsr df_tk_expression
d56d : 60               [ 6] 	rts
                             
                             ; These commands expect 2 numeric parameters
d56e :                       df_tk_setvdp
d56e :                       df_tk_spritepat
d56e :                       df_tk_spritecol
d56e :                       df_tk_spritenme
d56e :                       df_tk_vpoke
d56e :                       df_tk_poke
d56e :                       df_tk_doke
d56e :                       df_tk_point
d56e :                       df_tk_vload
d56e :                       df_tk_2parms
AS65 Assembler for R6502 [1.42].                                     Page   88
-------------------------------- bank\bank1.s --------------------------------

                             	; first parm
d56e : 20e4cf           [ 6] 	jsr df_tk_expression
d571 : a92c             [ 2] 	lda #','
d573 : 200bce           [ 6] 	jsr df_tk_expect_tok_err
                             	; tokenise second parm
d576 : 20e4cf           [ 6] 	jsr df_tk_expression
d579 : 60               [ 6] 	rts
                             
                             ; these commands expect 3 numeric parameters
d57a :                       df_tk_hplot
d57a :                       df_tk_plot
d57a :                       df_tk_circle
d57a :                       df_tk_sound
d57a :                       df_tk_colour
d57a :                       df_tk_spritepos
d57a :                       df_tk_shape
d57a :                       df_tk_renum
d57a :                       df_tk_3parms
d57a : 206ed5           [ 6] 	jsr df_tk_2parms
d57d : a92c             [ 2] 	lda #','
d57f : 200bce           [ 6] 	jsr df_tk_expect_tok_err
                             	; tokenise third parm
d582 : 20e4cf           [ 6] 	jsr df_tk_expression
d585 : 60               [ 6] 	rts
                             
                             ; these commands expect 4 numeric parameters
d586 :                       df_tk_play
d586 :                       df_tk_music
d586 :                       df_tk_line
d586 :                       df_tk_box
d586 :                       df_tk_bload
d586 :                       df_tk_4parms
d586 : 206ed5           [ 6] 	jsr df_tk_2parms
d589 : a92c             [ 2] 	lda #','
d58b : 200bce           [ 6] 	jsr df_tk_expect_tok_err
d58e : 206ed5           [ 6] 	jsr df_tk_2parms
d591 : 60               [ 6] 	rts
                             
                             ; these commands expect 5 numeric parameters
d592 :                       df_tk_sprite
d592 :                       df_tk_bsave
d592 :                       df_tk_5parms
d592 : 2086d5           [ 6] 	jsr df_tk_4parms
d595 : a92c             [ 2] 	lda #','
d597 : 200bce           [ 6] 	jsr df_tk_expect_tok_err
d59a : 20e4cf           [ 6] 	jsr df_tk_expression
d59d : 60               [ 6] 	rts
                             
                             
                             
d59e :                       mod_sz_tokenise_e
                             
                             
                             
                             	include "dflat\progedit.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
AS65 Assembler for R6502 [1.42].                                     Page   89
-------------------------------- bank\bank1.s --------------------------------

                             ;*
                             ;*  PROGEDIT.S
                             ;*  dflat module to enable editing of a dflat pro
                             ;*  dflat bascially starts here - waiting for use
                             ;*  when a line is entered, if it is not preceede
                             ;*  line number it is tokenised and attempted to 
                             ;*  immediatly.  If it is preceeded by a line num
                             ;*  number is used to save the tokenised line in 
                             ;*  position in memory.
                             ;*  So this is just like a good old editing sessi
                             ;*  nearly any common flavour of 80s basic. Howev
                             ;*  tokenises everything except whitespace and st
                             ;*  constants - even when saving.  Unlike my trus
                             ;*  where I could type in any garbage and it woul
                             ;*  saved with the line number, dflat needs to be
                             ;*  tokenise the line.  So it's actually a bit mo
                             ;*  Atari 8 bit BASIC.
                             ;*
                             ;************************************************
                             
                             
                             ;****************************************
                             ;* df_pg_find_line
                             ;* Find a line number in X(L), A(H)
                             ;* Return X(L), A(H) of line, Y = Length
                             ;* C=1 Exact match not found, C=0 Exact Found
                             ;* If not exact match then next highest line addr
                             ;* Will be in X and A
                             ;****************************************
d59e :                       df_pg_find_line
d59e : 868e             [ 3] 	stx num_a
d5a0 : 858f             [ 3] 	sta num_a+1
d5a2 : a5ae             [ 3] 	lda df_prgstrt
d5a4 : 859a             [ 3] 	sta num_tmp
d5a6 : a5af             [ 3] 	lda df_prgstrt+1
d5a8 : 859b             [ 3] 	sta num_tmp+1
d5aa :                       df_pg_check_next_line
d5aa : a59a             [ 3] 	lda num_tmp
d5ac : c5b0             [ 3] 	cmp df_prgend
d5ae : d00f             [ 3] 	bne df_pg_check_line
d5b0 : a59b             [ 3] 	lda num_tmp+1
d5b2 : c5b1             [ 3] 	cmp df_prgend+1
d5b4 : d009             [ 3] 	bne df_pg_check_line
d5b6 :                       df_pr_line_gt_target	
                             	; End of program or line > target
                             	; Load Y with the length
d5b6 : b29a             [ 5] 	lda (num_tmp)
d5b8 : a8               [ 2] 	tay
d5b9 : a69a             [ 3] 	ldx num_tmp
d5bb : a59b             [ 3] 	lda num_tmp+1
d5bd : 38               [ 2] 	sec
d5be : 60               [ 6] 	rts
d5bf :                       df_pg_check_line
d5bf : a001             [ 2] 	ldy #DFTK_LINNUM
d5c1 : a58e             [ 3] 	lda num_a
d5c3 : d19a             [ 5] 	cmp (num_tmp),y
d5c5 : d010             [ 3] 	bne df_pr_line_nomatch
d5c7 : c8               [ 2] 	iny
d5c8 : a58f             [ 3] 	lda num_a+1
d5ca : d19a             [ 5] 	cmp (num_tmp),y
d5cc : d009             [ 3] 	bne df_pr_line_nomatch
                             	; Got an exact match
AS65 Assembler for R6502 [1.42].                                     Page   90
-------------------------------- bank\bank1.s --------------------------------

d5ce : b29a             [ 5] 	lda (num_tmp)
d5d0 : a8               [ 2] 	tay
d5d1 : a69a             [ 3] 	ldx num_tmp
d5d3 : a59b             [ 3] 	lda num_tmp+1
d5d5 : 18               [ 2] 	clc
d5d6 : 60               [ 6] 	rts
d5d7 :                       df_pr_line_nomatch
                             	; Check if this line > target
d5d7 : 38               [ 2] 	sec
d5d8 : a001             [ 2] 	ldy #DFTK_LINNUM
d5da : a58e             [ 3] 	lda num_a
d5dc : f19a             [ 5] 	sbc (num_tmp),y
d5de : c8               [ 2] 	iny
d5df : a58f             [ 3] 	lda num_a+1
d5e1 : f19a             [ 5] 	sbc (num_tmp),y
d5e3 : 90d1             [ 3] 	bcc df_pr_line_gt_target
d5e5 :                       df_pr_line_next
                             	; Else we go to next line
d5e5 : 18               [ 2] 	clc
d5e6 : a59a             [ 3] 	lda num_tmp
d5e8 : 729a             [ 5] 	adc (num_tmp)
d5ea : 859a             [ 3] 	sta num_tmp
d5ec : a59b             [ 3] 	lda num_tmp+1
d5ee : 6900             [ 2] 	adc #0
d5f0 : 859b             [ 3] 	sta num_tmp+1
d5f2 : 80b6             [ 3] 	bra df_pg_check_next_line
                             	
                             ;****************************************
                             ;* df_pg_insert_block
                             ;* Insert a block at adr (X, A) of size Y
                             ;* df_prgend updated
                             ;* C=1 Error, C=0 Ok
                             ;****************************************
d5f4 :                       df_pg_insert_block
                             	; Inserting requires a block copy from
                             	; end of program space to the insert address
                             	
                             	; Save address as this is the lowest address
d5f4 : 868e             [ 3] 	stx num_a
d5f6 : 858f             [ 3] 	sta num_a+1
                             	; End of program space is the first byte to move
d5f8 : a5b0             [ 3] 	lda df_prgend
d5fa : 8596             [ 3] 	sta num_x
d5fc : a5b1             [ 3] 	lda df_prgend+1
d5fe : 8597             [ 3] 	sta num_x+1	
d600 :                       df_pg_insert_byte
                             	; Move a byte from the current top
d600 : b296             [ 5] 	lda (num_x)
                             	; To the new top (+Y)
d602 : 9196             [ 5] 	sta (num_x),y
                             	; Compare current address with lowest
d604 : a596             [ 3] 	lda num_x
d606 : c58e             [ 3] 	cmp num_a
d608 : d014             [ 3] 	bne df_pg_insert_next_byte
d60a : a597             [ 3] 	lda num_x+1
d60c : c58f             [ 3] 	cmp num_a+1
d60e : d00e             [ 3] 	bne df_pg_insert_next_byte
                             	; Finished, update program end pointer
d610 : 18               [ 2] 	clc
d611 : 98               [ 2] 	tya
d612 : 65b0             [ 3] 	adc df_prgend
d614 : 85b0             [ 3] 	sta df_prgend
AS65 Assembler for R6502 [1.42].                                     Page   91
-------------------------------- bank\bank1.s --------------------------------

d616 : a5b1             [ 3] 	lda df_prgend+1
d618 : 6900             [ 2] 	adc #0
d61a : 85b1             [ 3] 	sta df_prgend+1
d61c : 18               [ 2] 	clc
d61d : 60               [ 6] 	rts
d61e :                       df_pg_insert_next_byte
                             	; Decrement current address
d61e : 38               [ 2] 	sec
d61f : a596             [ 3] 	lda num_x
d621 : e901             [ 2] 	sbc #1
d623 : 8596             [ 3] 	sta num_x
d625 : a597             [ 3] 	lda num_x+1
d627 : e900             [ 2] 	sbc #0
d629 : 8597             [ 3] 	sta num_x+1
d62b : 80d3             [ 3] 	bra df_pg_insert_byte
                             
                             ;****************************************
                             ;* df_pg_delete_block
                             ;* Delete a block at adr (X, A) of size Y
                             ;* df_prgend updated
                             ;* C=1 Error, C=0 Ok
                             ;****************************************
d62d :                       df_pg_delete_block
                             	; Deleting requires a block copy from
                             	; deletion address to end of program
                             	
                             	; Save address as this is the start address
d62d : 868e             [ 3] 	stx num_a
d62f : 858f             [ 3] 	sta num_a+1
d631 :                       df_pg_delete_byte
                             	; Move a byte from current+Y
d631 : b18e             [ 5] 	lda (num_a),y
                             	; Down to current
d633 : 928e             [ 5] 	sta (num_a)
                             	; Compare current address with lowest
d635 : a58e             [ 3] 	lda num_a
d637 : c5b0             [ 3] 	cmp df_prgend
d639 : d017             [ 3] 	bne df_pg_delete_next_byte
d63b : a58f             [ 3] 	lda num_a+1
d63d : c5b1             [ 3] 	cmp df_prgend+1
d63f : d011             [ 3] 	bne df_pg_delete_next_byte
                             	; Finished, update program end pointer
d641 : 848e             [ 3] 	sty num_a
d643 : 38               [ 2] 	sec
d644 : a5b0             [ 3] 	lda df_prgend
d646 : e58e             [ 3] 	sbc num_a
d648 : 85b0             [ 3] 	sta df_prgend
d64a : a5b1             [ 3] 	lda df_prgend+1
d64c : e900             [ 2] 	sbc #0
d64e : 85b1             [ 3] 	sta df_prgend+1
d650 : 18               [ 2] 	clc
d651 : 60               [ 6] 	rts
d652 :                       df_pg_delete_next_byte
                             	; Decrement current address
d652 : 18               [ 2] 	clc
d653 : a58e             [ 3] 	lda num_a
d655 : 6901             [ 2] 	adc #1
d657 : 858e             [ 3] 	sta num_a
d659 : a58f             [ 3] 	lda num_a+1
d65b : 6900             [ 2] 	adc #0
d65d : 858f             [ 3] 	sta num_a+1
d65f : 80d0             [ 3] 	bra df_pg_delete_byte
AS65 Assembler for R6502 [1.42].                                     Page   92
-------------------------------- bank\bank1.s --------------------------------

                             
                             
                             ;****************************************
                             ;* Get a line of input
                             ;* Input: C=1 for echo, 0 for no echo
                             ;* Output: C=0 means linbuff is valid
                             ;****************************************
d661 :                       df_pg_inputline
                             	; C is set on input for echo or not
                             	; Read a line of input
d661 : 2058c4           [ 6] 	jsr io_read_line
                             	; If nothing entered then sec
d664 : c000             [ 2] 	cpy #0
d666 : d002             [ 3] 	bne df_pg_inputline_ok
d668 : 38               [ 2] 	sec
d669 : 60               [ 6] 	rts
d66a :                       df_pg_inputline_ok
                             	; Copy input bytes to line buffer
                             	; for lexical analysis
d66a :                       df_pg_copyinputtolinbuff
d66a : b140             [ 5] 	lda (buf_lo),y
d66c : 990009           [ 5] 	sta df_linbuff,y
d66f : 88               [ 2] 	dey
d670 : 10f8             [ 3] 	bpl df_pg_copyinputtolinbuff
d672 : 18               [ 2] 	clc
d673 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Tokenise line buffer
                             ;* Set line to 0x0000 if immediate line
                             ;****************************************
d674 :                       df_pg_tokeniseline
d674 : 4c23d0           [ 3] 	jmp df_lexer_line
                             
                             ;****************************************
                             ;* df_pg_dflat
                             ;* Start a dflat editing session
                             ;****************************************
d677 :                       df_pg_dflat
                             	; stack pointer
d677 : ba               [ 2] 	tsx
d678 : 86a8             [ 3] 	stx df_sp
                             	; error handler address
d67a : a914             [ 2] 	lda #lo(df_trap_error)
d67c : 85a9             [ 3] 	sta df_pc
d67e : a9f1             [ 2] 	lda #hi(df_trap_error)
d680 : 85aa             [ 3] 	sta df_pc+1
                             	
                             	; make sure normal I/O is resumed
                             	;jsr io_init_default
d682 :                       df_pg_prompt
d682 : a2fe             [ 2] 	ldx #lo(df_pg_prompt_msg)
d684 : a9d6             [ 2] 	lda #hi(df_pg_prompt_msg)
d686 : 2091c4           [ 6] 	jsr io_print_line
d689 : 64a7             [ 3] 	stz df_immed
d68b :                       df_pg_getcommand
                             	; current line is the token buffer when editing
d68b : a980             [ 2] 	lda #lo(df_tokbuff)
d68d : 85cf             [ 3] 	sta df_currlin
d68f : a909             [ 2] 	lda #hi(df_tokbuff)
d691 : 85d0             [ 3] 	sta df_currlin+1
d693 : 38               [ 2] 	sec
AS65 Assembler for R6502 [1.42].                                     Page   93
-------------------------------- bank\bank1.s --------------------------------

d694 : 2061d6           [ 6] 	jsr df_pg_inputline
d697 : b01a             [ 3] 	bcs df_pg_done
d699 : 20b5d6           [ 6] 	jsr df_pg_tokenise
d69c : a5a7             [ 3] 	lda df_immed
d69e : f0eb             [ 3] 	beq df_pg_getcommand
                             	; clear variables ready to run the statement
d6a0 : 2005d7           [ 6] 	jsr df_initrun
                             	; run from tokbuff
d6a3 : a280             [ 2] 	ldx #lo(df_tokbuff)
d6a5 : a909             [ 2] 	lda #hi(df_tokbuff)
                             	; always skip length and line number
d6a7 : a003             [ 2] 	ldy #3
d6a9 : 84d1             [ 3] 	sty df_exeoff
                             	; init currlin
d6ab : 20acda           [ 6] 	jsr df_rt_init_stat_ptr
                             	; start execution
d6ae : 20bdda           [ 6] 	jsr df_rt_exec_stat
                             	; Go and get another line of input
d6b1 : 80cf             [ 3] 	bra df_pg_prompt
                             	; if blank line then return to cmd
d6b3 :                       df_pg_done
d6b3 : 18               [ 2] 	clc
d6b4 : 60               [ 6] 	rts
                             
                             	; tokenise the line
d6b5 :                       df_pg_tokenise
d6b5 : 64a6             [ 3] 	stz errno
d6b7 : 2074d6           [ 6] 	jsr df_pg_tokeniseline
                             	; check if line number == 0
d6ba : ad8109           [ 4] 	lda df_tokbuff+DFTK_LINNUM
d6bd : d00a             [ 3] 	bne df_pg_line_number
d6bf : ad8209           [ 4] 	lda df_tokbuff+DFTK_LINNUM+1
d6c2 : d005             [ 3] 	bne df_pg_line_number
                             	
                             	; line number == 0 so in immediate mode from tok
                             	; don't zero out the line length as some routine
                             	; run the line in immediate mode
d6c4 : a901             [ 2] 	lda #1
d6c6 : 85a7             [ 3] 	sta df_immed
d6c8 : 60               [ 6] 	rts
                             
                             	; put the numbered line in to the right bit of m
d6c9 :                       df_pg_line_number
                             	; Check if this line exists
d6c9 : ad8109           [ 4] 	lda df_tokbuff+DFTK_LINNUM
d6cc : aa               [ 2] 	tax
d6cd : ad8209           [ 4] 	lda df_tokbuff+DFTK_LINNUM+1
d6d0 : 209ed5           [ 6] 	jsr df_pg_find_line
                             	; Save line address for later
d6d3 : da               [ 3] 	phx
d6d4 : 48               [ 3] 	pha
                             	; If line exists then it needs deleting
d6d5 : b003             [ 3] 	bcs df_pg_skip_del_line
                             
                             	; delete line from program
d6d7 : 202dd6           [ 6] 	jsr df_pg_delete_block
d6da :                       df_pg_skip_del_line
                             	; If line length is zero
                             	; then nothing else to do (i.e. line was deleted
d6da : ad8009           [ 4] 	lda df_tokbuff+DFTK_LINLEN
                             	; save the tokenised line length
d6dd : 48               [ 3] 	pha
AS65 Assembler for R6502 [1.42].                                     Page   94
-------------------------------- bank\bank1.s --------------------------------

d6de : d004             [ 3] 	bne df_pg_insertline
                             	; Length was zero, so get temp stuff off stack
d6e0 : 68               [ 4] 	pla
d6e1 : 68               [ 4] 	pla
d6e2 : 68               [ 4] 	pla
d6e3 : 60               [ 6] 	rts
                             
                             	; insert a program line unless it is immediate
d6e4 :                       df_pg_insertline
                             	; Restore previously saved length
d6e4 : 7a               [ 4] 	ply
                             	; Restore previously saved address to reinsert t
d6e5 : 68               [ 4] 	pla
d6e6 : fa               [ 4] 	plx
                             	; And save it all back to stack again
d6e7 : da               [ 3] 	phx
d6e8 : 48               [ 3] 	pha
d6e9 : 5a               [ 3] 	phy
                             	; We now have insert address and length
d6ea : 20f4d5           [ 6] 	jsr df_pg_insert_block
                             	; Restore length and sub 1 to get index in to th
d6ed : 7a               [ 4] 	ply
d6ee : 88               [ 2] 	dey
                             	; Restore address to a pointer
d6ef : 68               [ 4] 	pla
d6f0 : 858f             [ 3] 	sta num_a+1
d6f2 : fa               [ 4] 	plx
d6f3 : 868e             [ 3] 	stx num_a
                             	; num_a is destination, tokbuff is source, Y is 
d6f5 :                       df_pg_insertlinbyte
d6f5 : b98009           [ 4] 	lda df_tokbuff,y
d6f8 : 918e             [ 5] 	sta (num_a),y
d6fa : 88               [ 2] 	dey
d6fb : 10f8             [ 3] 	bpl df_pg_insertlinbyte
d6fd : 60               [ 6] 	rts
                             	
d6fe :                       df_pg_prompt_msg
d6fe : 52656164790d00        	db "Ready",UTF_CR,0
                             
                             	include "dflat\runtime.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  RUNTIME.S
                             ;*  This module is the runtime coordinator.  When
                             ;*  wants to run a program, execution of statemen
                             ;*  required procedure starts and proceeds from t
                             ;*  according to normal program flow.
                             ;*  This module also contains critical routines f
                             ;*  evaluation of expressions (numeric and string
                             ;*  Whilst the code to implement a specific comma
                             ;*  rtsubs.s, this is the key module that control
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
AS65 Assembler for R6502 [1.42].                                     Page   95
-------------------------------- bank\bank1.s --------------------------------

                             
d705 :                       mod_sz_runtime_s
                             
                             ;****************************************
                             ;* df_initrun
                             ;* Initialise program space for runtime
                             ;****************************************
d705 :                       df_initrun
                             	; String and array heap initialisation
                             	; Grows up from end of prog space PLUS 1
                             	; Initially empty (dim will allocate)
                             	_cpyZPWord df_prgend,df_starstrt
                             
                             	_incZPWord df_starstrt
                             
                             	_cpyZPWord df_starstrt,df_starend
                             
                             	
                             	; Reset runtime stack (grows up)
d71b : 64bf             [ 3] 	stz df_rtstop
                             
                             	; Reset parameter stack (grows up)
d71d : 64c0             [ 3] 	stz df_parmtop
                             	
                             	; Reset data pointer high byte
d71f : 64e8             [ 3] 	stz df_currdat+1
                             	
                             	; clear proc addresses
d721 : 2027d7           [ 6] 	jsr df_rt_init_vvt
                             
                             	; if nest counter zeroed
d724 : 64e6             [ 3] 	stz df_ifnest
                             
                             ;	clc
d726 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Initialise vvt
                             ;****************************************
d727 :                       df_rt_init_vvt
                             	; starting at beginning of vvt
                             	_cpyZPWord df_vvtstrt,df_tmpptra
                             
d72f : a6ba             [ 3] 	ldx df_varcnt
d731 : f02d             [ 3] 	beq df_rt_init_done
d733 :                       df_rt_init_vvt_slot
                             	; Only zero out proc and array pointers
                             	; Scalar variables are not initialised
d733 : b2d4             [ 5] 	lda (df_tmpptra)
d735 : 29c0             [ 2] 	and #DFVVT_PROC|DFVVT_ARRY
d737 : f017             [ 3] 	beq df_rt_init_vvt_skip
                             	; skip over the first byte which is variable typ
d739 : a001             [ 2] 	ldy #1
                             	; zero out first 3 bytes for proc and arrays
d73b : a900             [ 2] 	lda #0
d73d : 91d4             [ 5] 	sta (df_tmpptra),y
d73f : c8               [ 2] 	iny
d740 : 91d4             [ 5] 	sta (df_tmpptra),y
d742 : c8               [ 2] 	iny
d743 : 91d4             [ 5] 	sta (df_tmpptra),y
d745 : c8               [ 2] 	iny
                             	; before doing dim2 check if proc
AS65 Assembler for R6502 [1.42].                                     Page   96
-------------------------------- bank\bank1.s --------------------------------

                             	; as we don't want to erase the parm count
d746 : b2d4             [ 5] 	lda (df_tmpptra)
d748 : 2940             [ 2] 	and #DFVVT_PROC
d74a : d004             [ 3] 	bne df_rt_init_vvt_skip
                             	; if not proc then zero dim2
d74c : a900             [ 2] 	lda #0
d74e : 91d4             [ 5] 	sta (df_tmpptra),y	
d750 :                       df_rt_init_vvt_skip
                             	; increment pointer to next slot
                             	_adcZPWord df_tmpptra,8
                             
d75d : ca               [ 2] 	dex
d75e : d0d3             [ 3] 	bne df_rt_init_vvt_slot
d760 :                       df_rt_init_done
                             ;	clc
d760 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Evaluate a numeric expression
                             ;****************************************
d761 :                       df_rt_neval
                             	; push terminator on cpu stack
                             	; so we know where we are
d761 : a900             [ 2] 	lda #0
d763 : 48               [ 3] 	pha
                             
                             	; find escape token or keyword token
                             	; if escape token push on to operand stack
                             	; if keyword token push on to operator stack
d764 :                       df_rt_neval_optk
d764 : a4d1             [ 3] 	ldy df_exeoff
                             	; check end of line
d766 : c4c7             [ 3] 	cpy df_eolidx
d768 : f069             [ 3] 	beq df_rt_neval_process
d76a : c4c8             [ 3] 	cpy df_nxtstidx
d76c : f065             [ 3] 	beq df_rt_neval_process
d76e : b1cf             [ 5] 	lda (df_currlin),y
d770 : 3020             [ 3] 	bmi df_rt_neval_tk
d772 : c920             [ 2] 	cmp #DFTK_ESCVAL
d774 : 9017             [ 3] 	bcc df_rt_neval_esc
                             	; check for evaluation terminators
                             	; specifically ',' and ']'
d776 : c92c             [ 2] 	cmp #','
d778 : f059             [ 3] 	beq df_rt_neval_process
d77a : c95d             [ 2] 	cmp #']'
d77c : f055             [ 3] 	beq df_rt_neval_process
                             	; check for brackets
                             	; if close bracket then process
d77e : c929             [ 2] 	cmp #')'
d780 : f051             [ 3] 	beq df_rt_neval_process
                             	; if bracket then evaluate expression recursivel
d782 : c928             [ 2] 	cmp #'('
d784 : d049             [ 3] 	bne df_rt_neval_nextbyte
                             	; move past open bracket
d786 : e6d1             [ 5] 	inc df_exeoff
                             	; call evaluation function recursively
d788 : 2061d7           [ 6] 	jsr df_rt_neval
d78b : 8042             [ 3] 	bra df_rt_neval_nextbyte
d78d :                       df_rt_neval_esc
d78d : 20dcd7           [ 6] 	jsr df_rt_eval_esc
d790 : 803d             [ 3] 	bra df_rt_neval_nextbyte
                             	; if a token then push on operator stack
AS65 Assembler for R6502 [1.42].                                     Page   97
-------------------------------- bank\bank1.s --------------------------------

d792 :                       df_rt_neval_tk
d792 : 297f             [ 2] 	and #0x7f
                             	; check if op (look up type using X as index)
                             	; X contains the current operator index
d794 : aa               [ 2] 	tax
d795 : bddfd3           [ 4] 	lda df_tk_tokentype,x
                             	; A contains token type
d798 : 85d6             [ 3] 	sta df_tmpptrb
d79a : 8908             [ 2] 	bit #DFTK_OP
d79c : d006             [ 3] 	bne df_rt_neval_tk_op
                             	; check if fn
d79e : 8902             [ 2] 	bit #DFTK_FN
d7a0 : d029             [ 3] 	bne df_rt_neval_tk_fn
                             
                             	; If got here then something wrong
                             	SWBRK DFERR_TYPEMISM
                             
                             	
d7a4 :                       df_rt_neval_tk_op
                             	; X=Op, A=Type
                             	; if this op < current top of op stack
                             	; then do the op as it is higher priority so sho
                             	; not be pushed
                             	; what is top of the op stack?
                             	; save current op token value
                             	; C=0 means process the op now, else don't
                             	; save current operator index
d7a4 : 86d4             [ 3] 	stx df_tmpptra
                             	; mask off to keep priority
d7a6 : 2907             [ 2] 	and #DFTK_OPMSK
d7a8 : 85d6             [ 3] 	sta df_tmpptrb
                             	; peek top of op stack - pull and push X
d7aa : fa               [ 4] 	plx
d7ab : da               [ 3] 	phx
                             	; if 0 then nothing so push op
d7ac : f018             [ 3] 	beq df_rt_neval_pushOp
                             	; use it to index in to type table
d7ae : bddfd3           [ 4] 	lda df_tk_tokentype,x
                             	; mask off to keep priority
d7b1 : 2907             [ 2] 	and #DFTK_OPMSK
                             	; compare with the saved token type which includ
d7b3 : c5d6             [ 3] 	cmp df_tmpptrb
                             	; if top of stack >= current then C=1
                             	; else C=0
                             	; what is the state of C?
                             	; if 1 then just pushOp
d7b5 : f002             [ 3] 	beq df_rt_neval_donow
d7b7 : b00d             [ 3] 	bcs df_rt_neval_pushOp
d7b9 :                       df_rt_neval_donow
                             	; was C=0 so process now before pushing the new 
                             	; get operator off cpu stack
d7b9 : 68               [ 4] 	pla
                             	; save the current op on cpu stack
d7ba : a6d4             [ 3] 	ldx df_tmpptra
d7bc : da               [ 3] 	phx
                             	; now run the token that came off the stack
d7bd : 201edb           [ 6] 	jsr df_rt_run_token
                             	; get current op off cpu stack in to X
d7c0 : fa               [ 4] 	plx
                             	; get the token type in to A
d7c1 : bddfd3           [ 4] 	lda df_tk_tokentype,x
                             	; now go back around again to check whether to p
AS65 Assembler for R6502 [1.42].                                     Page   98
-------------------------------- bank\bank1.s --------------------------------

d7c4 : 80de             [ 3] 	bra df_rt_neval_tk_op
d7c6 :                       df_rt_neval_pushOp
                             	; push the operator
d7c6 : a5d4             [ 3] 	lda df_tmpptra
d7c8 : 48               [ 3] 	pha
d7c9 : 8004             [ 3] 	bra df_rt_neval_nextbyte
                             
d7cb :                       df_rt_neval_tk_fn
d7cb : 8a               [ 2] 	txa
                             	; run a fn token - returns a value on stack
d7cc : 201edb           [ 6] 	jsr df_rt_run_token
                             	; move to next byte
d7cf :                       df_rt_neval_nextbyte
d7cf : e6d1             [ 5] 	inc df_exeoff
d7d1 : 8091             [ 3] 	bra df_rt_neval_optk
                             	; keep going until non-ws char found or end of l
                             
d7d3 :                       df_rt_neval_process	
                             	; pop operator off stack and execute
                             	; keep popping until reached the terminator
d7d3 : 68               [ 4] 	pla
d7d4 : f005             [ 3] 	beq df_rt_neval_done
                             	; run the token code
d7d6 : 201edb           [ 6] 	jsr df_rt_run_token
                             	; top two bytes on stack is the result
d7d9 : 80f8             [ 3] 	bra df_rt_neval_process
d7db :                       df_rt_neval_done
                             ;	clc
d7db : 60               [ 6] 	rts
                             
                             	
                             ; jump to escape evaluation routine
d7dc :                       df_rt_eval_esc
d7dc : 0a               [ 2] 	asl a
d7dd : aa               [ 2] 	tax
d7de : 7ce1d7           [ 6] 	jmp (df_rt_eval_esc_tab,x)
                             	
d7e1 :                       df_rt_eval_esc_tab
d7e1 : 9ed8                  	dw df_rt_eval_chr
d7e3 : aad8                  	dw df_rt_eval_reserved
d7e5 : aad8                  	dw df_rt_eval_reserved
d7e7 : aad8                  	dw df_rt_eval_reserved
d7e9 : aad8                  	dw df_rt_eval_reserved	
d7eb : aad8                  	dw df_rt_eval_reserved	; no such thing as bytdec
d7ed : 9ed8                  	dw df_rt_eval_bythex
d7ef : 9ed8                  	dw df_rt_eval_bytbin
d7f1 : aad8                  	dw df_rt_eval_reserved	
d7f3 : 9ed8                  	dw df_rt_eval_intdec
d7f5 : 9ed8                  	dw df_rt_eval_inthex
d7f7 : 9ed8                  	dw df_rt_eval_intbin
d7f9 : aad8                  	dw df_rt_eval_reserved
d7fb : aad8                  	dw df_rt_eval_reserved
d7fd : aad8                  	dw df_rt_eval_reserved
d7ff : aad8                  	dw df_rt_eval_reserved	
d801 : acd8                  	dw df_rt_eval_strlit
d803 : f2d8                  	dw df_rt_eval_var
d805 : dbd9                  	dw df_rt_eval_proc
                             
                             
                             ;****************************************
                             ;* Evaluate a numeric expression and get
                             ;* the result back off the stack in A,X
AS65 Assembler for R6502 [1.42].                                     Page   99
-------------------------------- bank\bank1.s --------------------------------

                             ;****************************************
d807 :                       df_rt_getnval
                             	; evaluate the expression
d807 : 2061d7           [ 6] 	jsr df_rt_neval
                             	; expecting an int/byte back
d80a : 4c73ef           [ 3] 	jmp df_st_popInt
                             
                             
                             ;****************************************
                             ;* Evaluate a string expression
                             ;* X, A = Destination buffer / space
                             ;****************************************
d80d :                       df_rt_seval
                             	; keep X,A on the stack - will be modified
d80d : 48               [ 3] 	pha
d80e : da               [ 3] 	phx
                             	; push original destination
d80f : 2048ef           [ 6] 	jsr df_st_pushStr
                             	; Push the destination to the 6502 stack
                             	; hi byte first then lo
                             	; push string idx so we know our starting positi
                             	; in the string buffer
                             	; this limits all evaluations to 255 bytes
                             ;	lda df_stridx
                             ;	jsr df_st_pushOp
                             
                             	; find escape token or keyword token
                             	; if escape token push on to operand stack
                             	; if keyword operator token push on to operator 
                             	; if keyword function token run it
                             
d812 :                       df_rt_seval_optk
d812 : a4d1             [ 3] 	ldy df_exeoff
                             	; check end of line
d814 : c4c7             [ 3] 	cpy df_eolidx
d816 : f069             [ 3] 	beq df_rt_seval_done
d818 : c4c8             [ 3] 	cpy df_nxtstidx
d81a : f065             [ 3] 	beq df_rt_seval_done
d81c : b1cf             [ 5] 	lda (df_currlin),y
d81e : 301c             [ 3] 	bmi df_rt_seval_tk
d820 : c920             [ 2] 	cmp #DFTK_ESCVAL
d822 : 900a             [ 3] 	bcc df_rt_seval_esc
                             	; check for evaluation terminators
                             	; specifically ',' and ')'
d824 : c92c             [ 2] 	cmp #','
d826 : f059             [ 3] 	beq df_rt_seval_done
d828 : c929             [ 2] 	cmp #')'
d82a : f055             [ 3] 	beq df_rt_seval_done
d82c : 804f             [ 3] 	bra df_rt_seval_nextbyte
d82e :                       df_rt_seval_esc
                             	; the only escape char is STRLIT, VAR or PROC
d82e : c910             [ 2] 	cmp #DFTK_STRLIT
d830 : f044             [ 3] 	beq	df_rt_seval_esc_strlit
d832 : c911             [ 2] 	cmp #DFTK_VAR
d834 : f024             [ 3] 	beq	df_rt_seval_esc_var
d836 : c912             [ 2] 	cmp #DFTK_PROC
d838 : f041             [ 3] 	beq	df_rt_seval_esc_proc
                             
                             	; error if got here
                             	SWBRK DFERR_SYNTAX
                             
                             
AS65 Assembler for R6502 [1.42].                                     Page  100
-------------------------------- bank\bank1.s --------------------------------

                             	; if a token then push on operator stack
d83c :                       df_rt_seval_tk
d83c : 84d1             [ 3] 	sty df_exeoff
d83e : 297f             [ 2] 	and #0x7f
                             	; check if op
d840 : aa               [ 2] 	tax
d841 : bddfd3           [ 4] 	lda df_tk_tokentype,x
d844 : 2904             [ 2] 	and #DFTK_STROP
d846 : d009             [ 3] 	bne df_rt_seval_tk_op
                             	; check if fn
d848 : bddfd3           [ 4] 	lda df_tk_tokentype,x
d84b : 2902             [ 2] 	and #DFTK_FN
d84d : d005             [ 3] 	bne df_rt_seval_tk_fn	
                             	
                             	; token type mismatch if got here
                             	SWBRK DFERR_TYPEMISM
                             
                             
d851 :                       df_rt_seval_tk_op
                             	; the only op is $+
                             	; so just ignore!
d851 : 8a               [ 2] 	txa
d852 : 8029             [ 3] 	bra df_rt_seval_nextbyte
                             
d854 :                       df_rt_seval_tk_fn
d854 : 8a               [ 2] 	txa
d855 : 201edb           [ 6] 	jsr df_rt_run_token
d858 : 8004             [ 3] 	bra df_rt_seval_copy
                             
d85a :                       df_rt_seval_esc_var
                             	; go process the variable as a normal RVAL
d85a : 18               [ 2] 	clc
d85b : 20f2d8           [ 6] 	jsr df_rt_eval_var
                             	; copy source off rt stack to destination
d85e :                       df_rt_seval_copy
                             	; pull destination pointer
d85e : 68               [ 4] 	pla
d85f : 85d4             [ 3] 	sta df_tmpptra
d861 : 68               [ 4] 	pla
d862 : 85d5             [ 3] 	sta df_tmpptra+1
                             	; pop source string pointer off stack
d864 : 2078ef           [ 6] 	jsr df_st_popStr
d867 : 86d6             [ 3] 	stx df_tmpptrb
d869 : 85d7             [ 3] 	sta df_tmpptrb+1
                             	; go and copy the string
d86b : 2085d8           [ 6] 	jsr df_rt_copyStr
                             	; now save the destination
d86e : a5d5             [ 3] 	lda df_tmpptra+1
d870 : 48               [ 3] 	pha
d871 : a5d4             [ 3] 	lda df_tmpptra
d873 : 48               [ 3] 	pha
                             	
d874 : 8007             [ 3] 	bra df_rt_seval_nextbyte
                             	
d876 :                       df_rt_seval_esc_strlit
                             	; evaluate string literal
d876 : 20acd8           [ 6] 	jsr df_rt_eval_strlit
d879 : 80e3             [ 3] 	bra df_rt_seval_copy
                             	
d87b :                       df_rt_seval_esc_proc
                             	; not yet suported *******
                             	SWBRK DFERR_RUNTIME
AS65 Assembler for R6502 [1.42].                                     Page  101
-------------------------------- bank\bank1.s --------------------------------

                             
                             	
d87d :                       df_rt_seval_nextbyte
d87d : e6d1             [ 5] 	inc df_exeoff
d87f : 8091             [ 3] 	bra df_rt_seval_optk
                             	; keep going until non-ws char found or end of l
d881 :                       df_rt_seval_done
                             	; 
d881 : 68               [ 4] 	pla
d882 : 68               [ 4] 	pla
                             	
d883 : 18               [ 2] 	clc
d884 : 60               [ 6] 	rts
                             
                             
                             ; Copy string from ptrb to ptra
d885 :                       df_rt_copyStr
d885 : a000             [ 2] 	ldy #0
d887 :                       df_rt_copyStr_ch
d887 : b1d6             [ 5] 	lda (df_tmpptrb),y
d889 : 91d4             [ 5] 	sta (df_tmpptra),y
d88b : f003             [ 3] 	beq df_rt_copyStr_done
d88d : c8               [ 2] 	iny
d88e : 80f7             [ 3] 	bra df_rt_copyStr_ch
d890 :                       df_rt_copyStr_done
d890 : 98               [ 2] 	tya
d891 : 18               [ 2] 	clc
d892 : 65d4             [ 3] 	adc df_tmpptra
d894 : 85d4             [ 3] 	sta df_tmpptra
d896 : a5d5             [ 3] 	lda df_tmpptra+1
d898 : 6900             [ 2] 	adc #0
d89a : 85d5             [ 3] 	sta df_tmpptra+1
d89c : 18               [ 2] 	clc
d89d : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* Evaluate and push numeric value
                             ;****************************************
d89e :                       df_rt_eval_intdec
d89e :                       df_rt_eval_bytdec
d89e :                       df_rt_eval_inthex
d89e :                       df_rt_eval_bythex
d89e :                       df_rt_eval_intbin
d89e :                       df_rt_eval_bytbin
d89e :                       df_rt_eval_chr
                             	; numeric constant
d89e : c8               [ 2] 	iny
d89f : b1cf             [ 5] 	lda (df_currlin),y
d8a1 : aa               [ 2] 	tax
d8a2 : c8               [ 2] 	iny
d8a3 : b1cf             [ 5] 	lda (df_currlin),y
                             	; save offset before calling any routine
d8a5 : 84d1             [ 3] 	sty df_exeoff
                             	; push number on to stack
d8a7 : 4c43ef           [ 3] 	jmp df_st_pushInt
                             
d8aa :                       df_rt_eval_reserved
                             	; should not get here
                             	SWBRK DFERR_RUNTIME
                             
                             
                             ;****************************************
AS65 Assembler for R6502 [1.42].                                     Page  102
-------------------------------- bank\bank1.s --------------------------------

                             ;* Evaluate and push string constant
                             ;****************************************
d8ac :                       df_rt_eval_strlit
d8ac : 84d1             [ 3] 	sty df_exeoff
                             	; calculate the effective address
                             	; y + currlin
d8ae : 98               [ 2] 	tya
                             	; set carry to add one extra
d8af : 38               [ 2] 	sec
d8b0 : 65cf             [ 3] 	adc df_currlin
d8b2 : 85d4             [ 3] 	sta df_tmpptra
d8b4 : aa               [ 2] 	tax
d8b5 : a5d0             [ 3] 	lda df_currlin+1
d8b7 : 6900             [ 2] 	adc #0
d8b9 : 85d5             [ 3] 	sta df_tmpptra+1
                             	
                             	; push string on to stack
d8bb : 2048ef           [ 6] 	jsr df_st_pushStr
                             	; now proceed until end of string found
d8be : a4d1             [ 3] 	ldy df_exeoff
d8c0 :                       df_rt_eval_strlit_ch
d8c0 : b1cf             [ 5] 	lda (df_currlin),y
d8c2 : f003             [ 3] 	beq df_rt_eval_strlit_done
d8c4 : c8               [ 2] 	iny
d8c5 : 80f9             [ 3] 	bra df_rt_eval_strlit_ch
d8c7 :                       df_rt_eval_strlit_done
d8c7 : 84d1             [ 3] 	sty df_exeoff
d8c9 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Return array parameter
                             ;* A has parm
                             ;****************************************
d8ca :                       df_rt_arry_parm
                             	; move past open bracket or comma
d8ca : e6d1             [ 5] 	inc df_exeoff
                             	; evaluate expression inside bracket
d8cc : 2007d8           [ 6] 	jsr df_rt_getnval
d8cf : 8a               [ 2] 	txa
                             ;	clc
d8d0 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* Return double array parameter
                             ;* X = dim1, Y = dim2
                             ;****************************************
d8d1 :                       df_rt_arry_parm2
                             	; go get array parm 1
d8d1 : 20cad8           [ 6] 	jsr df_rt_arry_parm
d8d4 : 48               [ 3] 	pha
d8d5 : a200             [ 2] 	ldx #0
d8d7 : a4d1             [ 3] 	ldy df_exeoff
d8d9 :                       df_rt_arry_parm2_term
d8d9 : b1cf             [ 5] 	lda (df_currlin),y
d8db : c95d             [ 2] 	cmp #']'
d8dd : f00f             [ 3] 	beq df_rt_arry_parm2_skiparry2
d8df : c92c             [ 2] 	cmp #','
d8e1 : f005             [ 3] 	beq df_rt_arry_parm2_arry2
d8e3 : 84d1             [ 3] 	sty df_exeoff
d8e5 : c8               [ 2] 	iny
d8e6 : 80f1             [ 3] 	bra df_rt_arry_parm2_term
d8e8 :                       df_rt_arry_parm2_arry2
AS65 Assembler for R6502 [1.42].                                     Page  103
-------------------------------- bank\bank1.s --------------------------------

                             	; get second dimension and put in Y
d8e8 : 20cad8           [ 6] 	jsr df_rt_arry_parm
d8eb : a8               [ 2] 	tay
d8ec : fa               [ 4] 	plx
                             ;	clc
d8ed : 60               [ 6] 	rts
d8ee :                       df_rt_arry_parm2_skiparry2
d8ee : a000             [ 2] 	ldy #0
d8f0 : fa               [ 4] 	plx
                             ;	clc
d8f1 : 60               [ 6] 	rts
                             
                             	
                             ;****************************************
                             ;* Evaluate and push variable
                             ;* The actual value is pushed if numeric
                             ;* The pointer is pushed if string
                             ;* Carry Set = LVAR else normal RVAR
                             ;* LVAR : Y = line index, A=vvt type, tmpptra = v
                             ;****************************************
d8f2 :                       df_rt_eval_var
                             	; save carry bit
d8f2 : 08               [ 3] 	php
                             	; if lvar mode then already passed escape token
d8f3 : b00a             [ 3] 	bcs df_rt_eval_lvskip
                             	; move past var escape token
d8f5 : c8               [ 2] 	iny
d8f6 : 84d1             [ 3] 	sty df_exeoff
                             	; get var index and convert to vvt address
d8f8 : b1cf             [ 5] 	lda (df_currlin),y
d8fa : 20d4ca           [ 6] 	jsr df_var_addr
                             	; push vvt type first as this is the last thing 
d8fd : b2d4             [ 5] 	lda (df_tmpptra)
d8ff :                       df_rt_eval_lvskip
d8ff : 48               [ 3] 	pha
                             	; Test A
d900 : aa               [ 2] 	tax
                             	; simple variable
d901 : 1012             [ 3] 	bpl df_rt_eval_var_notarry
                             	; even if an array if no dimensions then return 
                             	; if at end of statement or line then simple cop
d903 : c4c7             [ 3] 	cpy df_eolidx
d905 : f02b             [ 3] 	beq df_rt_eval_var_simple
d907 : c4c8             [ 3] 	cpy df_nxtstidx
d909 : f027             [ 3] 	beq df_rt_eval_var_simple
                             	; if next ch is not [ then simple copy
d90b : c8               [ 2] 	iny
d90c : b1cf             [ 5] 	lda (df_currlin),y
d90e : 88               [ 2] 	dey
d90f : c95b             [ 2] 	cmp #'['
d911 : d01f             [ 3] 	bne df_rt_eval_var_simple
                             	; go do array handling
d913 : 802d             [ 3] 	bra df_rt_eval_var_do_arry
d915 :                       df_rt_eval_var_notarry
                             	; pull the type but not needed here
d915 : 68               [ 4] 	pla
                             	; check if lvar wanted rather than rvar
d916 : 28               [ 4] 	plp
d917 : b00c             [ 3] 	bcs df_rt_eval_lvar
                             	; just push the vvt lo,hi value
d919 : a001             [ 2] 	ldy #DFVVT_LO
d91b : b1d4             [ 5] 	lda (df_tmpptra),y
AS65 Assembler for R6502 [1.42].                                     Page  104
-------------------------------- bank\bank1.s --------------------------------

d91d : aa               [ 2] 	tax
d91e : a002             [ 2] 	ldy #DFVVT_HI
d920 : b1d4             [ 5] 	lda (df_tmpptra),y
d922 : 4c43ef           [ 3] 	jmp df_st_pushInt
                             
d925 :                       df_rt_eval_lvar
                             	; it's not an array, push the address of DFVVT_L
                             	; add DFVVT_LO offset to slot address in X,A
d925 : 18               [ 2] 	clc
d926 : a901             [ 2] 	lda #DFVVT_LO
d928 : 65d4             [ 3] 	adc df_tmpptra
d92a : aa               [ 2] 	tax
d92b : a5d5             [ 3] 	lda df_tmpptra+1
d92d : 6900             [ 2] 	adc #0
                             
                             	; push pointer to lo,hi
d92f : 4c4def           [ 3] 	jmp df_st_pushPtr
                             	
d932 :                       df_rt_eval_var_simple
                             ;	clc
                             	; simply get lo,hi and push ptr on stack
d932 : a001             [ 2] 	ldy #DFVVT_LO
d934 : b1d4             [ 5] 	lda (df_tmpptra),y
d936 : aa               [ 2] 	tax
d937 : a002             [ 2] 	ldy #DFVVT_HI
d939 : b1d4             [ 5] 	lda (df_tmpptra),y
                             	; hi val saved in Y
d93b : a8               [ 2] 	tay
                             	; get the type and discard P
d93c : 68               [ 4] 	pla
d93d : 68               [ 4] 	pla
                             	; move Y to A
d93e : 98               [ 2] 	tya
d93f : 4c4def           [ 3] 	jmp df_st_pushPtr
                             	
d942 :                       df_rt_eval_var_do_arry
                             	; move past var index
d942 : e6d1             [ 5] 	inc df_exeoff
                             	; zero out x,y as they have dimension info
d944 : a200             [ 2] 	ldx #0
d946 : a000             [ 2] 	ldy #0
                             	
                             	; ** Array handling routine **
                             	; A on stack = type
                             	; save vvt address
d948 : a5d5             [ 3] 	lda df_tmpptra+1
d94a : 48               [ 3] 	pha
d94b : a5d4             [ 3] 	lda df_tmpptra
d94d : 48               [ 3] 	pha
                             	
                             	; get array parms in X,Y
d94e : 20d1d8           [ 6] 	jsr df_rt_arry_parm2
                             	; restore vvt address
d951 : 68               [ 4] 	pla
d952 : 85d4             [ 3] 	sta df_tmpptra
d954 : 68               [ 4] 	pla
d955 : 85d5             [ 3] 	sta df_tmpptra+1
                             	; save dimension indices for later
                             	; save x last as needed first
d957 : 5a               [ 3] 	phy
d958 : da               [ 3] 	phx
                             	; if y is zero then need to decide some stuff
AS65 Assembler for R6502 [1.42].                                     Page  105
-------------------------------- bank\bank1.s --------------------------------

d959 : c000             [ 2] 	cpy #0
d95b : d00e             [ 3] 	bne df_rt_eval_var_dim2adj
                             	; if dim2 > 0 then swap x,y
d95d : a004             [ 2] 	ldy #DFVVT_DIM2
d95f : b1d4             [ 5] 	lda (df_tmpptra),y
d961 : a000             [ 2] 	ldy #0
d963 : c900             [ 2] 	cmp #0
d965 : f004             [ 3] 	beq df_rt_eval_var_dim2adj
                             	; pop from stack in swapped order
d967 : 7a               [ 4] 	ply
d968 : fa               [ 4] 	plx
                             	; save back on stack
d969 : 5a               [ 3] 	phy
d96a : da               [ 3] 	phx
                             	
d96b :                       df_rt_eval_var_dim2adj
                             	; don't let y=0
d96b : c000             [ 2] 	cpy #0
d96d : d001             [ 3] 	bne df_rt_eval_var_dim2adjy
d96f : c8               [ 2] 	iny
d970 :                       df_rt_eval_var_dim2adjy
                             	; don't let x=0
d970 : e000             [ 2] 	cpx #0
d972 : d001             [ 3] 	bne df_rt_eval_var_dim2adjx
d974 : e8               [ 2] 	inx
d975 :                       df_rt_eval_var_dim2adjx
                             	;calculate offset
                             	;(y-1)*dim1 + (x-1)
d975 : ca               [ 2] 	dex
d976 : 88               [ 2] 	dey
                             	; (y-1)
d977 : 848e             [ 3] 	sty num_a
d979 : 648f             [ 3] 	stz num_a+1
                             	; if y is 0 then no need to multiply
d97b : f00b             [ 3] 	beq df_rt_eval_var_nomult
                             	; (dim1)
d97d : a003             [ 2] 	ldy #DFVVT_DIM1
d97f : b1d4             [ 5] 	lda (df_tmpptra),y
d981 : 8592             [ 3] 	sta num_b
d983 : 6493             [ 3] 	stz num_b+1
                             	; (y-1)*dim1 num_a has result
d985 : 2025ca           [ 6] 	jsr int_fast_mult
d988 :                       df_rt_eval_var_nomult
                             	; move x to a
d988 : 8a               [ 2] 	txa
                             	; add x to num_a
d989 : 18               [ 2] 	clc
d98a : 658e             [ 3] 	adc num_a
d98c : 858e             [ 3] 	sta num_a
d98e : a58f             [ 3] 	lda num_a+1
d990 : 6900             [ 2] 	adc #0
d992 : 858f             [ 3] 	sta num_a+1
                             	; now have element offset in num_a
                             	; dimensions in x and y
d994 : fa               [ 4] 	plx
d995 : 7a               [ 4] 	ply
                             	; get type of variable originally found
d996 : 68               [ 4] 	pla
d997 : 48               [ 3] 	pha
d998 : 2901             [ 2] 	and #DFVVT_INT
d99a : f004             [ 3] 	beq df_rt_eval_var_push
                             	; if it is int then multiply offset by 2
AS65 Assembler for R6502 [1.42].                                     Page  106
-------------------------------- bank\bank1.s --------------------------------

d99c : 068e             [ 5] 	asl num_a
d99e : 268f             [ 5] 	rol num_a+1
d9a0 :                       df_rt_eval_var_push
                             	; add pointer in lo,hi to num_a
d9a0 : 18               [ 2] 	clc
d9a1 : a001             [ 2] 	ldy #DFVVT_LO
d9a3 : b1d4             [ 5] 	lda (df_tmpptra),y
d9a5 : 658e             [ 3] 	adc num_a
d9a7 : 858e             [ 3] 	sta num_a
d9a9 : a002             [ 2] 	ldy #DFVVT_HI
d9ab : b1d4             [ 5] 	lda (df_tmpptra),y
d9ad : d002             [ 3] 	bne df_rt_array_exists
                             	; if vvt address hi is zero then array not dimen
                             	SWBRK DFERR_DIM
                             
d9b1 :                       df_rt_array_exists
d9b1 : 658f             [ 3] 	adc num_a+1
d9b3 : 858f             [ 3] 	sta num_a+1	
                             	; get the type
d9b5 : 68               [ 4] 	pla
                             	; if not int or byte then push string
d9b6 : 2903             [ 2] 	and #DFVVT_INT|DFVVT_BYT
d9b8 : f019             [ 3] 	beq df_rt_eval_var_str
                             	; get LVAR preference
d9ba : 28               [ 4] 	plp
d9bb : b017             [ 3] 	bcs df_rt_eval_ptr
                             	; need to load lo and hi for int
                             	; but only lo for byt
d9bd : 2901             [ 2] 	and #DFVVT_INT
d9bf : f00a             [ 3] 	beq df_rt_eval_byt
                             	; push the contents pointed to by num_a
d9c1 : b28e             [ 5] 	lda (num_a)
d9c3 : aa               [ 2] 	tax
d9c4 : a001             [ 2] 	ldy #1
d9c6 : b18e             [ 5] 	lda (num_a),y
d9c8 : 4c43ef           [ 3] 	jmp df_st_pushInt
d9cb :                       df_rt_eval_byt
d9cb : b28e             [ 5] 	lda (num_a)
d9cd : aa               [ 2] 	tax
d9ce : a900             [ 2] 	lda #0
d9d0 : 4c43ef           [ 3] 	jmp df_st_pushInt
d9d3 :                       df_rt_eval_var_str
d9d3 : 28               [ 4] 	plp
d9d4 :                       df_rt_eval_ptr
                             ;	clc
                             	; put num_a not contents
d9d4 : a68e             [ 3] 	ldx num_a
d9d6 : a58f             [ 3] 	lda num_a+1
d9d8 : 4c4def           [ 3] 	jmp df_st_pushPtr
                             	
d9db :                       df_rt_eval_proc
d9db : a5c0             [ 3] 	lda df_parmtop				; Save current position of par
d9dd : 48               [ 3] 	pha
d9de : 20eeed           [ 6] 	jsr df_rt_proc				; Go and call the user functio
d9e1 : 68               [ 4] 	pla							; Get back the original parameter stac
d9e2 : c5c0             [ 3] 	cmp df_parmtop				; if it is the same, then no r
d9e4 : f002             [ 3] 	beq df_rt_eval_proc_err
d9e6 : 18               [ 2] 	clc
d9e7 : 60               [ 6] 	rts
d9e8 :                       df_rt_eval_proc_err
                             	; if no return value then report an errror
                             	SWBRK DFERR_RETURN
AS65 Assembler for R6502 [1.42].                                     Page  107
-------------------------------- bank\bank1.s --------------------------------

                             
                             
                             
                             
                             ;****************************************
                             ;* get two ints off the runtime stack
                             ;* first parm in ptrb, second in ptra
                             ;****************************************
d9ea :                       df_rt_get2Ints
                             	; the first int popped is actually the second pa
d9ea : 2073ef           [ 6] 	jsr df_st_popInt
d9ed : 86d6             [ 3] 	stx df_tmpptrb
d9ef : 85d7             [ 3] 	sta df_tmpptrb+1
                             
d9f1 : 2073ef           [ 6] 	jsr df_st_popInt
d9f4 : 86d4             [ 3] 	stx df_tmpptra
d9f6 : 85d5             [ 3] 	sta df_tmpptra+1
d9f8 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* get two strings off the runtime stack
                             ;* first parm in ptrb, second in ptra
                             ;****************************************
d9f9 :                       df_rt_get2Strs
                             	; the first int popped is actually the second pa
d9f9 : 2078ef           [ 6] 	jsr df_st_popStr
d9fc : 86d6             [ 3] 	stx df_tmpptrb
d9fe : 85d7             [ 3] 	sta df_tmpptrb+1
                             
da00 : 2078ef           [ 6] 	jsr df_st_popStr
da03 : 86d4             [ 3] 	stx df_tmpptra
da05 : 85d5             [ 3] 	sta df_tmpptra+1
da07 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ; common code for 2 ints runtime parsing
                             ;****************************************
da08 :                       df_rt_parm_2ints
                             	; evaluate 1st parm
da08 : 2061d7           [ 6] 	jsr df_rt_neval
                             	; jump over comma
da0b : e6d1             [ 5] 	inc df_exeoff
                             	; evaluate the 2nd parm
da0d : 2061d7           [ 6] 	jsr df_rt_neval
                             
                             	; pop 2nd parm
da10 : 2073ef           [ 6] 	jsr df_st_popInt
da13 : 86d6             [ 3] 	stx df_tmpptrb
da15 : 85d7             [ 3] 	sta df_tmpptrb+1
                             	; pop 1st parm
da17 : 2073ef           [ 6] 	jsr df_st_popInt
da1a : 86d4             [ 3] 	stx df_tmpptra
da1c : 85d5             [ 3] 	sta df_tmpptra+1
da1e : 60               [ 6] 	rts
                             
                             ;****************************************
                             ; common code for 3 ints runtime parsing
                             ;****************************************
da1f :                       df_rt_parm_3ints
                             	; evaluate 1st parm
da1f : 2061d7           [ 6] 	jsr df_rt_neval
da22 : e6d1             [ 5] 	inc df_exeoff
AS65 Assembler for R6502 [1.42].                                     Page  108
-------------------------------- bank\bank1.s --------------------------------

                             	; evaluate the 2nd parm
da24 : 2061d7           [ 6] 	jsr df_rt_neval
da27 : e6d1             [ 5] 	inc df_exeoff
                             	; evaluate the 3rd parm
da29 : 2061d7           [ 6] 	jsr df_rt_neval
                             
                             	; pop 3rd parm
da2c : 2073ef           [ 6] 	jsr df_st_popInt
da2f : 86d8             [ 3] 	stx df_tmpptrc
da31 : 85d9             [ 3] 	sta df_tmpptrc+1
                             	; pop 2nd parm
da33 : 2073ef           [ 6] 	jsr df_st_popInt
da36 : 86d6             [ 3] 	stx df_tmpptrb
da38 : 85d7             [ 3] 	sta df_tmpptrb+1
                             	; pop 1st parm
da3a : 2073ef           [ 6] 	jsr df_st_popInt
da3d : 86d4             [ 3] 	stx df_tmpptra
da3f : 85d5             [ 3] 	sta df_tmpptra+1
da41 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ; common code for 4 ints runtime parsing
                             ;****************************************
da42 :                       df_rt_parm_4ints
                             	; evaluate 1st parm
da42 : 2061d7           [ 6] 	jsr df_rt_neval
da45 : e6d1             [ 5] 	inc df_exeoff
                             	; evaluate the 2nd parm
da47 : 2061d7           [ 6] 	jsr df_rt_neval
da4a : e6d1             [ 5] 	inc df_exeoff
                             	; evaluate the 3rd parm
da4c : 2061d7           [ 6] 	jsr df_rt_neval
da4f : e6d1             [ 5] 	inc df_exeoff
                             	; evaluate the 4th parm
da51 : 2061d7           [ 6] 	jsr df_rt_neval
                             
                             	; pop 4th parm
da54 : 2073ef           [ 6] 	jsr df_st_popInt
da57 : 86da             [ 3] 	stx df_tmpptrd
da59 : 85db             [ 3] 	sta df_tmpptrd+1
                             	; pop 3rd parm
da5b : 2073ef           [ 6] 	jsr df_st_popInt
da5e : 86d8             [ 3] 	stx df_tmpptrc
da60 : 85d9             [ 3] 	sta df_tmpptrc+1
                             	; pop 2nd parm
da62 : 2073ef           [ 6] 	jsr df_st_popInt
da65 : 86d6             [ 3] 	stx df_tmpptrb
da67 : 85d7             [ 3] 	sta df_tmpptrb+1
                             	; pop 1st parm
da69 : 2073ef           [ 6] 	jsr df_st_popInt
da6c : 86d4             [ 3] 	stx df_tmpptra
da6e : 85d5             [ 3] 	sta df_tmpptra+1
da70 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ; common code for 5 ints runtime parsing
                             ;****************************************
da71 :                       df_rt_parm_5ints
                             	; evaluate 1st parm
da71 : 2061d7           [ 6] 	jsr df_rt_neval
da74 : e6d1             [ 5] 	inc df_exeoff
                             	; evaluate the 2nd parm
AS65 Assembler for R6502 [1.42].                                     Page  109
-------------------------------- bank\bank1.s --------------------------------

da76 : 2061d7           [ 6] 	jsr df_rt_neval
da79 : e6d1             [ 5] 	inc df_exeoff
                             	; evaluate the 3rd parm
da7b : 2061d7           [ 6] 	jsr df_rt_neval
da7e : e6d1             [ 5] 	inc df_exeoff
                             	; evaluate the 4th parm
da80 : 2061d7           [ 6] 	jsr df_rt_neval
da83 : e6d1             [ 5] 	inc df_exeoff
                             	; evaluate the 5th parm
da85 : 2061d7           [ 6] 	jsr df_rt_neval
                             
                             	; pop 5th parm
da88 : 2073ef           [ 6] 	jsr df_st_popInt
da8b : 86dc             [ 3] 	stx df_tmpptre
da8d : 85dd             [ 3] 	sta df_tmpptre+1
                             	; pop 4th parm
da8f : 2073ef           [ 6] 	jsr df_st_popInt
da92 : 86da             [ 3] 	stx df_tmpptrd
da94 : 85db             [ 3] 	sta df_tmpptrd+1
                             	; pop 3rd parm
da96 : 2073ef           [ 6] 	jsr df_st_popInt
da99 : 86d8             [ 3] 	stx df_tmpptrc
da9b : 85d9             [ 3] 	sta df_tmpptrc+1
                             	; pop 2nd parm
da9d : 2073ef           [ 6] 	jsr df_st_popInt
daa0 : 86d6             [ 3] 	stx df_tmpptrb
daa2 : 85d7             [ 3] 	sta df_tmpptrb+1
                             	; pop 1st parm
daa4 : 2073ef           [ 6] 	jsr df_st_popInt
daa7 : 86d4             [ 3] 	stx df_tmpptra
daa9 : 85d5             [ 3] 	sta df_tmpptra+1
                             
daab : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* initialise statement to be executed
                             ;* X,A = line pointer, Y=statement offset
                             ;****************************************
daac :                       df_rt_init_stat_ptr
                             	; save current line
daac : 86cf             [ 3] 	stx df_currlin
daae : 85d0             [ 3] 	sta df_currlin+1
dab0 : 84c9             [ 3] 	sty df_curstidx
dab2 : 84d1             [ 3] 	sty df_exeoff
dab4 : b2cf             [ 5] 	lda (df_currlin)
dab6 : 85c7             [ 3] 	sta df_eolidx
dab8 : b1cf             [ 5] 	lda (df_currlin),y
daba : 85c8             [ 3] 	sta df_nxtstidx
dabc : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* Execute from a statement pointed to
                             ;* by currlin and exeoff
                             ;****************************************
dabd :                       df_rt_exec_stat
dabd : a6cf             [ 3] 	ldx df_currlin
dabf : a5d0             [ 3] 	lda df_currlin+1
dac1 : a4d1             [ 3] 	ldy df_exeoff
dac3 :                       df_rt_exec_init_ptr
dac3 : 20acda           [ 6] 	jsr df_rt_init_stat_ptr
                             	; assume normal flow of control if next line hi 
                             	; this means no line can execute below page 1, n
AS65 Assembler for R6502 [1.42].                                     Page  110
-------------------------------- bank\bank1.s --------------------------------

dac6 : 64d3             [ 3] 	stz df_nextlin+1
                             
                             	; find first token in statement
dac8 :                       df_rt_exec_find_tok
dac8 : c8               [ 2] 	iny
dac9 : b1cf             [ 5] 	lda (df_currlin),y
dacb : 10fb             [ 3] 	bpl df_rt_exec_find_tok
dacd :                       df_rt_exec_found_tok
                             	; skip past token to next byte in readiness
dacd : c8               [ 2] 	iny
dace : 84d1             [ 3] 	sty df_exeoff
                             	; save the token
dad0 : 48               [ 3] 	pha
                             	; Run that statement
dad1 : 201edb           [ 6] 	jsr df_rt_run_token
                             	; what token was run, if it was enddef or return
dad4 : 68               [ 4] 	pla
dad5 : c987             [ 2] 	cmp #DFRT_ENDDEF
dad7 : f035             [ 4] 	beq df_rt_exec_end
dad9 : c988             [ 2] 	cmp #DFRT_RETURN
dadb : f031             [ 4] 	beq df_rt_exec_end
                             	
                             	; check for break, asynch get
dadd : 18               [ 2] 	clc
dade : 2046c4           [ 6] 	jsr io_get_ch
dae1 : c903             [ 2] 	cmp #UTF_ETX					; CTRL-C?
dae3 : f02b             [ 4] 	beq df_rt_exec_ctrl_c
dae5 : c91a             [ 2] 	cmp #UTF_BRK					; CTRK-Z?
dae7 : f02b             [ 4] 	beq df_rt_exec_ctrl_z
                             	; check if normal flow of control
dae9 : a5d3             [ 3] 	lda df_nextlin+1
daeb : d029             [ 4] 	bne df_rt_exec_jump
                             	; try and execute another statement
daed : a4c8             [ 3] 	ldy df_nxtstidx
daef : 84d1             [ 3] 	sty df_exeoff
daf1 : d0ca             [ 3] 	bne df_rt_exec_stat
                             
                             	; reached end of line, move to next
daf3 : 18               [ 2] 	clc
daf4 : b2cf             [ 5] 	lda (df_currlin)
daf6 : 65cf             [ 3] 	adc df_currlin
daf8 : 85cf             [ 3] 	sta df_currlin
dafa : a5d0             [ 3] 	lda df_currlin+1
dafc : 6900             [ 2] 	adc #0
dafe : 85d0             [ 3] 	sta df_currlin+1
                             	
                             	; start from first statement in new line
db00 : a003             [ 2] 	ldy #3
db02 : 84d1             [ 3] 	sty df_exeoff
                             
                             	; check if this line has any content (length >0)
db04 : b2cf             [ 5] 	lda (df_currlin)
db06 : 85c7             [ 3] 	sta df_eolidx
                             	; no more lines (len = 0), program done
db08 : d0b3             [ 4] 	bne df_rt_exec_stat
                             	; else done
                             	; normally wouldn't get here except immediate mo
                             	; if line number <> 0 then error
db0a : a5a7             [ 3] 	lda df_immed
db0c : f004             [ 3] 	beq df_rt_unexpected_end
db0e :                       df_rt_exec_end
db0e : 18               [ 2] 	clc
AS65 Assembler for R6502 [1.42].                                     Page  111
-------------------------------- bank\bank1.s --------------------------------

db0f : 60               [ 6] 	rts
db10 :                       df_rt_exec_ctrl_c
                             	SWBRK DFERR_BREAK
                             
db12 :                       df_rt_unexpected_end
                             	SWBRK DFERR_IMMEDIATE
                             
db14 :                       df_rt_exec_ctrl_z
                             	; Force a break with zero error number
                             	; this will drop in to the monitor
db14 : 0000                  	db 0,0
                             
                             	; if hi byte of nextline is not zero then
                             	; current line = next line
db16 :                       df_rt_exec_jump
                             	; initialise statement pointer from nextlin,toks
db16 : a6d2             [ 3] 	ldx df_nextlin
db18 : a5d3             [ 3] 	lda df_nextlin+1
db1a : a4c8             [ 3] 	ldy df_nxtstidx
db1c : 80a5             [ 4] 	bra df_rt_exec_init_ptr
                             
                             	
                             ;****************************************
                             ;* Run statement in A
                             ;****************************************
db1e :                       df_rt_run_token
                             	; mask off MSB
                             ;	and #0x7f
                             	; multiply by 2
db1e : 0a               [ 2] 	asl a
db1f : aa               [ 2] 	tax
                             	; execution code finishes with rts
db20 : 7ceedb           [ 6] 	jmp (df_rt_tokenjmp,x)
                             
                             
                             ;****************************************
                             ;* X,A : Line Address, Y = Index
                             ;* C=0 Found next statement
                             ;* C=1 No statement found
                             ;****************************************
db23 :                       df_rt_nextstat
                             	; save pointer
db23 : 86e3             [ 3] 	stx df_lineptr
db25 : 85e4             [ 3] 	sta df_lineptr+1
                             	; if end of program then err
db27 : b2e3             [ 5] 	lda (df_lineptr)
db29 : f01c             [ 3] 	beq df_rt_nextstat_err
                             	; if next statement idx 0
db2b : b1e3             [ 5] 	lda (df_lineptr),y
                             	; then go to next line
db2d : f007             [ 3] 	beq df_rt_nextstat_ln
                             	; else make this Y
db2f : a8               [ 2] 	tay
                             	; X = line low
db30 : a6e3             [ 3] 	ldx df_lineptr
                             	; A = line high
db32 : a5e4             [ 3] 	lda df_lineptr+1
db34 : 18               [ 2] 	clc
db35 : 60               [ 6] 	rts
db36 :                       df_rt_nextstat_ln
                             	; for next line, add line length to ptr
db36 : 18               [ 2] 	clc
AS65 Assembler for R6502 [1.42].                                     Page  112
-------------------------------- bank\bank1.s --------------------------------

db37 : b2e3             [ 5] 	lda (df_lineptr)
db39 : 65e3             [ 3] 	adc df_lineptr
db3b : 85e3             [ 3] 	sta df_lineptr
db3d : a5e4             [ 3] 	lda df_lineptr+1
db3f : 6900             [ 2] 	adc #0
db41 : 85e4             [ 3] 	sta df_lineptr+1
                             	; if end of program set C
db43 : b2e3             [ 5] 	lda (df_lineptr)
db45 : d004             [ 3] 	bne df_rt_nextstat_dn
db47 :                       df_rt_nextstat_err
db47 : a000             [ 2] 	ldy #0
db49 : 38               [ 2] 	sec
db4a : 60               [ 6] 	rts
db4b :                       df_rt_nextstat_dn
db4b : a6e3             [ 3] 	ldx df_lineptr
db4d : a5e4             [ 3] 	lda df_lineptr+1
                             	; always skip line number and length for start o
db4f : a003             [ 2] 	ldy #3
db51 : 18               [ 2] 	clc
db52 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Push current line and statement to runtime sta
                             ;****************************************
db53 :                       df_rt_push_stat
db53 : a5c9             [ 3] 	lda df_curstidx
db55 : 20faee           [ 6] 	jsr df_st_pushByte
db58 : a5d0             [ 3] 	lda df_currlin+1
db5a : a6cf             [ 3] 	ldx df_currlin
db5c : 4c13ef           [ 3] 	jmp df_st_pushWord
                             ;	clc
                             ;	rts
                             
                             ;****************************************
                             ;* Pop line and statement from runtime stack
                             ;* And transfer control to next statement
                             ;****************************************
db5f :                       df_rt_pop_stat
db5f : 2021ef           [ 6] 	jsr df_st_popWord
db62 : 86d2             [ 3] 	stx	df_nextlin
db64 : 85d3             [ 3] 	sta df_nextlin+1
db66 : 2003ef           [ 6] 	jsr df_st_popByte
db69 : a8               [ 2] 	tay
db6a : a6d2             [ 3] 	ldx df_nextlin
db6c : a5d3             [ 3] 	lda df_nextlin+1
db6e : 2023db           [ 6] 	jsr df_rt_nextstat
db71 : 86d2             [ 3] 	stx df_nextlin
db73 : 85d3             [ 3] 	sta df_nextlin+1
db75 : 84c8             [ 3] 	sty df_nxtstidx
                             ;	clc
db77 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Find proc definition with var index A
                             ;* Only call if proc not found before
                             ;****************************************
db78 :                       df_rt_findproc
                             	; save the search index
db78 : 85de             [ 3] 	sta df_procmode
                             	; start at program beginning
                             	_cpyZPWord df_prgstrt,df_lineptr
                             
AS65 Assembler for R6502 [1.42].                                     Page  113
-------------------------------- bank\bank1.s --------------------------------

db82 : a003             [ 2] 	ldy #3
db84 : 84e5             [ 3] 	sty df_lineidx
db86 : b2e3             [ 5] 	lda (df_lineptr)
db88 : f02c             [ 3] 	beq df_rt_findproc_err
db8a :                       df_rt_findproc_cmd
db8a : c8               [ 2] 	iny
db8b : b1e3             [ 5] 	lda (df_lineptr),y
db8d : 10fb             [ 3] 	bpl df_rt_findproc_cmd
db8f : c986             [ 2] 	cmp #DFRT_DEF
db91 : d010             [ 3] 	bne df_rt_findproc_nextstat
                             	; skip def token
db93 : c8               [ 2] 	iny
                             	; skip proc escape token
db94 : c8               [ 2] 	iny
                             	; now check the proc var number
db95 : b1e3             [ 5] 	lda (df_lineptr),y
db97 : c5de             [ 3] 	cmp df_procmode
db99 : d008             [ 3] 	bne df_rt_findproc_nextstat
                             	; found it, return AXY with line details
db9b : a6e3             [ 3] 	ldx df_lineptr
db9d : a5e4             [ 3] 	lda df_lineptr+1
db9f : a4e5             [ 3] 	ldy df_lineidx
dba1 : 18               [ 2] 	clc
dba2 : 60               [ 6] 	rts
dba3 :                       df_rt_findproc_nextstat
                             	; restore AXY line details and find next stateme
dba3 : a6e3             [ 3] 	ldx df_lineptr
dba5 : a5e4             [ 3] 	lda df_lineptr+1
dba7 : a4e5             [ 3] 	ldy df_lineidx
dba9 : 2023db           [ 6] 	jsr df_rt_nextstat
dbac : b008             [ 3] 	bcs df_rt_findproc_err
dbae : 86e3             [ 3] 	stx df_lineptr
dbb0 : 85e4             [ 3] 	sta df_lineptr+1
dbb2 : 84e5             [ 3] 	sty df_lineidx
dbb4 : 80d4             [ 3] 	bra df_rt_findproc_cmd
                             	; error
dbb6 :                       df_rt_findproc_err
                             	SWBRK DFERR_NOPROC
                             
                             	
                             ;****************************************
                             ;* Find an escape value
                             ;* Does not check for end of line or statement
                             ;****************************************
dbb8 :                       df_rt_findescval
dbb8 : a4d1             [ 3] 	ldy df_exeoff
dbba : 88               [ 2] 	dey
dbbb :                       df_rt_findescval_loop
dbbb : c8               [ 2] 	iny
dbbc : b1cf             [ 5] 	lda (df_currlin),y
dbbe : c920             [ 2] 	cmp #DFTK_ESCVAL
dbc0 : b0f9             [ 3] 	bcs df_rt_findescval_loop
dbc2 : 84d1             [ 3] 	sty df_exeoff
dbc4 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Skip white space
                             ;* Does not check for end of line or statement
                             ;* A contains non-ws char, df_exeoff updated
                             ;****************************************
dbc5 :                       df_rt_skip_ws
dbc5 : a4d1             [ 3] 	ldy df_exeoff
AS65 Assembler for R6502 [1.42].                                     Page  114
-------------------------------- bank\bank1.s --------------------------------

dbc7 : 88               [ 2] 	dey
dbc8 :                       df_rt_skip_ws_loop
dbc8 : c8               [ 2] 	iny
dbc9 : b1cf             [ 5] 	lda (df_currlin),y
dbcb : c920             [ 2] 	cmp #' '
dbcd : f0f9             [ 3] 	beq df_rt_skip_ws_loop
dbcf : 84d1             [ 3] 	sty df_exeoff
dbd1 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Get an lvar
                             ;* Assumes next token will be escape DFTK_VAR
                             ;* tmpptra contains vvt slot address
                             ;* X,A is the lvar pointer
                             ;****************************************
dbd2 :                       df_rt_getlvar
dbd2 : 20b8db           [ 6] 	jsr df_rt_findescval
                             	; move past the escape value
dbd5 : c8               [ 2] 	iny
                             	; pointing to variable index
dbd6 : b1cf             [ 5] 	lda (df_currlin),y
dbd8 : 84d1             [ 3] 	sty df_exeoff
                             	; get the vvt address
dbda : 20d4ca           [ 6] 	jsr df_var_addr
                             	; get the type
dbdd : b2d4             [ 5] 	lda (df_tmpptra)
                             	; set carry flag to return pointer (lvar)
dbdf : 38               [ 2] 	sec
dbe0 : 20f2d8           [ 6] 	jsr df_rt_eval_var
dbe3 : 4c7def           [ 3] 	jmp df_st_popPtr
                             ;	rts
                             
                             ;****************************************
                             ;* Pop stat from rt stack and continue
                             ;* Y MUST BE ON THE CPU STACK AS IT GETS PLYed HE
                             ;****************************************
dbe6 :                       df_rt_pop_stat_go
dbe6 : 205fdb           [ 6] 	jsr df_rt_pop_stat
                             	; restore stack pointer so we don't lose this en
dbe9 : 7a               [ 4] 	ply
dbea : 84bf             [ 3] 	sty df_rtstop
dbec : 18               [ 2] 	clc
dbed : 60               [ 6] 	rts
                             
                             	include "dflat\rtjmptab.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  RTJUMPTAB.S
                             ;*  Runtime token jump table.
                             ;*  dflat uses four key tables to tokenise and ru
                             ;*  - df_tokensyms    - table of token symbols
                             ;*  - df_tk_tokentype - table of token types
                             ;*  - df_tk_tokenjmp  - table of tokenising routi
                             ;*  - df_rt_tokenjmp  - table of runtime token an
                             ;*  The key is the token symbols.  When a line is
                             ;*  in to the raw (untokenised) buffer, df_tokens
AS65 Assembler for R6502 [1.42].                                     Page  115
-------------------------------- bank\bank1.s --------------------------------

                             ;*  used to identify tokens.  The position of the
                             ;*  token is used to then look up type and jump v
                             ;*  in the other tables.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
                             ; Tokeniser jump table
                             ; In token order of df_tokensyms
dbee :                       df_rt_tokenjmp
dbee : 62e4                  	dw	df_rt_assign
dbf0 : eeed                  	dw	df_rt_proc
dbf2 : 68e4                  	dw	df_rt_comment
dbf4 : 1ae4                  	dw	df_rt_println
dbf6 : d3e3                  	dw	df_rt_printat
dbf8 : dde3                  	dw	df_rt_print
dbfa : 48ee                  	dw	df_rt_def			; 0x86
dbfc : b0ee                  	dw	df_rt_enddef		; 0x87
dbfe : b5ee                  	dw	df_rt_return		; 0x88
dc00 : a5ed                  	dw	df_rt_abort			; 0x89
dc02 : f0e1                  	dw	df_rt_local
dc04 : 19e2                  	dw	df_rt_dim
dc06 : c0e0                  	dw	df_rt_repeat		; 0x8c
dc08 : c8e0                  	dw	df_rt_until
dc0a : 2fe0                  	dw	df_rt_for			; 0x8e
dc0c : 6ee0                  	dw	df_rt_next			; 0x8f
dc0e : 11df                  	dw	df_rt_while			; 0x90
dc10 : 76df                  	dw	df_rt_wend			; 0x81
dc12 : f0df                  	dw	df_rt_if			; 0x92
dc14 : dedf                  	dw	df_rt_else			; 0x93
dc16 : d9df                  	dw	df_rt_endif			; 0x94
dc18 : dedf                  	dw	df_rt_elseif		; 0x95
dc1a : 68e4                  	dw	df_rt_data			; 0x96
dc1c : e2f2                  	dw	df_rt_asm_assemble	; 0x97
dc1e : 69e4                  	dw	df_rt_run
dc20 : 87e5                  	dw	df_rt_list
dc22 : b6e1                  	dw	df_rt_input
dc24 : ece2                  	dw	df_rt_mode
dc26 : 9ce2                  	dw	df_rt_plot
dc28 : d9e2                  	dw	df_rt_cursor
dc2a : 92e2                  	dw	df_rt_cls
dc2c : dce7                  	dw	df_rt_vpoke
dc2e : e8e7                  	dw	df_rt_setvdp
dc30 : f2e7                  	dw	df_rt_colour
dc32 : 41e8                  	dw	df_rt_spritepat
dc34 : 6fe8                  	dw	df_rt_spritepos
dc36 : ade8                  	dw	df_rt_spritecol
dc38 : b2e8                  	dw	df_rt_spritenme
dc3a : 18e8                  	dw	df_rt_sprite
dc3c : d4e7                  	dw	df_rt_poke
dc3e : c6e7                  	dw	df_rt_doke
dc40 : e0e8                  	dw	df_rt_sound
dc42 : f4e8                  	dw	df_rt_music
dc44 : 12e9                  	dw	df_rt_play
dc46 : 03ea                  	dw	df_rt_save
dc48 : 1eea                  	dw	df_rt_load
dc4a : d7ea                  	dw	df_rt_dir
dc4c : 42ea                  	dw	df_rt_del
dc4e : 9be1                  	dw	df_rt_read
dc50 : 0edf                  	dw	df_rt_new
AS65 Assembler for R6502 [1.42].                                     Page  116
-------------------------------- bank\bank1.s --------------------------------

dc52 : 7ee4                  	dw	df_rt_renum
dc54 : bae3                  	dw	df_rt_wait
dc56 : 4deb                  	dw	df_rt_reset
dc58 : f3e2                  	dw	df_rt_hires
dc5a : 0be3                  	dw	df_rt_point
dc5c : 27e3                  	dw	df_rt_line
dc5e : 53e3                  	dw	df_rt_hplot
dc60 : f9e2                  	dw	df_rt_pixmode
dc62 : ffe2                  	dw	df_rt_pixmask
dc64 : 05e3                  	dw	df_rt_pixcol
dc66 : 3de3                  	dw	df_rt_box
dc68 : 15e3                  	dw	df_rt_circle
dc6a : 5fe3                  	dw	df_rt_shape
dc6c : 74ea                  	dw	df_rt_vload
dc6e : 52ea                  	dw	df_rt_bload
dc70 : 43e9                  	dw	df_rt_bsave
dc72 : dfe2                  	dw	df_rt_himem
dc74 : 0adf                  	dw	df_rt_monitor
dc76 : 49ea                  	dw	df_rt_chdir
                             
dc78 : 7feb                  	dw	df_rt_vpeek
dc7a : 64eb                  	dw	df_rt_peek
dc7c : 61eb                  	dw	df_rt_deek
dc7e : b4eb                  	dw	df_rt_stick
dc80 : 2cec                  	dw	df_rt_key
dc82 : bfec                  	dw	df_rt_chr
dc84 : 03ed                  	dw	df_rt_left
dc86 : 18ed                  	dw	df_rt_right
dc88 : 39ed                  	dw	df_rt_mid
dc8a : 5ced                  	dw	df_rt_len
dc8c : deeb                  	dw	df_rt_mem
dc8e : 41ec                  	dw	df_rt_scrn
dc90 : 8deb                  	dw	df_rt_rnd
dc92 : 53ec                  	dw	df_rt_elapsed
dc94 : 6dec                  	dw	df_rt_call
dc96 : d5ec                  	dw	df_rt_hex
dc98 : 71ed                  	dw	df_rt_asc
dc9a : 89ed                  	dw	df_rt_val
dc9c : c9eb                  	dw	df_rt_msbyte
dc9e : d4eb                  	dw	df_rt_lsbyte
                             	
dca0 : 1fdd                  	dw	df_rt_mult
dca2 : 40dd                  	dw	df_rt_div
dca4 : 61dd                  	dw	df_rt_mod
dca6 : 82dd                  	dw	df_rt_asl
dca8 : 94dd                  	dw	df_rt_lsr
dcaa : f9dc                  	dw	df_rt_add
dcac : 0cdd                  	dw	df_rt_sub
                             	
dcae : 3cde                  	dw	df_rt_and
dcb0 : 4bde                  	dw	df_rt_or
dcb2 : e3de                  	dw	df_rt_comlte
dcb4 : f0de                  	dw	df_rt_comgte
dcb6 : fdde                  	dw	df_rt_comne
dcb8 : bcde                  	dw	df_rt_comlt
dcba : c9de                  	dw	df_rt_comgt
dcbc : d6de                  	dw	df_rt_comeq
                             
dcbe : e5e0                  	dw	df_rt_sadd
dcc0 : 7ade                  	dw	df_rt_slte
dcc2 : 8bde                  	dw	df_rt_sgte
dcc4 : 98de                  	dw	df_rt_sne
AS65 Assembler for R6502 [1.42].                                     Page  117
-------------------------------- bank\bank1.s --------------------------------

dcc6 : a1de                  	dw	df_rt_slt
dcc8 : aade                  	dw	df_rt_sgt
dcca : b3de                  	dw	df_rt_seq
                             
                             ; escape sequence handlers
                             ; to do the reverse of tokenising during the list
                             ; command which is also used to save to disk.
dccc :                       df_rt_escjmp
dccc : 60e6                  	dw df_rt_lst_chr
dcce : 5fe6                  	dw df_rt_lst_reserved
dcd0 : 5fe6                  	dw df_rt_lst_reserved
dcd2 : 5fe6                  	dw df_rt_lst_reserved
dcd4 : 5fe6                  	dw df_rt_lst_reserved	
dcd6 : 5fe6                  	dw df_rt_lst_reserved	; no such thing as bytdec
dcd8 : 7de6                  	dw df_rt_lst_bythex
dcda : a2e6                  	dw df_rt_lst_bytbin
dcdc : 5fe6                  	dw df_rt_lst_reserved	
dcde : cde6                  	dw df_rt_lst_intdec
dce0 : 90e6                  	dw df_rt_lst_inthex
dce2 : aae6                  	dw df_rt_lst_intbin
dce4 : 5fe6                  	dw df_rt_lst_reserved
dce6 : 5fe6                  	dw df_rt_lst_reserved
dce8 : 5fe6                  	dw df_rt_lst_reserved
dcea : 5fe6                  	dw df_rt_lst_reserved	
dcec : 0ce7                  	dw df_rt_lst_strlit
dcee : d8e6                  	dw df_rt_lst_var
dcf0 : d8e6                  	dw df_rt_lst_proc
                             
                             	include "dflat\rtsubs.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  RTSUBS.S
                             ;*  Module that implements the runtime execution 
                             ;*  keywords and functions.
                             ;*  So this is where most of the action is for ru
                             ;*  a line is being executed, the dflat runtime c
                             ;*  jumps through the runtime table to routines h
                             ;*  Every dflat statement begins with a token (ig
                             ;*  whitespace), even the implicit assignment and
                             ;*  invocation.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
dcf2 :                       mod_sz_rtsubs_s
                             
                             	include "dflat\numop.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
AS65 Assembler for R6502 [1.42].                                     Page  118
-------------------------------- bank\bank1.s --------------------------------

                             ;*
                             ;*  NUMOP.S
                             ;*	Dflat number AND string operators.
                             ;*  Uses the operator stack to get parameters, le
                             ;*  result on the operator stack.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
                             ; common pushint code
dcf2 :                       df_rt_putintres
dcf2 : a6d4             [ 3] 	ldx df_tmpptra
dcf4 : a5d5             [ 3] 	lda df_tmpptra+1
dcf6 : 4c43ef           [ 3] 	jmp df_st_pushInt
                             
                             ; add two numbers
dcf9 :                       df_rt_add
dcf9 : 20ead9           [ 6] 	jsr df_rt_get2Ints
                             	_addZPWord df_tmpptra,df_tmpptrb
                             
dd09 : 4cf2dc           [ 3] 	jmp df_rt_putintres
                             	
                             ; subtract
dd0c :                       df_rt_sub
dd0c : 20ead9           [ 6] 	jsr df_rt_get2Ints
                             	_subZPWord df_tmpptra,df_tmpptrb
                             
dd1c : 4cf2dc           [ 3] 	jmp df_rt_putintres
                             
                             ; multiply
dd1f :                       df_rt_mult
dd1f : 20ead9           [ 6] 	jsr df_rt_get2Ints
                             	_cpyZPWord df_tmpptra,num_a
                             
                             	_cpyZPWord df_tmpptrb,num_b
                             
dd32 : 204cca           [ 6] 	jsr int_mult
                             	_cpyZPWord num_a,df_tmpptra
                             
dd3d : 4cf2dc           [ 3] 	jmp df_rt_putintres
                             
                             ; divide
dd40 :                       df_rt_div
dd40 : 20ead9           [ 6] 	jsr df_rt_get2Ints
                             	_cpyZPWord df_tmpptra,num_a
                             
                             	_cpyZPWord df_tmpptrb,num_b
                             
dd53 : 2075ca           [ 6] 	jsr int_div
                             	_cpyZPWord num_a,df_tmpptra
                             
dd5e : 4cf2dc           [ 3] 	jmp df_rt_putintres
                             
                             ; mod
dd61 :                       df_rt_mod
dd61 : 20ead9           [ 6] 	jsr df_rt_get2Ints
                             	_cpyZPWord df_tmpptra,num_a
                             
                             	_cpyZPWord df_tmpptrb,num_b
                             
AS65 Assembler for R6502 [1.42].                                     Page  119
-------------------------------- bank\bank1.s --------------------------------

dd74 : 2075ca           [ 6] 	jsr int_div
                             	_cpyZPWord num_x,df_tmpptra
                             
dd7f : 4cf2dc           [ 3] 	jmp df_rt_putintres
                             
                             ; shift left
dd82 :                       df_rt_asl
dd82 : 20ead9           [ 6] 	jsr df_rt_get2Ints
                             	; use low byte only for # of shifts
dd85 : a6d6             [ 3] 	ldx df_tmpptrb
dd87 : e8               [ 2] 	inx
dd88 :                       df_rt_aslbit
dd88 : ca               [ 2] 	dex
dd89 : f006             [ 3] 	beq df_rt_asldone
dd8b : 06d4             [ 5] 	asl df_tmpptra
dd8d : 26d5             [ 5] 	rol df_tmpptra+1
dd8f : 80f7             [ 3] 	bra df_rt_aslbit
dd91 :                       df_rt_asldone
dd91 : 4cf2dc           [ 3] 	jmp df_rt_putintres
                             
                             ; shift right
dd94 :                       df_rt_lsr
dd94 : 20ead9           [ 6] 	jsr df_rt_get2Ints
                             	; use low byte only for # of shifts
dd97 : a6d6             [ 3] 	ldx df_tmpptrb
dd99 : e8               [ 2] 	inx
dd9a :                       df_rt_lsrbit
dd9a : ca               [ 2] 	dex
dd9b : f006             [ 3] 	beq df_rt_lsrdone
dd9d : 46d5             [ 5] 	lsr df_tmpptra+1
dd9f : 66d4             [ 5] 	ror df_tmpptra
dda1 : 80f7             [ 3] 	bra df_rt_lsrbit
dda3 :                       df_rt_lsrdone
dda3 : 4cf2dc           [ 3] 	jmp df_rt_putintres
                             
                             ; common routine push true
dda6 :                       df_rt_true
dda6 : a2ff             [ 2] 	ldx #0xff
dda8 : 8a               [ 2] 	txa
dda9 : 4c43ef           [ 3] 	jmp df_st_pushInt
                             
                             ; common routine push false
ddac :                       df_rt_false
ddac : a200             [ 2] 	ldx #0x00
ddae : 8a               [ 2] 	txa
ddaf : 4c43ef           [ 3] 	jmp df_st_pushInt
                             
                             ; a == b
ddb2 :                       df_rt_eq
ddb2 : 20ead9           [ 6] 	jsr df_rt_get2Ints
ddb5 : a5d4             [ 3] 	lda df_tmpptra
ddb7 : c5d6             [ 3] 	cmp df_tmpptrb
ddb9 : d009             [ 3] 	bne df_rt_eq_false
ddbb : a5d5             [ 3] 	lda df_tmpptra+1
ddbd : c5d7             [ 3] 	cmp df_tmpptrb+1
ddbf : d003             [ 3] 	bne df_rt_eq_false
ddc1 : 4ca6dd           [ 3] 	jmp df_rt_true
ddc4 :                       df_rt_eq_false
ddc4 : 4cacdd           [ 3] 	jmp df_rt_false
                             
                             ; a <> b
ddc7 :                       df_rt_ne
AS65 Assembler for R6502 [1.42].                                     Page  120
-------------------------------- bank\bank1.s --------------------------------

ddc7 : 20ead9           [ 6] 	jsr df_rt_get2Ints
ddca : a5d4             [ 3] 	lda df_tmpptra
ddcc : c5d6             [ 3] 	cmp df_tmpptrb
ddce : f003             [ 3] 	beq df_rt_ne_tryhi
ddd0 :                       df_rt_ne_true
ddd0 : 4ca6dd           [ 3] 	jmp df_rt_true
ddd3 :                       df_rt_ne_tryhi
ddd3 : a5d5             [ 3] 	lda df_tmpptra+1
ddd5 : c5d7             [ 3] 	cmp df_tmpptrb+1
ddd7 : d0f7             [ 3] 	bne df_rt_ne_true
ddd9 : 4cacdd           [ 3] 	jmp df_rt_false
                             
                             ; a <= b
dddc :                       df_rt_lte
                             	; a <=b == !(b-a > 0)
dddc : 20ead9           [ 6] 	jsr df_rt_get2Ints
dddf :                       df_rt_lte_calc
dddf : 38               [ 2] 	sec
dde0 : a5d6             [ 3] 	lda df_tmpptrb
dde2 : e5d4             [ 3] 	sbc df_tmpptra
dde4 : a5d7             [ 3] 	lda df_tmpptrb+1
dde6 : e5d5             [ 3] 	sbc df_tmpptra+1
dde8 : 5002             [ 3] 	bvc df_rt_lte_bvc
ddea : 4980             [ 2] 	eor #0x80
ddec :                       df_rt_lte_bvc
ddec : 3003             [ 3] 	bmi df_rt_lte_false
ddee : 4ca6dd           [ 3] 	jmp df_rt_true
ddf1 :                       df_rt_lte_false
ddf1 : 4cacdd           [ 3] 	jmp df_rt_false
                             
                             ; a < b == (a-b) < 0
ddf4 :                       df_rt_lt
ddf4 : 20ead9           [ 6] 	jsr df_rt_get2Ints
ddf7 : 38               [ 2] 	sec
ddf8 : a5d4             [ 3] 	lda df_tmpptra
ddfa : e5d6             [ 3] 	sbc df_tmpptrb
ddfc : a5d5             [ 3] 	lda df_tmpptra+1
ddfe : e5d7             [ 3] 	sbc df_tmpptrb+1
de00 : 5002             [ 3] 	bvc df_rt_lt_bvc
de02 : 4980             [ 2] 	eor #0x80
de04 :                       df_rt_lt_bvc
de04 : 3003             [ 3] 	bmi df_rt_lt_true
de06 : 4cacdd           [ 3] 	jmp df_rt_false
de09 :                       df_rt_lt_true
de09 : 4ca6dd           [ 3] 	jmp df_rt_true
                             
                             ; a >= b == (a-b >=0)
de0c :                       df_rt_gte
de0c : 20ead9           [ 6] 	jsr df_rt_get2Ints
de0f : 38               [ 2] 	sec
de10 : a5d4             [ 3] 	lda df_tmpptra
de12 : e5d6             [ 3] 	sbc df_tmpptrb
de14 : a5d5             [ 3] 	lda df_tmpptra+1
de16 : e5d7             [ 3] 	sbc df_tmpptrb+1
de18 : 5002             [ 3] 	bvc df_rt_gte_bvc
de1a : 4980             [ 2] 	eor #0x80
de1c :                       df_rt_gte_bvc
de1c : 1003             [ 3] 	bpl df_rt_gte_true
de1e : 4cacdd           [ 3] 	jmp df_rt_false
de21 :                       df_rt_gte_true
de21 : 4ca6dd           [ 3] 	jmp df_rt_true
                             
AS65 Assembler for R6502 [1.42].                                     Page  121
-------------------------------- bank\bank1.s --------------------------------

                             ; a > b == (b-a) < 0
de24 :                       df_rt_gt
de24 : 20ead9           [ 6] 	jsr df_rt_get2Ints
de27 : 38               [ 2] 	sec
de28 : a5d6             [ 3] 	lda df_tmpptrb
de2a : e5d4             [ 3] 	sbc df_tmpptra
de2c : a5d7             [ 3] 	lda df_tmpptrb+1
de2e : e5d5             [ 3] 	sbc df_tmpptra+1
de30 : 5002             [ 3] 	bvc df_rt_gt_bvc
de32 : 4980             [ 2] 	eor #0x80
de34 :                       df_rt_gt_bvc
de34 : 3003             [ 3] 	bmi df_rt_gt_true
de36 : 4cacdd           [ 3] 	jmp df_rt_false
de39 :                       df_rt_gt_true
de39 : 4ca6dd           [ 3] 	jmp df_rt_true
                             
                             ; logical and
de3c :                       df_rt_and
de3c : 20ead9           [ 6] 	jsr df_rt_get2Ints
de3f : a5d4             [ 3] 	lda df_tmpptra
de41 : 25d6             [ 3] 	and df_tmpptrb
de43 : aa               [ 2] 	tax
de44 : a5d5             [ 3] 	lda df_tmpptra+1
de46 : 25d7             [ 3] 	and df_tmpptrb+1
de48 : 4c43ef           [ 3] 	jmp df_st_pushInt
                             	
                             ; logical or
de4b :                       df_rt_or
de4b : 20ead9           [ 6] 	jsr df_rt_get2Ints
de4e : a5d4             [ 3] 	lda df_tmpptra
de50 : 05d6             [ 3] 	ora df_tmpptrb
de52 : aa               [ 2] 	tax
de53 : a5d5             [ 3] 	lda df_tmpptra+1
de55 : 05d7             [ 3] 	ora df_tmpptrb+1
de57 : 4c43ef           [ 3] 	jmp df_st_pushInt
                             
                             ;********** STRING OPS **********
                             
                             ; common string comparator
de5a :                       df_rt_str_comp
de5a : 20f9d9           [ 6] 	jsr df_rt_get2Strs
de5d : a000             [ 2] 	ldy #0
de5f :                       df_rt_str_comp_byte
de5f : b1d4             [ 5] 	lda (df_tmpptra),y
de61 : aa               [ 2] 	tax							; Save op1 char in X
de62 : d1d6             [ 5] 	cmp (df_tmpptrb),y
                             	; if c=0 then <
de64 : 9008             [ 3] 	bcc df_rt_str_comp_lt
                             	; if c=1 and nz then >
de66 : d00a             [ 3] 	bne df_rt_str_comp_gt
                             	; if here then both strings still the same
de68 : 8a               [ 2] 	txa							; What was op1 char
                             	; if char is zero then end
de69 : f00b             [ 3] 	beq df_rt_str_comp_eq
                             	; else do next char
de6b : c8               [ 2] 	iny
de6c : 80f1             [ 3] 	bra df_rt_str_comp_byte
de6e :                       df_rt_str_comp_lt
de6e : a9ff             [ 2] 	lda #0xff
de70 : 18               [ 2] 	clc
de71 : 60               [ 6] 	rts
de72 :                       df_rt_str_comp_gt
AS65 Assembler for R6502 [1.42].                                     Page  122
-------------------------------- bank\bank1.s --------------------------------

de72 : a901             [ 2] 	lda #0x01
de74 : 18               [ 2] 	clc
de75 : 60               [ 6] 	rts
de76 :                       df_rt_str_comp_eq
de76 : a900             [ 2] 	lda #0x00
de78 : 18               [ 2] 	clc
de79 : 60               [ 6] 	rts
                             
                             ; string less than or equal
de7a :                       df_rt_slte
de7a : 205ade           [ 6] 	jsr df_rt_str_comp
de7d : c9ff             [ 2] 	cmp #0xff
de7f : f007             [ 3] 	beq df_rt_str_comp_true
de81 : c900             [ 2] 	cmp #0x00
de83 : f003             [ 3] 	beq df_rt_str_comp_true
de85 :                       df_rt_str_comp_false
de85 : 4cacdd           [ 3] 	jmp df_rt_false
de88 :                       df_rt_str_comp_true
de88 : 4ca6dd           [ 3] 	jmp df_rt_true	
                             
                             ; string greater then or equal	
de8b :                       df_rt_sgte
de8b : 205ade           [ 6] 	jsr df_rt_str_comp
de8e : c901             [ 2] 	cmp #0x01
de90 : f0f6             [ 3] 	beq df_rt_str_comp_true
de92 : c900             [ 2] 	cmp #0x00
de94 : f0f2             [ 3] 	beq df_rt_str_comp_true
de96 : 80ed             [ 3] 	bra df_rt_str_comp_false
                             
                             ; string not equal
de98 :                       df_rt_sne
de98 : 205ade           [ 6] 	jsr df_rt_str_comp
de9b : c900             [ 2] 	cmp #0x00
de9d : d0e9             [ 3] 	bne df_rt_str_comp_true
de9f : 80e4             [ 3] 	bra df_rt_str_comp_false
                             
                             ; string less than
dea1 :                       df_rt_slt
dea1 : 205ade           [ 6] 	jsr df_rt_str_comp
dea4 : c9ff             [ 2] 	cmp #0xff
dea6 : f0e0             [ 3] 	beq df_rt_str_comp_true
dea8 : 80db             [ 3] 	bra df_rt_str_comp_false
                             
                             ; string greater than
deaa :                       df_rt_sgt
deaa : 205ade           [ 6] 	jsr df_rt_str_comp
dead : c901             [ 2] 	cmp #0x01
deaf : f0d7             [ 3] 	beq df_rt_str_comp_true
deb1 : 80d2             [ 3] 	bra df_rt_str_comp_false
                             
                             ; string equal
deb3 :                       df_rt_seq
deb3 : 205ade           [ 6] 	jsr df_rt_str_comp
deb6 : c900             [ 2] 	cmp #0x00
deb8 : f0ce             [ 3] 	beq df_rt_str_comp_true
deba : 80c9             [ 3] 	bra df_rt_str_comp_false
                             
                             ; Common usage of boolean operators for num and s
                             
debc :                       df_rt_comlt
                             	; First find the data type on the stack
debc : 206bef           [ 6] 	jsr df_st_peekType
AS65 Assembler for R6502 [1.42].                                     Page  123
-------------------------------- bank\bank1.s --------------------------------

debf : 2980             [ 2] 	and #DFST_STR
dec1 : d003             [ 3] 	bne df_rt_comlt_str
                             	; If not string then assume number
dec3 : 4cf4dd           [ 3] 	jmp df_rt_lt
dec6 :                       df_rt_comlt_str
                             	; Must be string
dec6 : 4ca1de           [ 3] 	jmp df_rt_slt
                             
dec9 :                       df_rt_comgt
                             	; First find the data type on the stack
dec9 : 206bef           [ 6] 	jsr df_st_peekType
decc : 2980             [ 2] 	and #DFST_STR
dece : d003             [ 3] 	bne df_rt_comgt_str
                             	; If not string then assume number
ded0 : 4c24de           [ 3] 	jmp df_rt_gt
ded3 :                       df_rt_comgt_str
                             	; Must be string
ded3 : 4caade           [ 3] 	jmp df_rt_sgt
                             
ded6 :                       df_rt_comeq
                             	; First find the data type on the stack
ded6 : 206bef           [ 6] 	jsr df_st_peekType
ded9 : 2980             [ 2] 	and #DFST_STR
dedb : d003             [ 3] 	bne df_rt_comeq_str
                             	; If not string then assume number
dedd : 4cb2dd           [ 3] 	jmp df_rt_eq
dee0 :                       df_rt_comeq_str
                             	; Must be string
dee0 : 4cb3de           [ 3] 	jmp df_rt_seq
                             
dee3 :                       df_rt_comlte
                             	; First find the data type on the stack
dee3 : 206bef           [ 6] 	jsr df_st_peekType
dee6 : 2980             [ 2] 	and #DFST_STR
dee8 : d003             [ 3] 	bne df_rt_comlte_str
                             	; If not string then assume number
deea : 4cdcdd           [ 3] 	jmp df_rt_lte
deed :                       df_rt_comlte_str
                             	; Must be string
deed : 4c7ade           [ 3] 	jmp df_rt_slte
                             	
def0 :                       df_rt_comgte
                             	; First find the data type on the stack
def0 : 206bef           [ 6] 	jsr df_st_peekType
def3 : 2980             [ 2] 	and #DFST_STR
def5 : d003             [ 3] 	bne df_rt_comgte_str
                             	; If not string then assume number
def7 : 4c24de           [ 3] 	jmp df_rt_gt
defa :                       df_rt_comgte_str
                             	; Must be string
defa : 4c8bde           [ 3] 	jmp df_rt_sgte
                             
defd :                       df_rt_comne
                             	; First find the data type on the stack
defd : 206bef           [ 6] 	jsr df_st_peekType
df00 : 2980             [ 2] 	and #DFST_STR
df02 : d003             [ 3] 	bne df_rt_comne_str
                             	; If not string then assume number
df04 : 4cc7dd           [ 3] 	jmp df_rt_ne
df07 :                       df_rt_comne_str
                             	; Must be string
df07 : 4c98de           [ 3] 	jmp df_rt_sne
AS65 Assembler for R6502 [1.42].                                     Page  124
-------------------------------- bank\bank1.s --------------------------------

                             
                             
df0a :                       df_rt_monitor
df0a : 203ec2           [ 6] 	jsr _command_line
df0d : 60               [ 6] 	rts
                             	
df0e :                       df_rt_new
df0e : 4cabef           [ 3] 	jmp df_clear
                             	
df11 :                       df_rt_while
                             	; push statement address
df11 : 2053db           [ 6] 	jsr df_rt_push_stat
                             	; DFRT_WHILE token
df14 : a990             [ 2] 	lda #DFRT_WHILE
df16 : 20faee           [ 6] 	jsr df_st_pushByte
                             
                             	; get value in A,X
df19 : 2007d8           [ 6] 	jsr df_rt_getnval
                             
                             	; if value<>0 then continue
df1c : e000             [ 2] 	cpx #0
df1e : f001             [ 3] 	beq df_rt_while_done
df20 : 60               [ 6] 	rts
df21 :                       df_rt_while_done
                             	; pop while data off stack as not needed
df21 : 2003ef           [ 6] 	jsr df_st_popByte
df24 : 2003ef           [ 6] 	jsr df_st_popByte
df27 : 2021ef           [ 6] 	jsr df_st_popWord
                             	; while evaluated false so find wend
                             	; but check for any nested while/wends
                             	; nest = 1 to start
df2a : a5e6             [ 3] 	lda df_ifnest
df2c : 48               [ 3] 	pha
df2d : a901             [ 2] 	lda #1
df2f : 85e6             [ 3] 	sta df_ifnest
                             	; find the matching else/elseif/endif
                             	; start from current statement
                             	_cpyZPWord df_currlin,df_nextlin
                             
df39 :                       df_rt_findwend
df39 : a6d2             [ 3] 	ldx df_nextlin
df3b : a5d3             [ 3] 	lda df_nextlin+1
df3d : a4c9             [ 3] 	ldy df_curstidx
df3f : 2023db           [ 6] 	jsr df_rt_nextstat
                             	; got to end of program, then a problem
df42 : b030             [ 3] 	bcs df_rt_wend_end
df44 : 86d2             [ 3] 	stx df_nextlin
df46 : 85d3             [ 3] 	sta df_nextlin+1
df48 : 84c9             [ 3] 	sty df_curstidx
                             	; find the command token
df4a :                       df_rt_while_cmd
df4a : c8               [ 2] 	iny
df4b : b1d2             [ 5] 	lda (df_nextlin),y
df4d : 10fb             [ 3] 	bpl df_rt_while_cmd
                             	; check for wend
df4f : c991             [ 2] 	cmp #DFRT_WEND
df51 : d019             [ 3] 	bne df_rt_check_while
                             	; decrement nest
df53 : c6e6             [ 5] 	dec df_ifnest
                             	; if not zero then go find more commands
df55 : d0e2             [ 3] 	bne df_rt_findwend
                             	; else found it, restore if nest
AS65 Assembler for R6502 [1.42].                                     Page  125
-------------------------------- bank\bank1.s --------------------------------

                             	; and skip the wend statement
df57 : 68               [ 4] 	pla
df58 : 85e6             [ 3] 	sta df_ifnest
df5a : a6d2             [ 3] 	ldx df_nextlin
df5c : a5d3             [ 3] 	lda df_nextlin+1
df5e : a4c9             [ 3] 	ldy df_curstidx
df60 : 2023db           [ 6] 	jsr df_rt_nextstat
                             	; got to end of program, then a problem
df63 : b00f             [ 3] 	bcs df_rt_wend_end
                             	; need to update nxtstidx to transfer control
df65 : 86d2             [ 3] 	stx df_nextlin
df67 : 85d3             [ 3] 	sta df_nextlin+1
df69 : 84c8             [ 3] 	sty df_nxtstidx	
df6b : 60               [ 6] 	rts
df6c :                       df_rt_check_while
                             	; check for while
df6c : c990             [ 2] 	cmp #DFRT_WHILE
df6e : d0c9             [ 3] 	bne df_rt_findwend
                             	; if while found then increment nest
df70 : e6e6             [ 5] 	inc df_ifnest
df72 : 80c5             [ 3] 	bra df_rt_findwend
df74 :                       df_rt_wend_end
                             	SWBRK DFERR_IMMEDIATE
                             
                             
df76 :                       df_rt_wend
df76 : 2003ef           [ 6] 	jsr df_st_popByte
df79 : c990             [ 2] 	cmp #DFRT_WHILE
df7b : d00d             [ 3] 	bne df_rt_wend_err
                             	; pop the stat and continue
df7d : 2021ef           [ 6] 	jsr df_st_popWord
df80 : 86d2             [ 3] 	stx	df_nextlin
df82 : 85d3             [ 3] 	sta df_nextlin+1
df84 : 2003ef           [ 6] 	jsr df_st_popByte
df87 : 85c8             [ 3] 	sta df_nxtstidx
df89 : 60               [ 6] 	rts
df8a :                       df_rt_wend_err
                             	SWBRK DFERR_WEND
                             
                             
                             ;move to next statement during if/else matching
                             ;end of program is an error
df8c :                       df_rt_if_stat
df8c : a6d2             [ 3] 	ldx df_nextlin
df8e : a5d3             [ 3] 	lda df_nextlin+1
df90 : a4c9             [ 3] 	ldy df_curstidx
df92 : 2023db           [ 6] 	jsr df_rt_nextstat
                             	; got to end of program, then a problem
df95 : b009             [ 3] 	bcs df_rt_if_stat_err
df97 : 86d2             [ 3] 	stx df_nextlin
df99 : 85d3             [ 3] 	sta df_nextlin+1
df9b : 84c9             [ 3] 	sty df_curstidx
df9d : 84c8             [ 3] 	sty df_nxtstidx
df9f : 60               [ 6] 	rts
                             ; program ended with no match
dfa0 :                       df_rt_if_stat_err
                             	SWBRK DFERR_UNCLOSEDIF
                             
                             	
                             ; find matching else/elseif/endif
                             ; C = 0 match else/elseif/endif
                             ; C = 1 match endif only
AS65 Assembler for R6502 [1.42].                                     Page  126
-------------------------------- bank\bank1.s --------------------------------

                             ; endif is always matched
                             ; ** MAKE SURE NEXTLIN IS POPULATED! **
dfa2 :                       df_rt_if_match
                             	; save the current if nest level
dfa2 : a5e6             [ 3] 	lda df_ifnest
dfa4 : 48               [ 3] 	pha
                             	; local if nest level is zero to start with
dfa5 : 64e6             [ 3] 	stz df_ifnest	
                             	; save match pref
dfa7 : 08               [ 3] 	php
                             	; find the matching else/elseif/endif
                             	; start from df_nextlin, df_curstidx
dfa8 :                       df_rt_findelseendif
dfa8 : 208cdf           [ 6] 	jsr df_rt_if_stat
                             	; find command
dfab :                       df_rt_ifcmd
dfab : c8               [ 2] 	iny
dfac : b1d2             [ 5] 	lda (df_nextlin),y
dfae : 10fb             [ 3] 	bpl df_rt_ifcmd
                             	; check for endif
dfb0 : c994             [ 2] 	cmp #DFRT_ENDIF
dfb2 : f014             [ 3] 	beq df_rt_ifelse
                             
dfb4 : 28               [ 4] 	plp
dfb5 : 08               [ 3] 	php
                             	
dfb6 : b008             [ 3] 	bcs df_rt_ifskipelseif
dfb8 : c993             [ 2] 	cmp #DFRT_ELSE
dfba : f00c             [ 3] 	beq df_rt_ifelse
dfbc : c995             [ 2] 	cmp #DFRT_ELSEIF
dfbe : f008             [ 3] 	beq df_rt_ifelse
dfc0 :                       df_rt_ifskipelseif
                             	; another if token found - increment lcoal if ne
dfc0 : c992             [ 2] 	cmp #DFRT_IF
dfc2 : d002             [ 3] 	bne df_rt_skipnestif
dfc4 : e6e6             [ 5] 	inc df_ifnest
dfc6 :                       df_rt_skipnestif
                             	; no tokens of interest found, so next statement
dfc6 : 80e0             [ 3] 	bra df_rt_findelseendif
                             	
                             	; found else/elseif/endif
                             	; but check if this is nested
dfc8 :                       df_rt_ifelse
                             	; nest counter zero then found matching else/els
dfc8 : a6e6             [ 3] 	ldx df_ifnest
dfca : f008             [ 3] 	beq df_rt_if_found
                             	; endif token found so decrement local nest
dfcc : c994             [ 2] 	cmp #DFRT_ENDIF
dfce : d002             [ 3] 	bne df_rt_skipnestendif
dfd0 : c6e6             [ 5] 	dec df_ifnest
dfd2 :                       df_rt_skipnestendif	
                             	; continue to search for else/endif
dfd2 : 80d4             [ 3] 	bra df_rt_findelseendif
                             	; ok got a match
dfd4 :                       df_rt_if_found
                             	; remove pref
dfd4 : 28               [ 4] 	plp
                             	; restore global if nest
dfd5 : fa               [ 4] 	plx
dfd6 : 86e6             [ 3] 	stx df_ifnest
                             
                             	;A contains the token found, Y is index in to df
AS65 Assembler for R6502 [1.42].                                     Page  127
-------------------------------- bank\bank1.s --------------------------------

                             ;	clc
dfd8 : 60               [ 6] 	rts
                             
dfd9 :                       df_rt_endif
                             	; decrement if next level
dfd9 : c6e6             [ 5] 	dec df_ifnest
dfdb : 3011             [ 3] 	bmi df_rt_noif_err
                             ;	clc
dfdd : 60               [ 6] 	rts
                             	
                             	; else and ifelse encountered in a normal sequen
                             	; only happens when the clause has been executed
                             	; so we only now need to find the endif
dfde :                       df_rt_elseif
dfde :                       df_rt_else
                             	; not in if mode then error
dfde : a5e6             [ 3] 	lda df_ifnest
dfe0 : f00c             [ 3] 	beq df_rt_noif_err
                             	; find endif only
                             	; starting from current line and curstidx
                             	_cpyZPWord df_currlin,df_nextlin
                             
dfea : 38               [ 2] 	sec
dfeb : 4ca2df           [ 3] 	jmp df_rt_if_match
                             
                             ; endif/else/elseif encountered outside of an if	
dfee :                       df_rt_noif_err
                             	SWBRK DFERR_NOIF
                             
                             	
                             	; when if is encountered, the job of this routin
                             	; to determine which clause to execute, then tra
                             	; program control to that point.  in normal prog
                             	; sequence else/elseif statements will signify t
                             	; of an if construct.
dff0 :                       df_rt_if
                             	; increment global if nest counter
dff0 : e6e6             [ 5] 	inc df_ifnest
dff2 :                       df_rt_ifeval
                             	; get value
dff2 : 2007d8           [ 6] 	jsr df_rt_getnval
                             	; if value<>0 if is successful then continue nor
dff5 : c900             [ 2] 	cmp #0
dff7 : d035             [ 4] 	bne df_rt_if_done
dff9 : e000             [ 2] 	cpx #0
dffb : d031             [ 4] 	bne df_rt_if_done
                             	; got here then if clause evaluated to false
                             	; match with else/elseif/endif
                             	; df_nextlin is used to find the clause to execu
                             	_cpyZPWord df_currlin,df_nextlin
                             
e005 : 18               [ 2] 	clc						
e006 : 20a2df           [ 6] 	jsr df_rt_if_match
                             	; A contains the token found, Y is index of this
                             
e009 : c993             [ 2] 	cmp #DFRT_ELSE
                             	; else: df_nextlin and df_nxtstidx points to the
e00b : f01e             [ 3] 	beq df_rt_do_else
                             
e00d : c994             [ 2] 	cmp #DFRT_ENDIF
                             	; else: df_nextlin and df_nxtstidx points to the
e00f : f01d             [ 3] 	beq df_rt_if_done
AS65 Assembler for R6502 [1.42].                                     Page  128
-------------------------------- bank\bank1.s --------------------------------

                             
                             	; elif detected - increment past the token and e
                             	; make this the current line and token index
                             	_cpyZPWord df_nextlin,df_currlin
                             
                             	; move past the token and save position
e019 : c8               [ 2] 	iny
e01a : 5a               [ 3] 	phy
                             	; initialise statement pointer
e01b : a4c9             [ 3] 	ldy df_curstidx
e01d : a6cf             [ 3] 	ldx df_currlin
e01f : a5d0             [ 3] 	lda df_currlin+1
e021 : 20acda           [ 6] 	jsr df_rt_init_stat_ptr
                             	; restore Y (one byte past the token) and save i
e024 : 7a               [ 4] 	ply
e025 : 84d1             [ 3] 	sty df_exeoff
                             	; don't force a jump as we've initalised all var
e027 : 64d3             [ 3] 	stz df_nextlin+1
                             	; now everyting is set up to evaluate the elif c
e029 : 80c7             [ 4] 	bra df_rt_ifeval
                             	
e02b :                       df_rt_do_else
                             	; we need to point to the next statement not thi
e02b : 208cdf           [ 6] 	jsr df_rt_if_stat
e02e :                       df_rt_if_done
                             ;	clc
e02e : 60               [ 6] 	rts
                             	
e02f :                       df_rt_for
                             	; push statement address to rt stack
e02f : 2053db           [ 6] 	jsr df_rt_push_stat
                             	; get lvar
e032 : 20d2db           [ 6] 	jsr df_rt_getlvar
                             	; Save lvar pointer
e035 : 48               [ 3] 	pha
e036 : da               [ 3] 	phx
e037 : e6d1             [ 5] 	inc df_exeoff
                             
                             	; find starting value
e039 : 20b8db           [ 6] 	jsr df_rt_findescval
                             	; evaluate the starting value
                             	; can't use df_rt_getnval as need to use A,X fir
e03c : 2061d7           [ 6] 	jsr df_rt_neval
                             	; get ready to update the counter
e03f : fa               [ 4] 	plx
e040 : 86d4             [ 3] 	stx df_tmpptra
e042 : 68               [ 4] 	pla
e043 : 85d5             [ 3] 	sta df_tmpptra+1
e045 : 48               [ 3] 	pha
e046 : da               [ 3] 	phx
                             	; get the starting value from op stack
e047 : 2073ef           [ 6] 	jsr df_st_popInt
                             	; save it to counter slot
e04a : a001             [ 2] 	ldy #1
e04c : 91d4             [ 5] 	sta (df_tmpptra),y
e04e : 8a               [ 2] 	txa
e04f : 88               [ 2] 	dey
e050 : 92d4             [ 5] 	sta (df_tmpptra)
                             
                             	; find end value
e052 : 20b8db           [ 6] 	jsr df_rt_findescval
                             	; evaluate the end value
AS65 Assembler for R6502 [1.42].                                     Page  129
-------------------------------- bank\bank1.s --------------------------------

e055 : 2007d8           [ 6] 	jsr df_rt_getnval
                             	; and put on rt stack
e058 : 2013ef           [ 6] 	jsr df_st_pushWord
                             
                             	; find step value
e05b : 20b8db           [ 6] 	jsr df_rt_findescval
                             	; evaluate the end value
e05e : 2007d8           [ 6] 	jsr df_rt_getnval
                             	; and push on rt stack
e061 : 2013ef           [ 6] 	jsr df_st_pushWord
                             	; save the counter slot address
e064 : fa               [ 4] 	plx
e065 : 68               [ 4] 	pla
e066 : 2013ef           [ 6] 	jsr df_st_pushWord
                             	; all done - counter set to start
                             	; stack contains counter slot, step val, end val
                             	; now push for token
e069 : a98e             [ 2] 	lda #DFRT_FOR
e06b : 4cfaee           [ 3] 	jmp df_st_pushByte
                             ;	rts
                             
e06e :                       df_rt_next
                             	; remember stack position
e06e : a4bf             [ 3] 	ldy df_rtstop
e070 : 5a               [ 3] 	phy
e071 : 2003ef           [ 6] 	jsr df_st_popByte
e074 : c98e             [ 2] 	cmp #DFRT_FOR
e076 : d046             [ 3] 	bne df_rt_next_err
                             	; get the slot address
e078 : 2021ef           [ 6] 	jsr df_st_popWord
                             	; save address to ptrd, contents to ptra
e07b : 86da             [ 3] 	stx df_tmpptrd
e07d : 85db             [ 3] 	sta df_tmpptrd+1
e07f : b2da             [ 5] 	lda (df_tmpptrd)
e081 : 85d4             [ 3] 	sta df_tmpptra
e083 : a001             [ 2] 	ldy #1
e085 : b1da             [ 5] 	lda (df_tmpptrd),y
e087 : 85d5             [ 3] 	sta df_tmpptra+1
                             	
                             	; get step value, save in ptrb
e089 : 2021ef           [ 6] 	jsr df_st_popWord
e08c : 86d6             [ 3] 	stx df_tmpptrb
e08e : 85d7             [ 3] 	sta df_tmpptrb+1
                             
                             	; add step to counter and save back to counter
                             	_addZPWord df_tmpptra,df_tmpptrb
                             
e09d : a5d4             [ 3] 	lda df_tmpptra
e09f : 92da             [ 5] 	sta (df_tmpptrd)
e0a1 : a001             [ 2] 	ldy #1
e0a3 : a5d5             [ 3] 	lda df_tmpptra+1
e0a5 : 91da             [ 5] 	sta (df_tmpptrd),y
                             	
                             	; get end value, save in ptrb
e0a7 : 2021ef           [ 6] 	jsr df_st_popWord
e0aa : 86d6             [ 3] 	stx df_tmpptrb
e0ac : 85d7             [ 3] 	sta df_tmpptrb+1
                             	
                             	; call lte operation but no need to get ints
                             	; as already in ptra and ptrb
e0ae : 20dfdd           [ 6] 	jsr df_rt_lte_calc
                             	; check if true or false
AS65 Assembler for R6502 [1.42].                                     Page  130
-------------------------------- bank\bank1.s --------------------------------

e0b1 : 2073ef           [ 6] 	jsr df_st_popInt
e0b4 : e000             [ 2] 	cpx #0
                             	; if false then next is done
e0b6 : f003             [ 3] 	beq df_next_done
                             	; else we continue
e0b8 : 4ce6db           [ 3] 	jmp df_rt_pop_stat_go
                             	; if done, then continue with next statement
e0bb :                       df_next_done
e0bb : 4cdce0           [ 3] 	jmp df_rt_untilnext_done
                             	
e0be :                       df_rt_next_err
                             	SWBRK DFERR_NEXTFOR
                             
                             
                             	
e0c0 :                       df_rt_repeat
                             	; push statement address
e0c0 : 2053db           [ 6] 	jsr df_rt_push_stat
                             	; DFRT_REPEAT token
e0c3 : a98c             [ 2] 	lda #DFRT_REPEAT
e0c5 : 4cfaee           [ 3] 	jmp df_st_pushByte
                             ;	rts
                             	
e0c8 :                       df_rt_until
                             	; remember stack position
e0c8 : a4bf             [ 3] 	ldy df_rtstop
e0ca : 5a               [ 3] 	phy
e0cb : 2003ef           [ 6] 	jsr df_st_popByte
e0ce : c98c             [ 2] 	cmp #DFRT_REPEAT
e0d0 : d011             [ 3] 	bne df_rt_until_err
                             	; evaluate expression in to A,X
e0d2 : 2007d8           [ 6] 	jsr df_rt_getnval
                             	; if value<>0 then continue
e0d5 : e000             [ 2] 	cpx #0
e0d7 : d003             [ 3] 	bne df_rt_untilnext_done
                             
                             	; pop the stat and continue
e0d9 : 4ce6db           [ 3] 	jmp df_rt_pop_stat_go
                             
e0dc :                       df_rt_untilnext_done
e0dc : 7a               [ 4] 	ply
                             	; pop 2 items off stack (line address, index)
e0dd : 2021ef           [ 6] 	jsr df_st_popWord
e0e0 : 4c03ef           [ 3] 	jmp df_st_popByte
                             	; and continue
                             ;	clc
                             ;	rts
                             
e0e3 :                       df_rt_until_err
                             	SWBRK DFERR_UNTIL
                             
                             	
e0e5 :                       df_rt_sadd
                             ;	clc
e0e5 : 60               [ 6] 	rts
                             	
e0e6 :                       df_rt_print_num
e0e6 : 2073ef           [ 6] 	jsr df_st_popInt
e0e9 : 18               [ 2] 	clc
e0ea : 4c75c9           [ 3] 	jmp print_a_to_d
                             ;	rts
                             	
AS65 Assembler for R6502 [1.42].                                     Page  131
-------------------------------- bank\bank1.s --------------------------------

e0ed :                       df_rt_print_str
e0ed : 2078ef           [ 6] 	jsr df_st_popStr
e0f0 : 86d4             [ 3] 	stx df_tmpptra
e0f2 : 85d5             [ 3] 	sta df_tmpptra+1
e0f4 : a000             [ 2] 	ldy #0
e0f6 :                       df_rt_print_str_ch
e0f6 : b1d4             [ 5] 	lda (df_tmpptra),y
e0f8 : f006             [ 4] 	beq df_rt_print_str_done
e0fa : 2049c4           [ 6] 	jsr io_put_ch
e0fd : c8               [ 2] 	iny
e0fe : 80f6             [ 3] 	bra df_rt_print_str_ch
e100 :                       df_rt_print_str_done
                             ;	clc
e100 : 60               [ 6] 	rts
                             
                             ; * Find the position of the next data item to re
e101 :                       df_rt_nextdatum
                             	; load data line offset
e101 : a4e9             [ 3] 	ldy df_datoff 
                             	; if data pointer unitialised (because high byte
e103 : a5e8             [ 3] 	lda df_currdat+1
e105 : d02f             [ 3] 	bne df_rt_skipinitdataptr
                             	; then start at program beginning
                             	_cpyZPWord df_prgstrt,df_currdat
                             
e10f :                       df_rt_datlinstart
                             	; if end of program then error
e10f : b2e7             [ 5] 	lda (df_currdat)
e111 : f033             [ 3] 	beq df_rt_datumerr
                             	; index in to first line byte
e113 : a003             [ 2] 	ldy #3
e115 : 84e9             [ 3] 	sty df_datoff
                             	; find first 'data' statement
e117 :                       df_rt_datastatement
e117 : c8               [ 2] 	iny
e118 : 98               [ 2] 	tya
                             	; end of line reached?
e119 : d2e7             [ 5] 	cmp (df_currdat)
                             	; if not find data token
e11b : d00f             [ 3] 	bne df_rt_getdatatk
e11d :                       df_rt_datnextlin
                             	; if so then go to next line
e11d : 18               [ 2] 	clc
e11e : a5e7             [ 3] 	lda df_currdat
e120 : 72e7             [ 5] 	adc (df_currdat)
e122 : 85e7             [ 3] 	sta df_currdat
e124 : a5e8             [ 3] 	lda df_currdat+1
e126 : 6900             [ 2] 	adc #0
e128 : 85e8             [ 3] 	sta df_currdat+1
e12a : 80e3             [ 3] 	bra df_rt_datlinstart
e12c :                       df_rt_getdatatk
e12c : b1e7             [ 5] 	lda (df_currdat),y
e12e : 10e7             [ 3] 	bpl df_rt_datastatement
                             	; found data statement?
e130 : c996             [ 2] 	cmp #DFRT_DATA
                             	; if not then go to next line	
e132 : d0e9             [ 3] 	bne df_rt_datnextlin
e134 : 84e9             [ 3] 	sty df_datoff	
e136 :                       df_rt_skipinitdataptr
e136 : 98               [ 2] 	tya
                             	; end of line reached?
e137 : d2e7             [ 5] 	cmp (df_currdat)
AS65 Assembler for R6502 [1.42].                                     Page  132
-------------------------------- bank\bank1.s --------------------------------

                             	; if so go to next line
e139 : f0e2             [ 3] 	beq df_rt_datnextlin
                             	; else see if escape value
e13b : b1e7             [ 5] 	lda (df_currdat),y
e13d : c920             [ 2] 	cmp #DFTK_ESCVAL
e13f : c8               [ 2] 	iny
e140 : b0f4             [ 3] 	bcs df_rt_skipinitdataptr
                             	; ok found an escape value
                             	; save position and return
e142 : 88               [ 2] 	dey
e143 : 84e9             [ 3] 	sty df_datoff
                             ;	clc
e145 : 60               [ 6] 	rts
e146 :                       df_rt_datumerr
                             	SWBRK DFERR_NODATA
                             
                             
                             ; read a datum
e148 :                       df_rt_readdatum
                             	; update data pointer to next data item
e148 : 2001e1           [ 6] 	jsr df_rt_nextdatum
                             
                             	; now get lvar X,A from current statement
e14b : 20d2db           [ 6] 	jsr df_rt_getlvar
                             	; save lvar in tmpb, vvt ptr in tmpa
e14e : 86d6             [ 3] 	stx df_tmpptrb
e150 : 85d7             [ 3] 	sta df_tmpptrb+1
                             		
                             	; first save save current prgoram line and offse
e152 : a5cf             [ 3] 	lda df_currlin
e154 : 48               [ 3] 	pha
e155 : a5d0             [ 3] 	lda df_currlin+1
e157 : 48               [ 3] 	pha
e158 : a5d1             [ 3] 	lda df_exeoff
e15a : 48               [ 3] 	pha
e15b : a5c7             [ 3] 	lda df_eolidx
e15d : 48               [ 3] 	pha
e15e : a5c8             [ 3] 	lda df_nxtstidx
e160 : 48               [ 3] 	pha
e161 : a5c9             [ 3] 	lda df_curstidx
e163 : 48               [ 3] 	pha
                             
                             	; use data pointer as current position for evalu
                             	_cpyZPWord df_currdat,df_currlin
                             
e16c : a5e9             [ 3] 	lda df_datoff
e16e : 85d1             [ 3] 	sta df_exeoff
e170 : b2e7             [ 5] 	lda (df_currdat)
e172 : 85c7             [ 3] 	sta df_eolidx
e174 : 64c8             [ 3] 	stz df_nxtstidx
e176 : a903             [ 2] 	lda #3
e178 : 85c9             [ 3] 	sta df_curstidx
                             	
                             	; get type from vvt ptr in tmpa
e17a : b2d4             [ 5] 	lda (df_tmpptra)
e17c : a8               [ 2] 	tay
                             	; get lvar point from tmpb
e17d : a6d6             [ 3] 	ldx df_tmpptrb
e17f : a5d7             [ 3] 	lda df_tmpptrb+1
                             	
                             	; X,A and Y set up, now evaluate and perform ass
e181 : 2054e4           [ 6] 	jsr df_rt_doassign
AS65 Assembler for R6502 [1.42].                                     Page  133
-------------------------------- bank\bank1.s --------------------------------

                             
                             	; update data offset as data has been consumed
e184 : a5d1             [ 3] 	lda df_exeoff
e186 : 85e9             [ 3] 	sta df_datoff
                             	; restore line settings
e188 : 68               [ 4] 	pla
e189 : 85c9             [ 3] 	sta df_curstidx
e18b : 68               [ 4] 	pla
e18c : 85c8             [ 3] 	sta df_nxtstidx
e18e : 68               [ 4] 	pla
e18f : 85c7             [ 3] 	sta df_eolidx
e191 : 68               [ 4] 	pla
e192 : 85d1             [ 3] 	sta df_exeoff
e194 : 68               [ 4] 	pla
e195 : 85d0             [ 3] 	sta df_currlin+1
e197 : 68               [ 4] 	pla
e198 : 85cf             [ 3] 	sta df_currlin
e19a : 60               [ 6] 	rts
                             
                             
e19b :                       df_rt_read
                             	; find variable to read in to from current posit
e19b : a4d1             [ 3] 	ldy df_exeoff
e19d :                       df_rt_read_find_var
e19d : c8               [ 2] 	iny
                             	; if end of line or statement then done
e19e : c4c7             [ 3] 	cpy df_eolidx
e1a0 : f011             [ 3] 	beq df_rt_read_done
e1a2 : c4c8             [ 3] 	cpy df_nxtstidx
e1a4 : f00d             [ 3] 	beq df_rt_read_done
                             	; if not found escape then next byte
e1a6 : b1cf             [ 5] 	lda (df_currlin),y
e1a8 : c920             [ 2] 	cmp #DFTK_ESCVAL
e1aa : b0f1             [ 3] 	bcs df_rt_read_find_var
                             	; ok found escape, save position
e1ac : 84d1             [ 3] 	sty df_exeoff
                             	; go and read in the value
e1ae : 2048e1           [ 6] 	jsr df_rt_readdatum
                             	; try find another variable
e1b1 : 80e8             [ 3] 	bra df_rt_read
                             
e1b3 :                       df_rt_read_done
                             	; save position
e1b3 : 84d1             [ 3] 	sty df_exeoff
e1b5 : 60               [ 6] 	rts
                             
e1b6 :                       df_rt_input
                             	; df_tmpptra has the vvt address, X,A is the lva
e1b6 : 20d2db           [ 6] 	jsr df_rt_getlvar
                             	; Save lvar pointer
e1b9 : 86d6             [ 3] 	stx df_tmpptrb
e1bb : 85d7             [ 3] 	sta df_tmpptrb+1
                             	; go read a line of input
                             	; buf_lo ptr has the input, Y is size
e1bd : 38               [ 2] 	sec
e1be : 2058c4           [ 6] 	jsr io_read_line
                             	; check the type
e1c1 : b2d4             [ 5] 	lda (df_tmpptra)
e1c3 : 2904             [ 2] 	and #DFVVT_STR
e1c5 : d008             [ 3] 	bne df_rt_input_str
e1c7 : b2d4             [ 5] 	lda (df_tmpptra)
e1c9 : 2903             [ 2] 	and #DFVVT_INT|DFVVT_BYT
AS65 Assembler for R6502 [1.42].                                     Page  134
-------------------------------- bank\bank1.s --------------------------------

e1cb : d00a             [ 3] 	bne df_rt_input_num
                             	; if not int or byte then error
e1cd : 801f             [ 3] 	bra df_rt_input_err
e1cf :                       df_rt_input_str
e1cf : b140             [ 5] 	lda (buf_lo),y
e1d1 : 91d6             [ 5] 	sta (df_tmpptrb),y
e1d3 : 88               [ 2] 	dey
e1d4 : 10f9             [ 3] 	bpl df_rt_input_str
                             ;	clc
e1d6 : 60               [ 6] 	rts
                             
e1d7 :                       df_rt_input_num
                             	; X,A = address, linbuff must be on page boundar
e1d7 : a541             [ 3] 	lda buf_lo+1
e1d9 : a640             [ 3] 	ldx buf_lo
e1db : a000             [ 2] 	ldy #0				; any numeric format
e1dd : 206dc7           [ 6] 	jsr con_n_to_a
e1e0 : b00c             [ 3] 	bcs df_rt_input_err
e1e2 : a000             [ 2] 	ldy #0
e1e4 : a58e             [ 3] 	lda num_a
e1e6 : 91d6             [ 5] 	sta (df_tmpptrb),y
e1e8 : c8               [ 2] 	iny
e1e9 : a58f             [ 3] 	lda num_a+1
e1eb : 91d6             [ 5] 	sta (df_tmpptrb),y
                             ;	clc
e1ed : 60               [ 6] 	rts
e1ee :                       df_rt_input_err
                             	SWBRK DFERR_TYPEMISM
                             
                             	
e1f0 :                       df_rt_local
                             	; get current local count off rt stack
e1f0 : 2003ef           [ 6] 	jsr df_st_popByte
                             	; save on pc stack for incrmenting
e1f3 : 48               [ 3] 	pha
e1f4 : a4d1             [ 3] 	ldy df_exeoff
e1f6 : 88               [ 2] 	dey
e1f7 :                       df_rt_local_findesc
e1f7 : c8               [ 2] 	iny
                             	; check end of line
e1f8 : c4c7             [ 3] 	cpy df_eolidx
e1fa : f019             [ 4] 	beq df_rt_local_done
e1fc : c4c8             [ 3] 	cpy df_nxtstidx
e1fe : f015             [ 4] 	beq df_rt_local_done
                             	; find a var
e200 : b1cf             [ 5] 	lda (df_currlin),y
e202 : c911             [ 2] 	cmp #DFTK_VAR
e204 : d0f1             [ 4] 	bne df_rt_local_findesc
                             	; jump over escape value
e206 : c8               [ 2] 	iny
                             	; get var index
e207 : b1cf             [ 5] 	lda (df_currlin),y
e209 : 84d1             [ 3] 	sty df_exeoff
                             	; localise this variable
e20b : 20e1ee           [ 6] 	jsr df_rt_proc_local
                             	; increment local counter
e20e : 68               [ 4] 	pla
e20f : 1a               [ 2] 	inc a
e210 : 48               [ 3] 	pha
e211 : a4d1             [ 3] 	ldy df_exeoff
e213 : 80e2             [ 4] 	bra df_rt_local_findesc
e215 :                       df_rt_local_done
AS65 Assembler for R6502 [1.42].                                     Page  135
-------------------------------- bank\bank1.s --------------------------------

                             	; get the local counter
                             	; put on to rt stack
e215 : 68               [ 4] 	pla
e216 : 4cfaee           [ 3] 	jmp df_st_pushByte
                             ;	clc
                             ;	rts
                             	
e219 :                       df_rt_dim
e219 : a4d1             [ 3] 	ldy df_exeoff
e21b : 88               [ 2] 	dey
e21c :                       df_rt_dim_findesc
                             	; check end of line
e21c : c8               [ 2] 	iny
e21d : c4c7             [ 3] 	cpy df_eolidx
e21f : f06e             [ 3] 	beq df_rt_dim_done
e221 : c4c8             [ 3] 	cpy df_nxtstidx
e223 : f06a             [ 3] 	beq df_rt_dim_done
                             	; find a var
e225 : b1cf             [ 5] 	lda (df_currlin),y
e227 : c911             [ 2] 	cmp #DFTK_VAR
e229 : d0f1             [ 3] 	bne df_rt_dim_findesc
                             	; jump over escape value
e22b : c8               [ 2] 	iny
                             	; get var index
e22c : b1cf             [ 5] 	lda (df_currlin),y
                             	; move to open bracket
e22e : c8               [ 2] 	iny
e22f : 84d1             [ 3] 	sty df_exeoff
                             	; Calcuate VVT slot address in to tmpa
e231 : 20d4ca           [ 6] 	jsr df_var_addr
                             	; check if already dim'd
e234 : a003             [ 2] 	ldy #DFVVT_DIM1
e236 : b1d4             [ 5] 	lda (df_tmpptra),y
e238 : d056             [ 3] 	bne df_rt_dim_err
                             	; Save slot address found earlier
e23a : a5d4             [ 3] 	lda df_tmpptra
e23c : 48               [ 3] 	pha
e23d : a5d5             [ 3] 	lda df_tmpptra+1
e23f : 48               [ 3] 	pha
e240 : 20d1d8           [ 6] 	jsr df_rt_arry_parm2
                             	; Restore slot address
e243 : 68               [ 4] 	pla
e244 : 85d5             [ 3] 	sta df_tmpptra+1
e246 : 68               [ 4] 	pla
e247 : 85d4             [ 3] 	sta df_tmpptra
                             ;	bcs df_rt_dim_err
                             	; save x,y to dim1,2
e249 : 5a               [ 3] 	phy
e24a : da               [ 3] 	phx
e24b : a003             [ 2] 	ldy #DFVVT_DIM1
e24d : 68               [ 4] 	pla
e24e : 91d4             [ 5] 	sta (df_tmpptra),y
e250 : c8               [ 2] 	iny
e251 : 68               [ 4] 	pla
e252 : 91d4             [ 5] 	sta (df_tmpptra),y	
e254 :                       df_rt_dim_alloc
                             	; ok we have up to 2 dimensions
                             	; mult dim 1 and 2 if dim 2 <> 0
e254 : a003             [ 2] 	ldy #DFVVT_DIM1
e256 : b1d4             [ 5] 	lda (df_tmpptra),y
e258 : 858e             [ 3] 	sta num_a
e25a : 648f             [ 3] 	stz num_a+1
AS65 Assembler for R6502 [1.42].                                     Page  136
-------------------------------- bank\bank1.s --------------------------------

e25c : c8               [ 2] 	iny
e25d : b1d4             [ 5] 	lda (df_tmpptra),y
e25f : d002             [ 3] 	bne df_rt_dim2_nz
e261 : a901             [ 2] 	lda #1
e263 :                       df_rt_dim2_nz
e263 : 8592             [ 3] 	sta num_b
e265 : 6493             [ 3] 	stz num_b+1
e267 : 2025ca           [ 6] 	jsr int_fast_mult
                             	; check the type if int then mult2
e26a : b2d4             [ 5] 	lda (df_tmpptra)
e26c : 2901             [ 2] 	and #DFVVT_INT
e26e : f004             [ 3] 	beq df_rt_dim2_mul2
e270 : 068e             [ 5] 	asl num_a
e272 : 268f             [ 5] 	rol num_a+1
e274 :                       df_rt_dim2_mul2	
                             	; finally, we have a size of array
e274 : a68e             [ 3] 	ldx num_a
e276 : a58f             [ 3] 	lda num_a+1
                             
                             	; get a block of that size from heap
e278 : 2082ef           [ 6] 	jsr df_st_malloc
                             	; save pointer to block in var
e27b : a002             [ 2] 	ldy #DFVVT_HI
e27d : 91d4             [ 5] 	sta (df_tmpptra),y
e27f : 8a               [ 2] 	txa
e280 : 88               [ 2] 	dey
e281 : 91d4             [ 5] 	sta (df_tmpptra),y
                             	; finally, update the type to indicate array
e283 : b2d4             [ 5] 	lda (df_tmpptra)
e285 : 0980             [ 2] 	ora #DFVVT_ARRY
e287 : 92d4             [ 5] 	sta (df_tmpptra)
                             	; don't increment byte again - go check for more
e289 : 808e             [ 3] 	bra df_rt_dim	
e28b :                       df_rt_dim_next_byte
e28b : e6d1             [ 5] 	inc df_exeoff
e28d : 808a             [ 3] 	bra df_rt_dim
e28f :                       df_rt_dim_done
                             ;	clc
e28f : 60               [ 6] 	rts
e290 :                       df_rt_dim_err
                             	SWBRK DFERR_DIM
                             
                             
e292 :                       df_rt_cls
                             	; set cursror position to top left first
e292 : a200             [ 2] 	ldx #0
e294 : a000             [ 2] 	ldy #0
e296 : 205ec3           [ 6] 	jsr _gr_set_cur
e299 : 4c86c2           [ 3] 	jmp _gr_cls
                             ;	clc
                             ;	rts
                             	
e29c :                       df_rt_plot
                             	; evaluate the expression
e29c : 2007d8           [ 6] 	jsr df_rt_getnval
                             	; save lo byte
e29f : da               [ 3] 	phx
                             	; jump over comma
e2a0 : e6d1             [ 5] 	inc df_exeoff
                             	; evaluate the expression
e2a2 : 2007d8           [ 6] 	jsr df_rt_getnval
                             	; save lo byte
AS65 Assembler for R6502 [1.42].                                     Page  137
-------------------------------- bank\bank1.s --------------------------------

e2a5 : da               [ 3] 	phx
                             	; jump over comma
e2a6 : e6d1             [ 5] 	inc df_exeoff
                             	; evaluate the expression
e2a8 : 2061d7           [ 6] 	jsr df_rt_neval
                             	; check the type on the stack
e2ab : 206bef           [ 6] 	jsr df_st_peekType
                             	; if >=0x80 then a pointer / string
e2ae : c080             [ 2] 	cpy #0x80
e2b0 : b009             [ 3] 	bcs df_rt_plotstr
                             	; else it is int
e2b2 : 2073ef           [ 6] 	jsr df_st_popInt
                             	; put low byte of pop result in a
e2b5 : 8a               [ 2] 	txa
                             	; get y and x in that order
e2b6 : 7a               [ 4] 	ply
e2b7 : fa               [ 4] 	plx
e2b8 : 4cfec2           [ 3] 	jmp _gr_plot
                             ;	clc
                             ;	rts
                             
e2bb :                       df_rt_plotstr
                             	; pop string pointer
e2bb : 207def           [ 6] 	jsr df_st_popPtr
                             	; save pointer to tmpa
e2be : 86d4             [ 3] 	stx df_tmpptra
e2c0 : 85d5             [ 3] 	sta df_tmpptra+1
                             	; get y and x in that order
e2c2 : 7a               [ 4] 	ply
e2c3 : fa               [ 4] 	plx
                             	; set cursror position
e2c4 :                       df_rt_plotstrch
e2c4 : b2d4             [ 5] 	lda (df_tmpptra)
e2c6 : f010             [ 3] 	beq df_rt_plotstrdone
                             	_incZPWord df_tmpptra
                             
e2ce : da               [ 3] 	phx
e2cf : 5a               [ 3] 	phy
e2d0 : 20fec2           [ 6] 	jsr _gr_plot
e2d3 : 7a               [ 4] 	ply
e2d4 : fa               [ 4] 	plx
e2d5 : e8               [ 2] 	inx
e2d6 : 80ec             [ 3] 	bra df_rt_plotstrch
e2d8 :                       df_rt_plotstrdone
                             ;	clc
e2d8 : 60               [ 6] 	rts
                             	
e2d9 :                       df_rt_cursor
                             	; evaluate the expression
e2d9 : 2007d8           [ 6] 	jsr df_rt_getnval
                             	; write low byte of vdp_curoff
                             	; by writing a zero then cursor on else not
e2dc : 860f             [ 3] 	stx vdp_curoff
                             ;	clc
e2de : 60               [ 6] 	rts
                             		
e2df :                       df_rt_himem
                             	; evaluate the expression
e2df : 2007d8           [ 6] 	jsr df_rt_getnval
                             	; write X,A to df_memtop
e2e2 : 8eb90b           [ 4] 	stx df_memtop
e2e5 : 8dba0b           [ 4] 	sta df_memtop+1
AS65 Assembler for R6502 [1.42].                                     Page  138
-------------------------------- bank\bank1.s --------------------------------

                             	; now clear everything down
e2e8 : 4cabef           [ 3] 	jmp df_clear
e2eb : 60               [ 6] 	rts
                             
e2ec :                       df_rt_mode
                             	; evaluate the expression
e2ec : 2007d8           [ 6] 	jsr df_rt_getnval
                             	; only interested in low byte
e2ef : 8a               [ 2] 	txa
e2f0 : 4c66c1           [ 3] 	jmp _gr_init_screen
                             ;	clc
                             ;	rts
                             
e2f3 :                       df_rt_hires
                             	; evaluate the expression X = colour fg/bg
e2f3 : 2007d8           [ 6] 	jsr df_rt_getnval
e2f6 : 4c9ec2           [ 3] 	jmp _gr_init_hires
                             ;	clc
                             ;	rts
                             	
e2f9 :                       df_rt_pixmode
                             	; evaluate the expression X = mode
e2f9 : 2007d8           [ 6] 	jsr df_rt_getnval
e2fc : 862a             [ 3] 	stx gr_scrngeom+gr_pixmode
                             ;	clc
e2fe : 60               [ 6] 	rts
                             
e2ff :                       df_rt_pixmask
                             	; evaluate the expression X = mask
e2ff : 2007d8           [ 6] 	jsr df_rt_getnval
e302 : 862b             [ 3] 	stx gr_scrngeom+gr_pixmask
                             ;	clc
e304 : 60               [ 6] 	rts
                             
e305 :                       df_rt_pixcol
                             	; evaluate the expression X = col
e305 : 2007d8           [ 6] 	jsr df_rt_getnval
e308 : 862c             [ 3] 	stx gr_scrngeom+gr_pixcol
                             ;	clc
e30a : 60               [ 6] 	rts
                             
e30b :                       df_rt_point
e30b : 2008da           [ 6] 	jsr df_rt_parm_2ints
e30e : a6d4             [ 3] 	ldx df_tmpptra
e310 : a4d6             [ 3] 	ldy df_tmpptrb
e312 : 4c2ec3           [ 3] 	jmp _gr_point
                             ;	clc
                             ;	rts
                             
e315 :                       df_rt_circle
e315 : 201fda           [ 6] 	jsr df_rt_parm_3ints
e318 : a5d4             [ 3] 	lda df_tmpptra				; load x0
e31a : 858e             [ 3] 	sta num_a
e31c : a5d6             [ 3] 	lda	df_tmpptrb				; load y0
e31e : 858f             [ 3] 	sta num_a+1
e320 : a5d8             [ 3] 	lda df_tmpptrc				; load r
e322 : 8590             [ 3] 	sta num_a+2
e324 : 4ce6c2           [ 3] 	jmp _gr_circle
                             
e327 :                       df_rt_line
e327 : 2042da           [ 6] 	jsr df_rt_parm_4ints
e32a : a5d4             [ 3] 	lda df_tmpptra				; load x0
AS65 Assembler for R6502 [1.42].                                     Page  139
-------------------------------- bank\bank1.s --------------------------------

e32c : 858e             [ 3] 	sta num_a
e32e : a5d6             [ 3] 	lda	df_tmpptrb				; load y0
e330 : 858f             [ 3] 	sta num_a+1
e332 : a5d8             [ 3] 	lda df_tmpptrc				; load x1
e334 : 8590             [ 3] 	sta num_a+2
e336 : a5da             [ 3] 	lda df_tmpptrd				; load y1
e338 : 8591             [ 3] 	sta num_a+3
e33a : 4cb6c2           [ 3] 	jmp _gr_line
                             
e33d :                       df_rt_box
e33d : 2042da           [ 6] 	jsr df_rt_parm_4ints
e340 : a5d4             [ 3] 	lda df_tmpptra				; load x0
e342 : 858e             [ 3] 	sta num_a
e344 : a5d6             [ 3] 	lda	df_tmpptrb				; load y0
e346 : 858f             [ 3] 	sta num_a+1
e348 : a5d8             [ 3] 	lda df_tmpptrc				; load x1
e34a : 8590             [ 3] 	sta num_a+2
e34c : a5da             [ 3] 	lda df_tmpptrd				; load y1
e34e : 8591             [ 3] 	sta num_a+3
e350 : 4ccec2           [ 3] 	jmp _gr_box
                             
e353 :                       df_rt_hplot
e353 : 201fda           [ 6] 	jsr df_rt_parm_3ints
e356 : a6d4             [ 3] 	ldx df_tmpptra
e358 : a4d6             [ 3] 	ldy df_tmpptrb
e35a : a5d8             [ 3] 	lda df_tmpptrc
e35c : 4c16c3           [ 3] 	jmp _gr_hchar
                             
e35f :                       df_rt_shape
e35f : 201fda           [ 6] 	jsr df_rt_parm_3ints
e362 : a6d4             [ 3] 	ldx df_tmpptra				; load x
e364 : da               [ 3] 	phx
e365 : a4d6             [ 3] 	ldy	df_tmpptrb				; load y
e367 : 5a               [ 3] 	phy
e368 : a6d8             [ 3] 	ldx df_tmpptrc				; load coords[]
e36a : a5d9             [ 3] 	lda df_tmpptrc+1			; load coords[]
e36c : 2013ef           [ 6] 	jsr df_st_pushWord
e36f :                       df_rt_shapeLoop
e36f : 2021ef           [ 6] 	jsr df_st_popWord			; Get pointer
e372 : 86d4             [ 3] 	stx df_tmpptra
e374 : 85d5             [ 3] 	sta df_tmpptra+1
e376 : b2d4             [ 5] 	lda (df_tmpptra)			; Get X coord as int
e378 : 8539             [ 3] 	sta tmp_alo
e37a : a001             [ 2] 	ldy #1
e37c : b1d4             [ 5] 	lda (df_tmpptra),y			; Get X hi byte
e37e : 853a             [ 3] 	sta tmp_ahi
e380 : c8               [ 2] 	iny
e381 : b1d4             [ 5] 	lda (df_tmpptra),y			; Get Y coord as int
e383 : 853b             [ 3] 	sta tmp_blo
e385 : c8               [ 2] 	iny
e386 : b1d4             [ 5] 	lda (df_tmpptra),y			; Get Y hi byte
e388 : 853c             [ 3] 	sta tmp_bhi
e38a : a539             [ 3] 	lda tmp_alo					; If X and Y low are zero then e
e38c : d007             [ 3] 	bne df_rt_shapeCalc
e38e : a53b             [ 3] 	lda tmp_blo
e390 : d003             [ 3] 	bne df_rt_shapeCalc
                             	; Got here then must be finished
e392 : 68               [ 4] 	pla							; Pop bytes off 6502 stack
e393 : 68               [ 4] 	pla
e394 : 60               [ 6] 	rts
e395 :                       df_rt_shapeCalc
e395 : 18               [ 2] 	clc
AS65 Assembler for R6502 [1.42].                                     Page  140
-------------------------------- bank\bank1.s --------------------------------

e396 : a5d4             [ 3] 	lda df_tmpptra				; Increment coord pointer 
e398 : 6904             [ 2] 	adc #4						; 2 ints is 4 bytes per coord
e39a : aa               [ 2] 	tax
e39b : a5d5             [ 3] 	lda df_tmpptra+1
e39d : 6900             [ 2] 	adc #0
e39f : 2013ef           [ 6] 	jsr df_st_pushWord			; Put pointer on runtime st
                             	; previous cursor is starting position
                             	; plus delta is new position
e3a2 : 68               [ 4] 	pla							; get y0 off stack
e3a3 : 18               [ 2] 	clc
e3a4 : 858f             [ 3] 	sta num_a+1
e3a6 : 653b             [ 3] 	adc tmp_blo
e3a8 : 8591             [ 3] 	sta num_a+3					; y1 = y0+dy
e3aa : aa               [ 2] 	tax							; save y1 in X reg
e3ab : 68               [ 4] 	pla							; get x0 off stack
e3ac : 18               [ 2] 	clc
e3ad : 858e             [ 3] 	sta num_a					; x0
e3af : 6539             [ 3] 	adc tmp_alo
e3b1 : 8590             [ 3] 	sta num_a+2					; x1
e3b3 : 48               [ 3] 	pha							; save x1
e3b4 : da               [ 3] 	phx							; save y1
e3b5 : 20b6c2           [ 6] 	jsr _gr_line				; line x0,y0,x1,y1
e3b8 : 80b5             [ 3] 	bra df_rt_shapeLoop			; go back to next coord
                             	
e3ba :                       df_rt_wait
                             	; evaluate the expression
e3ba : 2007d8           [ 6] 	jsr df_rt_getnval
                             	; put high byte in to Y (X,Y)=16 bits
e3bd : a8               [ 2] 	tay
e3be :                       df_rt_wait_counter
                             	; get vdp low byte timer val in A
e3be : a50c             [ 3] 	lda vdp_cnt	
e3c0 :                       df_rt_wait_tick
                             	; check if a tick has occurred (i.e. val <> A)
e3c0 : c50c             [ 3] 	cmp vdp_cnt
e3c2 : f0fc             [ 3] 	beq df_rt_wait_tick
                             	; countdown tick
e3c4 : ca               [ 2] 	dex
e3c5 : e0ff             [ 2] 	cpx #0xff
e3c7 : d001             [ 3] 	bne df_rt_wait_skiphi
e3c9 : 88               [ 2] 	dey
e3ca :                       df_rt_wait_skiphi
e3ca : e000             [ 2] 	cpx #0
e3cc : d0f0             [ 3] 	bne df_rt_wait_counter
e3ce : c000             [ 2] 	cpy #0
e3d0 : d0ec             [ 3] 	bne df_rt_wait_counter
e3d2 : 60               [ 6] 	rts
                             	
e3d3 :                       df_rt_printat
                             	; Get x,y
e3d3 : 2008da           [ 6] 	jsr df_rt_parm_2ints
e3d6 : a6d4             [ 3] 	ldx df_tmpptra
e3d8 : a4d6             [ 3] 	ldy df_tmpptrb
                             	; Set the cursror here
e3da : 205ec3           [ 6] 	jsr _gr_set_cur
                             	; and continue to normal print command
e3dd :                       df_rt_print
e3dd : a4d1             [ 3] 	ldy df_exeoff
e3df : 88               [ 2] 	dey
e3e0 :                       df_rt_print_ws
e3e0 : c8               [ 2] 	iny
                             	; evaluate an expression
AS65 Assembler for R6502 [1.42].                                     Page  141
-------------------------------- bank\bank1.s --------------------------------

e3e1 : c4c7             [ 3] 	cpy df_eolidx
e3e3 : f032             [ 4] 	beq df_rt_print_done
e3e5 : c4c8             [ 3] 	cpy df_nxtstidx
e3e7 : f02e             [ 4] 	beq df_rt_print_done
e3e9 : b1cf             [ 5] 	lda (df_currlin),y
e3eb : c920             [ 2] 	cmp #' '
e3ed : f0f1             [ 3] 	beq df_rt_print_ws
e3ef : c92c             [ 2] 	cmp #','
e3f1 : f0ed             [ 3] 	beq df_rt_print_ws
                             	; save index
e3f3 : 84d1             [ 3] 	sty df_exeoff
                             	
                             	; if starts with string literal then process sev
e3f5 : c910             [ 2] 	cmp #DFTK_STRLIT
e3f7 : f015             [ 4] 	beq df_rt_print_string
                             	; else evaluate a numeric
e3f9 : 2061d7           [ 6] 	jsr df_rt_neval
                             	; check what is on the argument stack
e3fc : a4c0             [ 3] 	ldy df_parmtop
e3fe : 88               [ 2] 	dey
e3ff : b9000b           [ 4] 	lda df_opstck,y
e402 : 3005             [ 3] 	bmi df_rt_print_gotstr
e404 : 20e6e0           [ 6] 	jsr df_rt_print_num
e407 : 80d4             [ 4] 	bra df_rt_print
e409 :                       df_rt_print_gotstr
e409 : 20ede0           [ 6] 	jsr df_rt_print_str
e40c : 80cf             [ 4] 	bra df_rt_print
e40e :                       df_rt_print_string
                             	; point to string accumulator
e40e : a6c3             [ 3] 	ldx df_sevalptr
e410 : a5c4             [ 3] 	lda df_sevalptr+1
e412 : 200dd8           [ 6] 	jsr df_rt_seval
e415 : 80f2             [ 3] 	bra df_rt_print_gotstr
e417 :                       df_rt_print_done
e417 : 84d1             [ 3] 	sty df_exeoff
e419 : 60               [ 6] 	rts
                             	
e41a :                       df_rt_println
e41a : 20dde3           [ 6] 	jsr df_rt_print
e41d : a90d             [ 2] 	lda #UTF_CR
e41f : 4c49c4           [ 3] 	jmp io_put_ch
                             
                             
                             ; assign to a number variable
                             ; X,A must have lvar
e422 :                       df_rt_nassign
e422 : 48               [ 3] 	pha
e423 : da               [ 3] 	phx
                             	; now go evaluate expression in to A,X
e424 : 2007d8           [ 6] 	jsr df_rt_getnval
                             	; restore variable address to write to
e427 : 7a               [ 4] 	ply
e428 : 84d4             [ 3] 	sty df_tmpptra
e42a : 7a               [ 4] 	ply
e42b : 84d5             [ 3] 	sty df_tmpptra+1
                             	; save X,A int in contents section
e42d : a001             [ 2] 	ldy #1
e42f : 91d4             [ 5] 	sta (df_tmpptra),y
e431 : 8a               [ 2] 	txa
e432 : a000             [ 2] 	ldy #0
e434 : 91d4             [ 5] 	sta (df_tmpptra),y
                             
AS65 Assembler for R6502 [1.42].                                     Page  142
-------------------------------- bank\bank1.s --------------------------------

e436 : 60               [ 6] 	rts
                             
                             ; assign to a string variable
                             ; X,A must have lvar
e437 :                       df_rt_sassign
                             	; now go evaluate expression
                             	; with the destination being X,A
e437 : 200dd8           [ 6] 	jsr df_rt_seval
                             
                             	; get string pointer from top of runtime stack
e43a : 4c78ef           [ 3] 	jmp df_st_popStr
                             	
                             ;	clc
                             ;	rts
                             
                             ; generate lvar from a var token ready for assign
e43d :                       df_rt_generate_lvar
                             	; move past escape val
e43d : e6d1             [ 5] 	inc df_exeoff
e43f : a4d1             [ 3] 	ldy df_exeoff
                             	; pointing to variable index
e441 : b1cf             [ 5] 	lda (df_currlin),y
                             	; get the vvt address
e443 : 20d4ca           [ 6] 	jsr df_var_addr
                             
                             	; get the type and save
e446 : b2d4             [ 5] 	lda (df_tmpptra)
e448 : 48               [ 3] 	pha
                             
                             	; set carry flag to return pointer (lvar)
e449 : 38               [ 2] 	sec
e44a : 20f2d8           [ 6] 	jsr df_rt_eval_var
e44d : 207def           [ 6] 	jsr df_st_popPtr
                             	; pull the type previously saved into Y
e450 : 7a               [ 4] 	ply
                             	; move past the lvar variable index
e451 : e6d1             [ 5] 	inc df_exeoff
                             ;	clc
e453 : 60               [ 6] 	rts
                             
                             ; assign
                             ; X,A,Y contain lvar pointer and type
e454 :                       df_rt_doassign
                             	; save A and put type Y in to A
e454 : 48               [ 3] 	pha
e455 : 98               [ 2] 	tya
e456 : 2904             [ 2] 	and #DFVVT_STR
                             	; if a string then string expression
e458 : f004             [ 3] 	beq df_rt_assign_num
                             	; remember to restore A
                             	; jump to string expression evaluator
e45a : 68               [ 4] 	pla
e45b : 4c37e4           [ 3] 	jmp df_rt_sassign
e45e :                       df_rt_assign_num
                             	; else jump to numeric expression evaluator
                             	; remember to restore A
e45e : 68               [ 4] 	pla
e45f : 4c22e4           [ 3] 	jmp df_rt_nassign
                             
                             ; general assignment execution
e462 :                       df_rt_assign
e462 : 203de4           [ 6] 	jsr df_rt_generate_lvar
AS65 Assembler for R6502 [1.42].                                     Page  143
-------------------------------- bank\bank1.s --------------------------------

                             	; go and do the assignment
e465 : 4c54e4           [ 3] 	jmp df_rt_doassign
                             	
                             ; comment or data token is ignored by runtime
e468 :                       df_rt_comment
e468 :                       df_rt_data
                             ;	clc
e468 : 60               [ 6] 	rts
                             
                             	
                             ; run token	
e469 :                       df_rt_run
                             ;	sec
e469 : 60               [ 6] 	rts
                             
                             ; end of line / statement indicator
                             ; CS = End, CC = not end
e46a :                       df_rt_eos
e46a : a4d1             [ 3] 	ldy df_exeoff
e46c : c4c7             [ 3] 	cpy df_eolidx
e46e : f00c             [ 3] 	beq df_rt_eos_true
e470 : b1cf             [ 5] 	lda (df_currlin),y
e472 : c93a             [ 2] 	cmp #':'
e474 : f006             [ 3] 	beq df_rt_eos_true
e476 : c4c8             [ 3] 	cpy df_nxtstidx
e478 : f002             [ 3] 	beq df_rt_eos_true
e47a : 18               [ 2] 	clc
e47b : 60               [ 6] 	rts
e47c :                       df_rt_eos_true
e47c : 38               [ 2] 	sec
e47d : 60               [ 6] 	rts
                             
                             ; renum start,offset,increment
                             ; if increment == 0 then just add offset to the a
                             ; if increment <> 0 then renumber from first affe
                             ; renumbers from the first matching line to end o
e47e :                       df_rt_renum
e47e : e6d1             [ 5] 	inc df_exeoff
e480 : 201fda           [ 6] 	jsr df_rt_parm_3ints
                             	; starting line number
e483 : a6d4             [ 3] 	ldx df_tmpptra
e485 : a5d5             [ 3] 	lda df_tmpptra+1
e487 : 209ed5           [ 6] 	jsr df_pg_find_line
e48a : 9002             [ 3] 	bcc df_rt_renum_ok
                             	SWBRK DFERR_NOLINE
                             
e48e :                       df_rt_renum_ok
                             	; save starting position in program
e48e : 86da             [ 3] 	stx df_tmpptrd
e490 : 85db             [ 3] 	sta df_tmpptrd+1
e492 :                       df_rt_renum_do
                             	; if not end of program
e492 : b2da             [ 5] 	lda (df_tmpptrd)
                             	; then renumber this line
e494 : d001             [ 3] 	bne df_rt_renum_update
                             	; else done
e496 : 60               [ 6] 	rts
e497 :                       df_rt_renum_update
                             	; add offset to start line number
                             	; add increment to start line number
                             	; if increment <> 0 then update this line number
                             	; if increment == 0 then add offset to this  lin
AS65 Assembler for R6502 [1.42].                                     Page  144
-------------------------------- bank\bank1.s --------------------------------

                             	
                             	; add offset to start line number
                             	_addZPWord df_tmpptra,df_tmpptrb
                             
                             	; if increment == 0 then update this line with s
e4a4 : a5d8             [ 3] 	lda df_tmpptrc
e4a6 : 05d9             [ 3] 	ora df_tmpptrc+1
e4a8 : f01a             [ 3] 	beq df_rt_renum_mode2
                             	; mode 1 means increment <> 0
                             	; so set this line number to current value of st
e4aa : a001             [ 2] 	ldy #DFTK_LINNUM
e4ac : a5d4             [ 3] 	lda df_tmpptra
e4ae : 91da             [ 5] 	sta (df_tmpptrd),y
e4b0 : c8               [ 2] 	iny
e4b1 : a5d5             [ 3] 	lda df_tmpptra+1
e4b3 : 91da             [ 5] 	sta (df_tmpptrd),y
                             	; add increment to start line
                             	_addZPWord df_tmpptra,df_tmpptrc
                             
e4c2 : 8010             [ 3] 	bra df_rt_renum_next
e4c4 :                       df_rt_renum_mode2
                             	; mode 2 means increment == 0
                             	; so just add offset to this line number
e4c4 : a001             [ 2] 	ldy #DFTK_LINNUM
e4c6 : 18               [ 2] 	clc
e4c7 : b1da             [ 5] 	lda (df_tmpptrd),y
e4c9 : 65d6             [ 3] 	adc df_tmpptrb
e4cb : 91da             [ 5] 	sta (df_tmpptrd),y
e4cd : c8               [ 2] 	iny
e4ce : b1da             [ 5] 	lda (df_tmpptrd),y
e4d0 : 65d7             [ 3] 	adc df_tmpptrb+1
e4d2 : 91da             [ 5] 	sta (df_tmpptrd),y	
e4d4 :                       df_rt_renum_next
e4d4 : 18               [ 2] 	clc
e4d5 : a5da             [ 3] 	lda df_tmpptrd
e4d7 : 72da             [ 5] 	adc (df_tmpptrd)
e4d9 : 85da             [ 3] 	sta df_tmpptrd
e4db : a5db             [ 3] 	lda df_tmpptrd+1
e4dd : 6900             [ 2] 	adc #0
e4df : 85db             [ 3] 	sta df_tmpptrd+1
e4e1 : 80af             [ 3] 	bra df_rt_renum_do
                             
                             
                             ; * List all procs in VNT
e4e3 :                       df_rt_listprocnames
                             	; start at the beginning of the vnt table
                             	_cpyZPWord df_vntstrt,df_tmpptra
                             
                             	; start at index 0
e4eb : 64d6             [ 3] 	stz df_tmpptrb
e4ed :                       df_rt_listcheckvnt
                             	; If reached the var count then not found
e4ed : a5d6             [ 3] 	lda df_tmpptrb
e4ef : c5ba             [ 3] 	cmp df_varcnt
e4f1 : f03c             [ 4] 	beq df_rt_listpn_done
e4f3 : a000             [ 2] 	ldy #0
e4f5 : b1d4             [ 5] 	lda (df_tmpptra),y
e4f7 : c95f             [ 2] 	cmp #'_'
e4f9 : d01c             [ 4] 	bne df_rt_listnextvnt
e4fb :                       df_rt_listprocch
e4fb : b1d4             [ 5] 	lda (df_tmpptra),y
e4fd : 2049c4           [ 6] 	jsr io_put_ch
AS65 Assembler for R6502 [1.42].                                     Page  145
-------------------------------- bank\bank1.s --------------------------------

e500 : c900             [ 2] 	cmp #0
e502 : f003             [ 3] 	beq df_rt_listproccr
e504 : c8               [ 2] 	iny
e505 : 80f4             [ 4] 	bra df_rt_listprocch
e507 :                       df_rt_listproccr
e507 : a90d             [ 2] 	lda #UTF_CR
e509 : 2049c4           [ 6] 	jsr io_put_ch
e50c : 18               [ 2] 	clc
e50d :                       df_rt_listprocpause
e50d : 2046c4           [ 6] 	jsr io_get_ch
e510 : c920             [ 2] 	cmp #' '
e512 : d003             [ 3] 	bne df_rt_listnextvnt
e514 :                       df_rt_listwait
e514 : 38               [ 2] 	sec
e515 : 80f6             [ 3] 	bra df_rt_listprocpause
e517 :                       df_rt_listnextvnt
e517 : b1d4             [ 5] 	lda (df_tmpptra),y
e519 : f003             [ 3] 	beq df_rt_listgotnext
e51b : c8               [ 2] 	iny
e51c : 80f9             [ 3] 	bra df_rt_listnextvnt
e51e :                       df_rt_listgotnext
                             	; increment vnt #
e51e : e6d6             [ 5] 	inc df_tmpptrb
                             	; skip past zero terminator
e520 : c8               [ 2] 	iny
                             	; add this to vnt pointer
e521 : 18               [ 2] 	clc
e522 : 98               [ 2] 	tya
e523 : 65d4             [ 3] 	adc df_tmpptra
e525 : 85d4             [ 3] 	sta df_tmpptra
e527 : a5d5             [ 3] 	lda df_tmpptra+1
e529 : 6900             [ 2] 	adc #0
e52b : 85d5             [ 3] 	sta df_tmpptra+1
e52d : 80be             [ 4] 	bra df_rt_listcheckvnt
e52f :                       df_rt_listpn_done
e52f : 60               [ 6] 	rts
                             
e530 :                       df_rt_listproc
                             	;copy procname to linbuff
                             	; always put '_'
e530 : a95f             [ 2] 	lda #'_'
e532 : 8d0009           [ 4] 	sta df_linbuff
e535 : a200             [ 2] 	ldx #0
e537 : a4d1             [ 3] 	ldy df_exeoff
e539 :                       df_rt_listp_copy
e539 : c8               [ 2] 	iny
e53a : e8               [ 2] 	inx
e53b : b1cf             [ 5] 	lda (df_currlin),y
e53d : 9d0009           [ 5] 	sta df_linbuff,x
e540 : 20b7cd           [ 6] 	jsr df_tk_isalphanum
e543 : b0f4             [ 3] 	bcs df_rt_listp_copy
                             	; zero the line index
e545 : 64c5             [ 3] 	stz df_linoff
                             	; save runtime pos
e547 : 84d1             [ 3] 	sty df_exeoff
                             	; Now try and find in VNT
e549 : 20efca           [ 6] 	jsr df_var_find
e54c : b037             [ 3] 	bcs df_rt_listp_notfound
                             	; Ok we have got a match in A, find the proc
e54e : 2078db           [ 6] 	jsr df_rt_findproc
                             	; Save the line pointer
e551 : 86d4             [ 3] 	stx df_tmpptra
AS65 Assembler for R6502 [1.42].                                     Page  146
-------------------------------- bank\bank1.s --------------------------------

e553 : 85d5             [ 3] 	sta df_tmpptra+1
                             	; save statement index in to line
e555 : 84e5             [ 3] 	sty df_lineidx
                             	; Check if '-' option used
e557 : a4d1             [ 3] 	ldy df_exeoff
e559 : b1cf             [ 5] 	lda (df_currlin),y
e55b : c92d             [ 2] 	cmp #'-'
                             	; if so, list to end of program
e55d : f063             [ 3] 	beq df_rt_listprgend
                             	; Now try and find the end of this procedure
                             	; enddef or another def
                             	; A,X=Line ptr, Y=line idx
e55f : a6d4             [ 3] 	ldx df_tmpptra
e561 : a5d5             [ 3] 	lda df_tmpptra+1
e563 : a4e5             [ 3] 	ldy df_lineidx
e565 :                       df_rt_listp_findend
                             	; Go to next stat
e565 : 2023db           [ 6] 	jsr df_rt_nextstat
e568 : b058             [ 3] 	bcs df_rt_listprgend
                             	; save y (a,x in lineptr)
e56a : 5a               [ 3] 	phy
                             	; find the command
e56b :                       df_rt_listp_findcmd
e56b : c8               [ 2] 	iny
e56c : b1e3             [ 5] 	lda (df_lineptr),y
e56e : 10fb             [ 3] 	bpl df_rt_listp_findcmd
                             	; restore y to stat beginning
e570 : 7a               [ 4] 	ply
                             	; check A - looking for enddef or def
e571 : c987             [ 2] 	cmp #DFRT_ENDDEF
e573 : f00a             [ 3] 	beq df_rt_listp_done
e575 : c986             [ 2] 	cmp #DFRT_DEF
e577 : f006             [ 3] 	beq df_rt_listp_done
                             	; if neither then next stat from current
e579 : a6e3             [ 3] 	ldx df_lineptr
e57b : a5e4             [ 3] 	lda df_lineptr+1
e57d : 80e6             [ 3] 	bra df_rt_listp_findend
e57f :                       df_rt_listp_done
                             	; Push end line on to stack
e57f : a5e4             [ 3] 	lda df_lineptr+1
e581 : 48               [ 3] 	pha
e582 : da               [ 3] 	phx
e583 : 8043             [ 3] 	bra df_rt_list_line 
e585 :                       df_rt_listp_notfound
                             	; Fatal error if proc not found
                             	SWBRK DFERR_NOPROC
                             
                             	
                             ; list token
e587 :                       df_rt_list
e587 : 64dc             [ 3] 	stz df_tmpptre		; Zero means in normal list mode
                             	; find non-ws
e589 : 20c5db           [ 6] 	jsr df_rt_skip_ws
                             	; if end of statement then no line specifiers
e58c : 206ae4           [ 6] 	jsr df_rt_eos
                             	; so list whole program
e58f : b029             [ 3] 	bcs df_rt_listprg
                             	
                             	;if '_' then use procnames
e591 : c95f             [ 2] 	cmp #'_'
e593 : d003             [ 3] 	bne df_rt_list_all
e595 : 4c30e5           [ 3] 	jmp df_rt_listproc
AS65 Assembler for R6502 [1.42].                                     Page  147
-------------------------------- bank\bank1.s --------------------------------

e598 :                       df_rt_list_all
                             	;if '*' then display all procnames
e598 : c92a             [ 2] 	cmp #'*'
e59a : d003             [ 3] 	bne df_rt_list_linno
e59c : 4ce3e4           [ 3] 	jmp df_rt_listprocnames
e59f :                       df_rt_list_linno
                             	; else get 1st parameter
e59f : 2007d8           [ 6] 	jsr df_rt_getnval
                             	; find the starting line number in X,A
e5a2 : 209ed5           [ 6] 	jsr df_pg_find_line
e5a5 : 86d4             [ 3] 	stx df_tmpptra
e5a7 : 85d5             [ 3] 	sta df_tmpptra+1
                             	
                             	; if end of statement then only start line was p
e5a9 : 206ae4           [ 6] 	jsr df_rt_eos
                             	; so list until end of program
e5ac : b014             [ 3] 	bcs df_rt_listprgend
                             	; else get 2nd parameter
e5ae : e6d1             [ 5] 	inc df_exeoff
e5b0 : 2007d8           [ 6] 	jsr df_rt_getnval
                             	; find the starting line number in X,A
e5b3 : 209ed5           [ 6] 	jsr df_pg_find_line
e5b6 : 48               [ 3] 	pha
e5b7 : da               [ 3] 	phx
e5b8 : 800e             [ 3] 	bra df_rt_list_line
                             
                             ; Common listing routine used by LIST and SAVE
                             ; tmpe = 0 means in LIST mode else SAVE mode
                             ; can stop the listing in LIST mode with CTRL-C
e5ba :                       df_rt_listprg
                             	; program start and end as for pointer value
                             	_cpyZPWord df_prgstrt, df_tmpptra
                             
e5c2 :                       df_rt_listprgend
e5c2 : a5b1             [ 3] 	lda df_prgend+1
e5c4 : 48               [ 3] 	pha
e5c5 : a5b0             [ 3] 	lda df_prgend
e5c7 : 48               [ 3] 	pha
e5c8 :                       df_rt_list_line
                             	; if line length = 0 then end of program
e5c8 : b2d4             [ 5] 	lda (df_tmpptra)
e5ca : f019             [ 3] 	beq df_rt_list_line_fin
                             	; if in list mode and CTRL-C then also stop
e5cc : a5dc             [ 3] 	lda df_tmpptre
e5ce : d019             [ 3] 	bne df_rt_list_line_cont
                             	; check for break, asynch get
e5d0 : 18               [ 2] 	clc
e5d1 :                       df_rt_list_synckey
e5d1 : a5dc             [ 3] 	lda df_tmpptre					; Ignore keys on save mode
e5d3 : d014             [ 3] 	bne df_rt_list_line_cont
e5d5 : 2046c4           [ 6] 	jsr io_get_ch
e5d8 : c920             [ 2] 	cmp #' '						; Space = PAUSE
e5da : f006             [ 3] 	beq df_rt_list_pause
e5dc : c903             [ 2] 	cmp #UTF_ETX					; CTRL-C?
e5de : f005             [ 3] 	beq df_rt_list_line_fin
e5e0 : 8007             [ 3] 	bra df_rt_list_line_cont		; any other key contin
e5e2 :                       df_rt_list_pause
e5e2 : 38               [ 2] 	sec								; Check key sync
e5e3 : 80ec             [ 3] 	bra df_rt_list_synckey
e5e5 :                       df_rt_list_line_fin
e5e5 : 68               [ 4] 	pla
e5e6 : 68               [ 4] 	pla
AS65 Assembler for R6502 [1.42].                                     Page  148
-------------------------------- bank\bank1.s --------------------------------

e5e7 : 18               [ 2] 	clc
e5e8 : 60               [ 6] 	rts
e5e9 :                       df_rt_list_line_cont
e5e9 : a000             [ 2] 	ldy #0
e5eb : 84d1             [ 3] 	sty df_exeoff
e5ed : 2025e7           [ 6] 	jsr df_rt_list_linnum
e5f0 : 2014e6           [ 6] 	jsr df_rt_list_line_only
e5f3 :                       df_rt_list_next_line
                             	; new line
e5f3 : a90d             [ 2] 	lda #UTF_CR
e5f5 : 2049c4           [ 6] 	jsr io_put_ch
                             	; increment pointer to next line
e5f8 : 18               [ 2] 	clc
e5f9 : a5d4             [ 3] 	lda df_tmpptra
e5fb : 72d4             [ 5] 	adc (df_tmpptra)
e5fd : 85d4             [ 3] 	sta df_tmpptra
e5ff : a5d5             [ 3] 	lda df_tmpptra+1
e601 : 6900             [ 2] 	adc #0
e603 : 85d5             [ 3] 	sta df_tmpptra+1
                             	; if pointer > end then listing is done
e605 : 38               [ 2] 	sec
e606 : 68               [ 4] 	pla
e607 : aa               [ 2] 	tax
e608 : e5d4             [ 3] 	sbc df_tmpptra
e60a : 68               [ 4] 	pla
e60b : 48               [ 3] 	pha
e60c : da               [ 3] 	phx
e60d : e5d5             [ 3] 	sbc df_tmpptra+1
e60f : b0b7             [ 4] 	bcs df_rt_list_line
                             	
                             	; if got here then reached tmpb
e611 : 68               [ 4] 	pla
e612 : 68               [ 4] 	pla
e613 : 60               [ 6] 	rts
                             
                             ;Using df_tmpptra as line pointer
                             ;Print decode an entire line
e614 :                       df_rt_list_line_only
e614 : a003             [ 2] 	ldy #3
e616 : b1d4             [ 5] 	lda (df_tmpptra),y
e618 : 85c8             [ 3] 	sta df_nxtstidx
e61a : c8               [ 2] 	iny
e61b : 84d1             [ 3] 	sty df_exeoff
e61d :                       df_rt_list_decode
e61d : a4d1             [ 3] 	ldy df_exeoff
e61f : b1d4             [ 5] 	lda (df_tmpptra),y
e621 : 300e             [ 3] 	bmi df_rt_list_token
e623 : c920             [ 2] 	cmp #DFTK_ESCVAL
e625 : 9005             [ 3] 	bcc df_rt_list_escval
                             	; normal char just print it
e627 : 2049c4           [ 6] 	jsr io_put_ch
e62a : 8008             [ 3] 	bra df_rt_list_nexttok
e62c :                       df_rt_list_escval
                             	; A and Y need to be valid on entry
e62c : 204be6           [ 6] 	jsr df_rt_list_decode_esc
e62f : 8003             [ 3] 	bra df_rt_list_nexttok
e631 :                       df_rt_list_token
e631 : 2032e7           [ 6] 	jsr df_rt_list_decode_token
e634 :                       df_rt_list_nexttok	
                             	; advance the line offset
e634 : e6d1             [ 5] 	inc df_exeoff
e636 : a5d1             [ 3] 	lda df_exeoff
AS65 Assembler for R6502 [1.42].                                     Page  149
-------------------------------- bank\bank1.s --------------------------------

                             	; check if at end of line
e638 : d2d4             [ 5] 	cmp (df_tmpptra)
e63a : f00e             [ 3] 	beq df_rt_list_line_only_fin
                             	; check if at end of statement
e63c : c5c8             [ 3] 	cmp df_nxtstidx
e63e : d0dd             [ 3] 	bne df_rt_list_decode
e640 : a8               [ 2] 	tay
                             	; save the next statement offset
e641 : b1d4             [ 5] 	lda (df_tmpptra),y
e643 : 85c8             [ 3] 	sta df_nxtstidx
e645 : c8               [ 2] 	iny
e646 : 84d1             [ 3] 	sty df_exeoff
e648 : 80d3             [ 3] 	bra df_rt_list_decode
e64a :                       df_rt_list_line_only_fin
e64a : 60               [ 6] 	rts
                             	
                             	
                             ; decode escape sequences
e64b :                       df_rt_list_decode_esc
                             	; jump over esc byte
e64b : c8               [ 2] 	iny
e64c : 84d1             [ 3] 	sty df_exeoff
                             	; get the next two bytes in case needed
e64e : 48               [ 3] 	pha
e64f : b1d4             [ 5] 	lda (df_tmpptra),y
e651 : 85d6             [ 3] 	sta df_tmpptrb
e653 : c8               [ 2] 	iny
e654 : b1d4             [ 5] 	lda (df_tmpptra),y
e656 : 85d7             [ 3] 	sta df_tmpptrb+1
e658 : 88               [ 2] 	dey
e659 : 68               [ 4] 	pla
                             	; x2 to get jmp offset
e65a : 0a               [ 2] 	asl a
e65b : aa               [ 2] 	tax
                             	; now jump to decoder
e65c : 7cccdc           [ 6] 	jmp (df_rt_escjmp,x)
                             
                             ; reserved
e65f :                       df_rt_lst_reserved
e65f : 60               [ 6] 	rts
                             
                             ; decode a byte char
e660 :                       df_rt_lst_chr
e660 : a927             [ 2] 	lda #0x27			; Single quote
e662 : 2049c4           [ 6] 	jsr io_put_ch
e665 : a5d6             [ 3] 	lda df_tmpptrb
e667 : 2049c4           [ 6] 	jsr io_put_ch
e66a : a927             [ 2] 	lda #0x27			; Single quote
e66c : 2049c4           [ 6] 	jsr io_put_ch
e66f : c8               [ 2] 	iny
e670 : 84d1             [ 3] 	sty df_exeoff
e672 : 60               [ 6] 	rts
                             
                             ; Output 0x for hex chars
e673 :                       df_rt_lst_hex_pre
e673 : a930             [ 2] 	lda #'0'
e675 : 2049c4           [ 6] 	jsr io_put_ch
e678 : a978             [ 2] 	lda #'x'
e67a : 4c49c4           [ 3] 	jmp io_put_ch
                             ;	rts
                             
                             ; Decode a byte hex	
AS65 Assembler for R6502 [1.42].                                     Page  150
-------------------------------- bank\bank1.s --------------------------------

e67d :                       df_rt_lst_bythex
e67d : 2073e6           [ 6] 	jsr df_rt_lst_hex_pre
e680 :                       df_rt_lst_lo_hex
e680 : a5d6             [ 3] 	lda df_tmpptrb
e682 : 2022c7           [ 6] 	jsr str_a_to_x
e685 : 2049c4           [ 6] 	jsr io_put_ch
e688 : 8a               [ 2] 	txa
e689 : 2049c4           [ 6] 	jsr io_put_ch
e68c : c8               [ 2] 	iny
e68d : 84d1             [ 3] 	sty df_exeoff
e68f : 60               [ 6] 	rts
                             
                             ; Decode an int hex
e690 :                       df_rt_lst_inthex
e690 : 2073e6           [ 6] 	jsr df_rt_lst_hex_pre
e693 : a5d7             [ 3] 	lda df_tmpptrb+1
e695 : 2022c7           [ 6] 	jsr str_a_to_x
e698 : 2049c4           [ 6] 	jsr io_put_ch
e69b : 8a               [ 2] 	txa
e69c : 2049c4           [ 6] 	jsr io_put_ch
e69f : 4c80e6           [ 3] 	jmp df_rt_lst_lo_hex
                             
                             ; Decode a byte binary
e6a2 :                       df_rt_lst_bytbin
e6a2 : a208             [ 2] 	ldx #8
e6a4 : a5d6             [ 3] 	lda df_tmpptrb
e6a6 : 85d7             [ 3] 	sta df_tmpptrb+1
e6a8 : 8005             [ 3] 	bra df_rt_lst_bin
                             
                             ; Decode a int binary
                             
e6aa :                       df_rt_lst_intbin
e6aa : a210             [ 2] 	ldx #16
e6ac : c8               [ 2] 	iny
e6ad : 84d1             [ 3] 	sty df_exeoff
                             
                             ; Main 01 decoding of binary
e6af :                       df_rt_lst_bin
e6af : a930             [ 2] 	lda #'0'
e6b1 : 2049c4           [ 6] 	jsr io_put_ch
e6b4 : a962             [ 2] 	lda #'b'
e6b6 : 2049c4           [ 6] 	jsr io_put_ch
e6b9 :                       df_rt_lst_bit
e6b9 : a930             [ 2] 	lda #'0'
e6bb : 06d6             [ 5] 	asl df_tmpptrb
e6bd : 26d7             [ 5] 	rol df_tmpptrb+1
e6bf : 9002             [ 3] 	bcc df_rt_lst_bit_skip0
e6c1 : a931             [ 2] 	lda #'1'
e6c3 :                       df_rt_lst_bit_skip0
e6c3 : 2049c4           [ 6] 	jsr io_put_ch
e6c6 : ca               [ 2] 	dex
e6c7 : d0f0             [ 3] 	bne df_rt_lst_bit
e6c9 : c8               [ 2] 	iny
e6ca : 84d1             [ 3] 	sty df_exeoff
                             ;	clc
e6cc : 60               [ 6] 	rts
                             	
                             ; Decode a decimal integer
e6cd :                       df_rt_lst_intdec	
e6cd : a6d6             [ 3] 	ldx df_tmpptrb
e6cf : a5d7             [ 3] 	lda df_tmpptrb+1
e6d1 : c8               [ 2] 	iny
AS65 Assembler for R6502 [1.42].                                     Page  151
-------------------------------- bank\bank1.s --------------------------------

e6d2 : 84d1             [ 3] 	sty df_exeoff
e6d4 : 18               [ 2] 	clc
e6d5 : 4c75c9           [ 3] 	jmp print_a_to_d
                             ;	rts
                             
                             ; decode a variable or procedure
e6d8 :                       df_rt_lst_var
e6d8 :                       df_rt_lst_proc
                             	; get var index
e6d8 : b1d4             [ 5] 	lda (df_tmpptra),y
e6da : aa               [ 2] 	tax
                             	_cpyZPWord df_vntstrt,df_tmpptrb
                             
e6e3 :                       df_rt_list_findvvt
e6e3 : e000             [ 2] 	cpx #0
e6e5 : f015             [ 3] 	beq df_rt_list_gotvvt
e6e7 :                       df_rt_list_vvtend
e6e7 : b2d6             [ 5] 	lda (df_tmpptrb)
e6e9 : f008             [ 3] 	beq df_rt_list_gotvvtend
                             	_incZPWord df_tmpptrb
                             
e6f1 : 80f4             [ 3] 	bra df_rt_list_vvtend
e6f3 :                       df_rt_list_gotvvtend
                             	_incZPWord df_tmpptrb
                             
e6f9 : ca               [ 2] 	dex
e6fa : 80e7             [ 3] 	bra df_rt_list_findvvt
e6fc :                       df_rt_list_gotvvt
e6fc : b2d6             [ 5] 	lda (df_tmpptrb)
e6fe : f00b             [ 4] 	beq df_rt_list_donvvt
e700 : 2049c4           [ 6] 	jsr io_put_ch
                             	_incZPWord df_tmpptrb
                             
e709 : 80f1             [ 4] 	bra df_rt_list_gotvvt
e70b :                       df_rt_list_donvvt
e70b : 60               [ 6] 	rts
                             
e70c :                       df_rt_lst_strlit
e70c : a922             [ 2] 	lda #0x22
e70e : 2049c4           [ 6] 	jsr io_put_ch
e711 : a4d1             [ 3] 	ldy df_exeoff
e713 :                       df_rt_lst_strlitch
e713 : b1d4             [ 5] 	lda (df_tmpptra),y
e715 : f006             [ 3] 	beq df_rt_lst_strlitdon
e717 : 2049c4           [ 6] 	jsr io_put_ch
e71a : c8               [ 2] 	iny
e71b : 80f6             [ 3] 	bra df_rt_lst_strlitch
e71d :                       df_rt_lst_strlitdon
e71d : a922             [ 2] 	lda #0x22
e71f : 2049c4           [ 6] 	jsr io_put_ch
e722 : 84d1             [ 3] 	sty df_exeoff
e724 : 60               [ 6] 	rts
                             
e725 :                       df_rt_list_linnum
e725 : a001             [ 2] 	ldy #1
e727 : b1d4             [ 5] 	lda (df_tmpptra),y
e729 : aa               [ 2] 	tax
e72a : a002             [ 2] 	ldy #2
e72c : b1d4             [ 5] 	lda (df_tmpptra),y
e72e : 18               [ 2] 	clc
e72f : 4c75c9           [ 3] 	jmp print_a_to_d
                             
AS65 Assembler for R6502 [1.42].                                     Page  152
-------------------------------- bank\bank1.s --------------------------------

                             ; decode a token value with MSB set
e732 :                       df_rt_list_decode_token
                             	; if not assembler then normal listing
e732 : c997             [ 2] 	cmp #DFRT_ASM
e734 : d003             [ 3] 	bne df_rt_list_decode_token_normal
e736 : 4c6ee7           [ 3] 	jmp df_rt_asm_decode_token
e739 :                       df_rt_list_decode_token_normal
e739 : 297f             [ 2] 	and #0x7f
                             	; token 0 and 1 don't get decoded they are impli
e73b : c902             [ 2] 	cmp #2
e73d : b001             [ 3] 	bcs df_rt_list_do_decode_tkn	
e73f : 60               [ 6] 	rts
e740 :                       df_rt_list_do_decode_tkn
e740 : aa               [ 2] 	tax
e741 : a92a             [ 2] 	lda #lo(df_tokensyms)
e743 : 85d6             [ 3] 	sta df_tmpptrb
e745 : a9d1             [ 2] 	lda #hi(df_tokensyms)
e747 : 85d7             [ 3] 	sta df_tmpptrb+1
e749 :                       df_rt_list_find_sym
e749 : e000             [ 2] 	cpx #0
e74b : f00f             [ 3] 	beq df_rt_list_got_sym
e74d :                       df_rt_list_next_ch
e74d : b2d6             [ 5] 	lda (df_tmpptrb)
e74f : 48               [ 3] 	pha
                             	_incZPWord df_tmpptrb
                             
e756 : 68               [ 4] 	pla
e757 : 10f4             [ 3] 	bpl df_rt_list_next_ch
e759 :                       df_rt_list_got_last_sym
                             	; ok got to the last ch
                             	; advance to next sym
e759 : ca               [ 2] 	dex
e75a : 80ed             [ 3] 	bra df_rt_list_find_sym
e75c :                       df_rt_list_got_sym
e75c : b2d6             [ 5] 	lda (df_tmpptrb)
e75e : 08               [ 3] 	php
e75f : 297f             [ 2] 	and #0x7f
e761 : 2049c4           [ 6] 	jsr io_put_ch
                             	_incZPWord df_tmpptrb
                             
e76a : 28               [ 4] 	plp
e76b : 10ef             [ 3] 	bpl df_rt_list_got_sym
e76d : 60               [ 6] 	rts 
                             
                             ;** Decode assembler token in A **
e76e :                       df_rt_asm_decode_token
e76e : a92e             [ 2] 	lda #'.'			;Always put out the . symbol
e770 : 2049c4           [ 6] 	jsr io_put_ch
e773 : a4d1             [ 3] 	ldy df_exeoff		;Print out any whitespace
e775 :                       df_rt_asm_decode_token_ws
e775 : c8               [ 2] 	iny					;Point to char after the asm token
e776 : b1d4             [ 5] 	lda (df_tmpptra),y	;What is the char?
e778 : 20e6cd           [ 6] 	jsr df_tk_isws		;If not then found the keyword
e77b : 9005             [ 3] 	bcc df_rt_asm_decode_token_found
e77d : 2049c4           [ 6] 	jsr io_put_ch		;Print the space
e780 : 80f3             [ 3] 	bra df_rt_asm_decode_token_ws
e782 :                       df_rt_asm_decode_token_found
e782 : c911             [ 2] 	cmp #DFTK_VAR		; If is a label variable?
e784 : d003             [ 3] 	bne df_rt_asm_decode_token_keyword
                             	; if so then process as normal escape handling
e786 : 4c4be6           [ 3] 	jmp df_rt_list_decode_esc
e789 :                       df_rt_asm_decode_token_keyword
AS65 Assembler for R6502 [1.42].                                     Page  153
-------------------------------- bank\bank1.s --------------------------------

e789 : 297f             [ 2] 	and #0x7f			; Mask off MSB
e78b : aa               [ 2] 	tax					;Put it in to X as the counter
                             	; Point to asm symbol table
e78c : a902             [ 2] 	lda #lo(df_asm_tokensyms)
e78e : 85d6             [ 3] 	sta df_tmpptrb
e790 : a9f6             [ 2] 	lda #hi(df_asm_tokensyms)
e792 : 85d7             [ 3] 	sta df_tmpptrb+1
e794 :                       df_rt_list_find_asm_sym
e794 : e000             [ 2] 	cpx #0
e796 : f01a             [ 3] 	beq df_rt_list_got_asm_sym
e798 :                       df_rt_list_next_asm_ch
                             	_incZPWord df_tmpptrb
                             
e79e : b2d6             [ 5] 	lda (df_tmpptrb)
e7a0 : c920             [ 2] 	cmp #' '			; Skip all chars >=' '
e7a2 : b0f4             [ 3] 	bcs df_rt_list_next_asm_ch
e7a4 : 38               [ 2] 	sec					; Skip offset and mode bytes
e7a5 : 65d6             [ 3] 	adc df_tmpptrb
e7a7 : 85d6             [ 3] 	sta df_tmpptrb
e7a9 : a5d7             [ 3] 	lda df_tmpptrb+1
e7ab : 6900             [ 2] 	adc #0
e7ad : 85d7             [ 3] 	sta df_tmpptrb+1
e7af : ca               [ 2] 	dex					; One less symbol to skip over
e7b0 : 80e2             [ 3] 	bra df_rt_list_find_asm_sym
e7b2 :                       df_rt_list_got_asm_sym
e7b2 : b2d6             [ 5] 	lda (df_tmpptrb)
e7b4 : c920             [ 2] 	cmp #' '
e7b6 : 900b             [ 3] 	bcc df_rt_asm_decode_token_done
e7b8 : 2049c4           [ 6] 	jsr io_put_ch
                             	_incZPWord df_tmpptrb
                             
e7c1 : 80ef             [ 3] 	bra df_rt_list_got_asm_sym
e7c3 :                       df_rt_asm_decode_token_done
e7c3 : 84d1             [ 3] 	sty df_exeoff		; Save offset
e7c5 : 60               [ 6] 	rts 
                             
                             
e7c6 :                       df_rt_doke
e7c6 : 2008da           [ 6] 	jsr df_rt_parm_2ints
e7c9 : a5d6             [ 3] 	lda df_tmpptrb
e7cb : 92d4             [ 5] 	sta (df_tmpptra)
                             	; get high byte to doke
e7cd : a5d7             [ 3] 	lda df_tmpptrb+1
e7cf : a001             [ 2] 	ldy #1
                             	; poke hi byte
e7d1 : 91d4             [ 5] 	sta (df_tmpptra),y
e7d3 : 60               [ 6] 	rts
                             	
e7d4 :                       df_rt_poke
e7d4 : 2008da           [ 6] 	jsr df_rt_parm_2ints
e7d7 : a5d6             [ 3] 	lda df_tmpptrb
e7d9 : 92d4             [ 5] 	sta (df_tmpptra)
                             ;	clc
e7db : 60               [ 6] 	rts
                             
e7dc :                       df_rt_vpoke
e7dc : 2008da           [ 6] 	jsr df_rt_parm_2ints
e7df : a6d4             [ 3] 	ldx df_tmpptra
e7e1 : a4d5             [ 3] 	ldy df_tmpptra+1
e7e3 : a5d6             [ 3] 	lda df_tmpptrb
e7e5 : 4cd6c3           [ 3] 	jmp _vdp_poke
                             ;	clc
AS65 Assembler for R6502 [1.42].                                     Page  154
-------------------------------- bank\bank1.s --------------------------------

                             ;	rts
                             
e7e8 :                       df_rt_setvdp
e7e8 : 2008da           [ 6] 	jsr df_rt_parm_2ints
e7eb : a5d4             [ 3] 	lda df_tmpptra
e7ed : a6d6             [ 3] 	ldx df_tmpptrb
e7ef : 4cd6c4           [ 3] 	jmp vdp_wr_reg
                             ;	clc
                             ;	rts
                             
e7f2 :                       df_rt_colour
e7f2 : 201fda           [ 6] 	jsr df_rt_parm_3ints
                             	; colour is a combination of b and c parms
e7f5 : a5d6             [ 3] 	lda df_tmpptrb
e7f7 : 0a               [ 2] 	asl a
e7f8 : 0a               [ 2] 	asl a
e7f9 : 0a               [ 2] 	asl a
e7fa : 0a               [ 2] 	asl a
e7fb : 05d8             [ 3] 	ora df_tmpptrc
e7fd : 48               [ 3] 	pha
e7fe : a5d4             [ 3] 	lda df_tmpptra
e800 : c920             [ 2] 	cmp #32					; 32 = border colour
e802 : f00e             [ 3] 	beq df_rt_colour_border
                             	; else write to the colour table
                             	; first calculate the colour table address
e804 : 18               [ 2] 	clc
e805 : 6516             [ 3] 	adc vdp_base+vdp_addr_col
e807 : aa               [ 2] 	tax
e808 : a517             [ 3] 	lda vdp_base+vdp_addr_col+1
e80a : 6900             [ 2] 	adc #0
e80c : a8               [ 2] 	tay
e80d : 68               [ 4] 	pla
                             	; A = colour, YX = address
e80e : 200ec5           [ 6] 	jsr vdp_poke
e811 : 60               [ 6] 	rts
e812 :                       df_rt_colour_border
e812 : a907             [ 2] 	lda #7
e814 : fa               [ 4] 	plx
e815 : 4cd6c4           [ 3] 	jmp vdp_wr_reg
                             
e818 :                       df_rt_sprite
e818 : 2071da           [ 6] 	jsr df_rt_parm_5ints
                             	; calculate the sprite number in vram
e81b : a5d4             [ 3] 	lda df_tmpptra
e81d : 0a               [ 2] 	asl a
e81e : 0a               [ 2] 	asl a
e81f : 18               [ 2] 	clc
e820 : 651a             [ 3] 	adc vdp_base+vdp_addr_spa
e822 : aa               [ 2] 	tax
e823 : a51b             [ 3] 	lda vdp_base+vdp_addr_spa+1
e825 : 6900             [ 2] 	adc #0
e827 : 78               [ 2] 	sei				; Disable interrupts
e828 : 20e3c4           [ 6] 	jsr vdp_wr_addr
                             	; now write the vertical position (tmpc, not b)
e82b : a5d8             [ 3] 	lda df_tmpptrc
e82d : 2009c5           [ 6] 	jsr vdp_wr_vram
                             	; now write the horizontal position (tmpb)
e830 : a5d6             [ 3] 	lda df_tmpptrb
e832 : 2009c5           [ 6] 	jsr vdp_wr_vram
                             	; now write the pattern name (tmpd)
e835 : a5da             [ 3] 	lda df_tmpptrd
e837 : 2009c5           [ 6] 	jsr vdp_wr_vram
AS65 Assembler for R6502 [1.42].                                     Page  155
-------------------------------- bank\bank1.s --------------------------------

                             	; now write the colour / ec byte (tmpe)
e83a : a5dc             [ 3] 	lda df_tmpptre
e83c : 2009c5           [ 6] 	jsr vdp_wr_vram
e83f : 58               [ 2] 	cli				; Enable interrupts
e840 : 60               [ 6] 	rts
                             
                             
                             ; copy pattern array to sprite pattern vram
                             ; pattern array is a mim 4 element int
e841 :                       df_rt_spritepat
e841 : 2008da           [ 6] 	jsr df_rt_parm_2ints
                             	; save sprite number
e844 : 86d4             [ 3] 	stx df_tmpptra
e846 : 64d5             [ 3] 	stz df_tmpptra+1
                             	; multiply by 8 to get pattern offset
e848 : 06d4             [ 5] 	asl df_tmpptra
e84a : 26d5             [ 5] 	rol df_tmpptra+1
e84c : 06d4             [ 5] 	asl df_tmpptra
e84e : 26d5             [ 5] 	rol df_tmpptra+1
e850 : 06d4             [ 5] 	asl df_tmpptra
e852 : 26d5             [ 5] 	rol df_tmpptra+1
                             	; add offset to sprite pattern base
                             	; and put in X,A
e854 : a5d4             [ 3] 	lda df_tmpptra
e856 : 651c             [ 3] 	adc vdp_base+vdp_addr_spp
e858 : aa               [ 2] 	tax
e859 : a5d5             [ 3] 	lda df_tmpptra+1
e85b : 651d             [ 3] 	adc vdp_base+vdp_addr_spp+1
e85d : 78               [ 2] 	sei			; Disable interrupts
                             	; set vdp address
e85e : 20e3c4           [ 6] 	jsr vdp_wr_addr
                             	; start from beginning of array
e861 : a000             [ 2] 	ldy #0
e863 :                       df_rt_spritepat_line
                             	; get the sprite patten from array
e863 : b1d6             [ 5] 	lda (df_tmpptrb),y
                             	; and write to vdp
e865 : 2009c5           [ 6] 	jsr vdp_wr_vram
e868 : c8               [ 2] 	iny
                             	; do this for 8 bytes (4 elements)
e869 : c008             [ 2] 	cpy #8
e86b : d0f6             [ 3] 	bne df_rt_spritepat_line
e86d : 58               [ 2] 	cli			; Enable interrupts
e86e : 60               [ 6] 	rts
                             
e86f :                       df_rt_spritepos
e86f : 201fda           [ 6] 	jsr df_rt_parm_3ints
                             	; calculate the sprite number in vram
e872 : a5d4             [ 3] 	lda df_tmpptra
e874 : 0a               [ 2] 	asl a
e875 : 0a               [ 2] 	asl a
e876 : 651a             [ 3] 	adc vdp_base+vdp_addr_spa
e878 : aa               [ 2] 	tax
e879 : a51b             [ 3] 	lda vdp_base+vdp_addr_spa+1
e87b : 6900             [ 2] 	adc #0
e87d : 78               [ 2] 	sei
e87e : 20e3c4           [ 6] 	jsr vdp_wr_addr
                             	; now write the vertical position (tmpc, not b)
e881 : a5d8             [ 3] 	lda df_tmpptrc
e883 : 2009c5           [ 6] 	jsr vdp_wr_vram
                             	; now write the horizontal position (tmpb)
e886 : a5d6             [ 3] 	lda df_tmpptrb
AS65 Assembler for R6502 [1.42].                                     Page  156
-------------------------------- bank\bank1.s --------------------------------

e888 : 2009c5           [ 6] 	jsr vdp_wr_vram
e88b : 58               [ 2] 	cli
e88c : 60               [ 6] 	rts
                             
                             ; common routine for col and nme variations
                             ; A contains offset in to sprite table to update
e88d :                       df_rt_spriteattr
                             	; save A which contains the offset
e88d : 48               [ 3] 	pha
e88e : 2008da           [ 6] 	jsr df_rt_parm_2ints
                             	; calculate the sprite number in vram
e891 : a5d4             [ 3] 	lda df_tmpptra
e893 : 0a               [ 2] 	asl a
e894 : 0a               [ 2] 	asl a
e895 : 651a             [ 3] 	adc vdp_base+vdp_addr_spa
e897 : 85d4             [ 3] 	sta df_tmpptra
e899 : a51b             [ 3] 	lda vdp_base+vdp_addr_spa+1
e89b : 6900             [ 2] 	adc #0
e89d : 85d5             [ 3] 	sta df_tmpptra+1
                             	; add offset and put in X,A to set VRAM address
e89f : 68               [ 4] 	pla							; get offset from stack
e8a0 : 65d4             [ 3] 	adc df_tmpptra
e8a2 : aa               [ 2] 	tax
e8a3 : a5d5             [ 3] 	lda df_tmpptra+1
e8a5 : 6900             [ 2] 	adc #0
e8a7 : a8               [ 2] 	tay
e8a8 : a5d6             [ 3] 	lda df_tmpptrb
e8aa : 4c0ec5           [ 3] 	jmp vdp_poke
                             
e8ad :                       df_rt_spritecol
                             	; offset is 3 for colour byte
e8ad : a903             [ 2] 	lda #3
e8af : 4c8de8           [ 3] 	jmp df_rt_spriteattr
                             
e8b2 :                       df_rt_spritenme
                             	; offset is 2 for name byte
e8b2 : a902             [ 2] 	lda #2
e8b4 : 4c8de8           [ 3] 	jmp df_rt_spriteattr
                             
e8b7 :                       df_rt_snd_common
                             	; 3 inputs
                             	; tmpa = channel (1,2,3), tmpb = period, tmpc = 
e8b7 : a5d4             [ 3] 	lda df_tmpptra
                             	; tone channel addressing is 0 to 2
e8b9 : 3a               [ 2] 	dec a
e8ba : 2903             [ 2] 	and #3
                             	; ok doing a tone channel, get reg index for per
e8bc : 0a               [ 2] 	asl a
e8bd : aa               [ 2] 	tax
                             	; get low byte of period
e8be : a4d6             [ 3] 	ldy df_tmpptrb
e8c0 : 20a6c3           [ 6] 	jsr _snd_set
                             	; increment reg number to high byte
e8c3 : e8               [ 2] 	inx
                             	; get high byte of period
e8c4 : a5d7             [ 3] 	lda df_tmpptrb+1
e8c6 : 290f             [ 2] 	and #0x0f
e8c8 : a8               [ 2] 	tay
                             	; set period
e8c9 : 20a6c3           [ 6] 	jsr _snd_set
                             	; get volume register index (8 = channel 1)
e8cc : 18               [ 2] 	clc
AS65 Assembler for R6502 [1.42].                                     Page  157
-------------------------------- bank\bank1.s --------------------------------

e8cd : a5d4             [ 3] 	lda df_tmpptra
e8cf : 2903             [ 2] 	and #3
e8d1 : 6907             [ 2] 	adc #7
e8d3 : aa               [ 2] 	tax
                             	; get volume
e8d4 : a5d8             [ 3] 	lda df_tmpptrc
e8d6 : 290f             [ 2] 	and #0x0f
e8d8 : d002             [ 3] 	bne df_rt_sound_env_skip
                             	; envelope mode
e8da : 0910             [ 2] 	ora #0x10
e8dc :                       df_rt_sound_env_skip
e8dc : a8               [ 2] 	tay
e8dd : 4ca6c3           [ 3] 	jmp _snd_set
                             ;	rts
                             
                             ; sound chan,period,volume	
e8e0 :                       df_rt_sound
e8e0 : 201fda           [ 6] 	jsr df_rt_parm_3ints
e8e3 :                       df_rt_dosound
                             	; check which channel (0 = noise)
e8e3 : a5d4             [ 3] 	lda df_tmpptra
e8e5 : f003             [ 3] 	beq df_rt_sound_noise
e8e7 : 4cb7e8           [ 3] 	jmp df_rt_snd_common
e8ea :                       df_rt_sound_noise
                             	; ok update the noise channel, volume is irrelev
e8ea : a206             [ 2] 	ldx #6
e8ec : a5d6             [ 3] 	lda df_tmpptrb
e8ee : 291f             [ 2] 	and #0x1f
e8f0 : a8               [ 2] 	tay
e8f1 : 4ca6c3           [ 3] 	jmp _snd_set
                             ;	clc
                             ;	rts
                             
                             ; music chan,octave,note,volume
e8f4 :                       df_rt_music
e8f4 : 2042da           [ 6] 	jsr df_rt_parm_4ints
                             	; parm 2 = octave, need to x 12word = 24
e8f7 : 18               [ 2] 	clc
e8f8 : a5d6             [ 3] 	lda df_tmpptrb
e8fa : 65d6             [ 3] 	adc df_tmpptrb
e8fc : 65d6             [ 3] 	adc df_tmpptrb
e8fe : 0a               [ 2] 	asl a
e8ff : 0a               [ 2] 	asl a
                             	; we have x12, now add note to get index
e900 : 65d8             [ 3] 	adc df_tmpptrc
e902 : 0a               [ 2] 	asl a
e903 : a8               [ 2] 	tay
                             	; get period A,X (hi/lo)
e904 : 2076c3           [ 6] 	jsr _snd_get_note
e907 : 86d6             [ 3] 	stx df_tmpptrb
e909 : 85d7             [ 3] 	sta df_tmpptrb+1
                             	; put vol in tmpc
e90b : a5da             [ 3] 	lda df_tmpptrd
e90d : 85d8             [ 3] 	sta df_tmpptrc
                             	; tmpa,b,c contain chan,per,vol
e90f : 4ce3e8           [ 3] 	jmp df_rt_dosound
                             	
                             	
                             ; play tonemask,noisemask,envelope,period
e912 :                       df_rt_play
e912 : 2042da           [ 6] 	jsr df_rt_parm_4ints
                             	; parm 1 = tone enable
AS65 Assembler for R6502 [1.42].                                     Page  158
-------------------------------- bank\bank1.s --------------------------------

e915 : a5d4             [ 3] 	lda df_tmpptra
e917 : 2907             [ 2] 	and #7
e919 : 85d4             [ 3] 	sta df_tmpptra
                             	; parm 2 = noise enable
e91b : a5d6             [ 3] 	lda df_tmpptrb
e91d : 2907             [ 2] 	and #7
e91f : 0a               [ 2] 	asl a
e920 : 0a               [ 2] 	asl a
e921 : 0a               [ 2] 	asl a
e922 : 05d4             [ 3] 	ora df_tmpptra
                             	; we now have bits set for channels to enable
                             	; but need to invert for the 8910
                             	; keep top 2 bits 0 as these are port a and b in
e924 : 493f             [ 2] 	eor #0x3f
e926 : a8               [ 2] 	tay
                             	; reg 7 is control register
e927 : a207             [ 2] 	ldx #7
e929 : 20a6c3           [ 6] 	jsr _snd_set
                             	; parm 3 = envelope mode
e92c : a5d8             [ 3] 	lda df_tmpptrc
e92e : 290f             [ 2] 	and #0xf
e930 : a8               [ 2] 	tay
                             	; 13 is envelope shape register
e931 : a20d             [ 2] 	ldx #13
e933 : 20a6c3           [ 6] 	jsr _snd_set
                             	; parm 4 = envelope period
                             	; 11 is envelope period register
e936 : a20b             [ 2] 	ldx #11
                             	; get low
e938 : a4da             [ 3] 	ldy df_tmpptrd
e93a : 20a6c3           [ 6] 	jsr _snd_set
                             	; get high
e93d : e8               [ 2] 	inx
e93e : a4db             [ 3] 	ldy df_tmpptrd+1
e940 : 4ca6c3           [ 3] 	jmp _snd_set
                             ;	clc
                             ;	rts
                             
                             
                             ;* Binary save mem,hdr,addr,len,filename
e943 :                       df_rt_bsave
                             	; Get mem type, 0=RAM, else VRAM
e943 : 2061d7           [ 6] 	jsr df_rt_neval				; Get mem type
e946 : 2073ef           [ 6] 	jsr df_st_popInt			; X,A = mem type (only X)
                             	; if check X for v or r
e949 : e076             [ 2] 	cpx #'v'
e94b : d003             [ 3] 	bne df_rt_bsave_tryr
e94d : 18               [ 2] 	clc							; Clear C for vram
e94e : 8007             [ 3] 	bra df_rt_bsave_savep
e950 :                       df_rt_bsave_tryr
e950 : e072             [ 2] 	cpx #'r'
e952 : f002             [ 3] 	beq	 df_rt_bsave_setR
                             	SWBRK DFERR_TYPEMISM		; was not v or r!
                             
e956 :                       df_rt_bsave_setR
e956 : 38               [ 2] 	sec							; Set C for ram
e957 :                       df_rt_bsave_savep
                             	; save C, clear=VRAM, set=RAM
e957 : 08               [ 3] 	php
                             
                             	; jump over comma
e958 : e6d1             [ 5] 	inc df_exeoff
AS65 Assembler for R6502 [1.42].                                     Page  159
-------------------------------- bank\bank1.s --------------------------------

                             	; Get header length
e95a : 2061d7           [ 6] 	jsr df_rt_neval				; Get header length
e95d : 2073ef           [ 6] 	jsr df_st_popInt			; X,A = Header length (only X
                             	; save X as header length
e960 : da               [ 3] 	phx
                             
                             	; jump over comma
e961 : e6d1             [ 5] 	inc df_exeoff
e963 : 2061d7           [ 6] 	jsr df_rt_neval				; Get address
e966 : 2073ef           [ 6] 	jsr df_st_popInt			; X,A = Address
e969 : 48               [ 3] 	pha
e96a : da               [ 3] 	phx
                             
                             	; jump over comma
e96b : e6d1             [ 5] 	inc df_exeoff
e96d : 2061d7           [ 6] 	jsr df_rt_neval				; Get length
e970 : 2073ef           [ 6] 	jsr df_st_popInt			; X,A = Length
e973 : 48               [ 3] 	pha
e974 : da               [ 3] 	phx
                             
                             	; jump over comma
e975 : e6d1             [ 5] 	inc df_exeoff
                             	; Process filename
e977 : 20f8e9           [ 6] 	jsr df_rt_parse_file
e97a : 204fc4           [ 6] 	jsr io_open_write
e97d : b05a             [ 3] 	bcs df_rt_file_errc3		; Error condition resets t
                             
                             	; On the stack, we have lenlo,lenhi,adlo,adhi,he
e97f : ba               [ 2] 	tsx
e980 : bc0501           [ 4] 	ldy 0x105,x					; Get header len
e983 : f008             [ 3] 	beq df_rt_bsave_byte
e985 : a900             [ 2] 	lda #0						; Zero filler
e987 :                       df_rt_bsave_header
e987 : 2049c4           [ 6] 	jsr io_put_ch				; Write a byte to disk
e98a : 88               [ 2] 	dey
e98b : d0fa             [ 3] 	bne df_rt_bsave_header
e98d :                       df_rt_bsave_byte
e98d : ba               [ 2] 	tsx							; Restore SP to X
e98e : bd0101           [ 4] 	lda 0x101,x					; low<>0 carry on
e991 : d005             [ 3] 	bne df_rt_bsave_byte_do
e993 : bd0201           [ 4] 	lda 0x102,x					; hi<>0 carry on
e996 : f038             [ 3] 	beq df_rt_bsave_done		; else done
e998 :                       df_rt_bsave_byte_do
e998 : bd0601           [ 4] 	lda 0x106,x					; Get the C status
e99b : 48               [ 3] 	pha
e99c : 28               [ 4] 	plp							; C unaffected by next ops
                             	
e99d : bd0301           [ 4] 	lda 0x103,x					; Get low address
e9a0 : bc0401           [ 4] 	ldy 0x104,x					; Get high address
e9a3 : aa               [ 2] 	tax							; X,Y contain address
                             
e9a4 : b006             [ 3] 	bcs df_rt_bsave_ram			; RAM or VRAM?
                             	; Read from VRAM
e9a6 : 98               [ 2] 	tya							; A needs to contain high byte
e9a7 : 20bec3           [ 6] 	jsr _vdp_peek				; Peek VRAM
e9aa : 8006             [ 3] 	bra df_rt_bsave_write
e9ac :                       df_rt_bsave_ram
                             	; Read from RAM
e9ac : 86d4             [ 3] 	stx df_tmpptra				; Save address
e9ae : 84d5             [ 3] 	sty df_tmpptra+1
e9b0 : b2d4             [ 5] 	lda (df_tmpptra)			; Peek RAM
e9b2 :                       df_rt_bsave_write
AS65 Assembler for R6502 [1.42].                                     Page  160
-------------------------------- bank\bank1.s --------------------------------

e9b2 : 2049c4           [ 6] 	jsr io_put_ch				; Write to disk
e9b5 : ba               [ 2] 	tsx							; Get SP to X
e9b6 : fe0301           [ 6] 	inc 0x103,x					; Increment low address
e9b9 : d003             [ 3] 	bne df_rt_bsave_skiph
e9bb : fe0401           [ 6] 	inc 0x104,x					; Increment high address
e9be :                       df_rt_bsave_skiph
e9be : bc0101           [ 4] 	ldy 0x101,x					; Get low len byte
e9c1 : f005             [ 3] 	beq df_rt_bsave_dech
e9c3 : de0101           [ 6] 	dec 0x101,x					; A simple decrement
e9c6 : 80c5             [ 3] 	bra df_rt_bsave_byte		; Process next byte
e9c8 :                       df_rt_bsave_dech
e9c8 : de0101           [ 6] 	dec 0x101,x					; Decrement low in readiness
e9cb : de0201           [ 6] 	dec 0x102,x					; Decrement high
e9ce : 80bd             [ 3] 	bra df_rt_bsave_byte		; Process next byte
e9d0 :                       df_rt_bsave_done
                             	; Tidy the stack
e9d0 : 68               [ 4] 	pla
e9d1 : 68               [ 4] 	pla
e9d2 : 68               [ 4] 	pla
e9d3 : 68               [ 4] 	pla
e9d4 : 68               [ 4] 	pla
e9d5 : 68               [ 4] 	pla
e9d6 : 4c17ea           [ 3] 	jmp df_rt_file_cleanup		; Clean up FS
                             
e9d9 :                       df_rt_file_errc3				; Stepping stone!!!
e9d9 : b0fe             [ 3] 	bcs df_rt_file_errc3
                             
                             ;* common filename procesing routine
                             ;* 
e9db :                       df_rt_init_filename
                             	; evaluate string
e9db : 2061d7           [ 6] 	jsr df_rt_neval
e9de : 2078ef           [ 6] 	jsr df_st_popStr
                             
                             	; save string address
e9e1 : 86d6             [ 3] 	stx df_tmpptrb
e9e3 : 85d7             [ 3] 	sta df_tmpptrb+1
                             	
                             	; copy string to fhandle
e9e5 : a000             [ 2] 	ldy #0
e9e7 :                       df_rt_copy_fn
e9e7 : b1d6             [ 5] 	lda (df_tmpptrb),y
e9e9 : 8940             [ 2] 	bit #0x40					; If 0x40 bit not set
e9eb : f002             [ 3] 	beq df_rt_fname_case		; then not an alpha char
e9ed : 29df             [ 2] 	and #0xdf					; Else mask out 0x20 bit to make u
e9ef :                       df_rt_fname_case	
e9ef : 996600           [ 5] 	sta fh_handle,y
e9f2 : c8               [ 2] 	iny
e9f3 : c900             [ 2] 	cmp #0
e9f5 : d0f0             [ 3] 	bne df_rt_copy_fn
e9f7 : 60               [ 6] 	rts
                             	
                             ;* common file parsing routine
e9f8 :                       df_rt_parse_file
                             	; now process filename
e9f8 : 20dbe9           [ 6] 	jsr df_rt_init_filename
e9fb : a902             [ 2] 	lda #2					; Only works for SD card now
e9fd : 2022c4           [ 6] 	jsr io_active_device
                             ;	clc
ea00 : 60               [ 6] 	rts
ea01 :                       df_rt_file_errc
                             	SWBRK DFERR_FNAME
AS65 Assembler for R6502 [1.42].                                     Page  161
-------------------------------- bank\bank1.s --------------------------------

                             
                             ; save "file"
ea03 :                       df_rt_save
ea03 : 20f8e9           [ 6] 	jsr df_rt_parse_file
ea06 : 204fc4           [ 6] 	jsr io_open_write
ea09 : b0f6             [ 3] 	bcs df_rt_file_errc
                             	; ok now have redirected output to device
                             	; go and list the program in save mode
ea0b : a901             [ 2] 	lda #1
ea0d : 85dc             [ 3] 	sta df_tmpptre
ea0f : 20bae5           [ 6] 	jsr df_rt_listprg
                             	; final CR to end the save
ea12 : a90d             [ 2] 	lda #UTF_CR
ea14 : 2049c4           [ 6] 	jsr io_put_ch
ea17 :                       df_rt_file_cleanup
                             	; close the file
ea17 : 2052c4           [ 6] 	jsr io_close
ea1a : 18               [ 2] 	clc
                             	; restore to default device io
ea1b : 4c1fc4           [ 3] 	jmp io_set_default
                             ;	clc
                             ;	rts
                             
                             ; load 'x',"file" where 0=serial, 1=SDCard
ea1e :                       df_rt_load
ea1e : 20f8e9           [ 6] 	jsr df_rt_parse_file
ea21 : 204cc4           [ 6] 	jsr io_open_read
ea24 :                       df_rt_file_errc2		; Used as a stepping stone furt
ea24 : b0db             [ 3] 	bcs df_rt_file_errc
                             	; no echo - very important
                             	; else might try and write to a device
                             	; only open for reading (i.e. SD CARD)
ea26 :                       df_rt_loadline
ea26 : 18               [ 2] 	clc
ea27 : 2061d6           [ 6] 	jsr df_pg_inputline
                             	; if C clear then tokenise line
ea2a : 9011             [ 3] 	bcc df_rt_ldtokenise
                             	; else done
                             	; clear dflat runtime else will try to execute
                             	; the last tokenised line!
ea2c : 9c8009           [ 4] 	stz df_tokbuff			; Offset to next line
ea2f : 9c8109           [ 4] 	stz df_tokbuff+1		; Clear line low
ea32 : 9c8209           [ 4] 	stz df_tokbuff+2		; Clear line high
ea35 : 64c8             [ 3] 	stz df_nxtstidx			; Clear next statement
ea37 : a901             [ 2] 	lda #1					; Set immediate mode
ea39 : 85a7             [ 3] 	sta df_immed
ea3b : 80da             [ 3] 	bra df_rt_file_cleanup	; Ok now can close and do
ea3d :                       df_rt_ldtokenise
ea3d : 20b5d6           [ 6] 	jsr df_pg_tokenise		; Tokenise loaded string
ea40 : 80e4             [ 3] 	bra df_rt_loadline		; Continue with next until b
                             
ea42 :                       df_rt_del
ea42 : 20dbe9           [ 6] 	jsr df_rt_init_filename		; Parse filename
ea45 : 2076c0           [ 6] 	jsr _fs_delete				; Delete file
ea48 : 60               [ 6] 	rts
                             
ea49 :                       df_rt_chdir
ea49 : 20dbe9           [ 6] 	jsr df_rt_init_filename		; Parse filename
ea4c : 205ec0           [ 6] 	jsr _fs_chdir				; Try and change directory
ea4f : b0b0             [ 3] 	bcs df_rt_file_errc
ea51 : 60               [ 6] 	rts
                             
AS65 Assembler for R6502 [1.42].                                     Page  162
-------------------------------- bank\bank1.s --------------------------------

                             ; bload MEM,HEAD,ADDR,FNAME
ea52 :                       df_rt_bload
                             	; Get mem type, 0=RAM, else VRAM
ea52 : 2061d7           [ 6] 	jsr df_rt_neval				; Get mem type
ea55 : 2073ef           [ 6] 	jsr df_st_popInt			; X,A = mem type (only X)
                             	; if check X for v or r
ea58 : e076             [ 2] 	cpx #'v'
ea5a : d003             [ 3] 	bne df_rt_bload_tryr
ea5c : 18               [ 2] 	clc							; Clear C for vram
ea5d : 8007             [ 3] 	bra df_rt_bload_savep
ea5f :                       df_rt_bload_tryr
ea5f : e072             [ 2] 	cpx #'r'
ea61 : f002             [ 3] 	beq	 df_rt_bload_setR
                             	SWBRK DFERR_TYPEMISM		; was not v or r!
                             
ea65 :                       df_rt_bload_setR
ea65 : 38               [ 2] 	sec							; Set C for ram
ea66 :                       df_rt_bload_savep
                             	; save C, clear=VRAM, set=RAM
ea66 : 08               [ 3] 	php
                             	; jump over comma
ea67 : e6d1             [ 5] 	inc df_exeoff
                             	; Get header length
ea69 : 2061d7           [ 6] 	jsr df_rt_neval				; Get header length
ea6c : 2073ef           [ 6] 	jsr df_st_popInt			; X,A = Header length (only X
                             	; save X as header length
ea6f : da               [ 3] 	phx
                             	; jump over comma
ea70 : e6d1             [ 5] 	inc df_exeoff
ea72 : 8005             [ 3] 	bra df_rt_bvload
ea74 :                       df_rt_vload
ea74 : 18               [ 2] 	clc							; Hardcode for VRAM
ea75 : 08               [ 3] 	php
ea76 : a207             [ 2] 	ldx #7						; Hardcode header length
ea78 : da               [ 3] 	phx
ea79 :                       df_rt_bvload
ea79 : 2061d7           [ 6] 	jsr df_rt_neval				; Get address
ea7c : 2073ef           [ 6] 	jsr df_st_popInt			; X,A = Address
ea7f : 48               [ 3] 	pha
ea80 : da               [ 3] 	phx
                             	; jump over comma
ea81 : e6d1             [ 5] 	inc df_exeoff
ea83 : 20f8e9           [ 6] 	jsr df_rt_parse_file
ea86 : 204cc4           [ 6] 	jsr io_open_read
ea89 : b099             [ 3] 	bcs df_rt_file_errc2		; Error condition resets t
                             	; On the stack, we have adlo,adhi,head,mem
ea8b : ba               [ 2] 	tsx
ea8c : bc0301           [ 4] 	ldy 0x103,x					; Get header
ea8f : f008             [ 3] 	beq df_rt_vload_byte
ea91 :                       df_rt_vload_header
ea91 : 2046c4           [ 6] 	jsr io_get_ch				; Get a character
ea94 : b032             [ 3] 	bcs df_rt_vload_done		; If EOF then done
ea96 : 88               [ 2] 	dey
ea97 : d0f8             [ 3] 	bne df_rt_vload_header
ea99 :                       df_rt_vload_byte
ea99 : ba               [ 2] 	tsx							; Restore SP to X
ea9a : bd0401           [ 4] 	lda 0x104,x					; Get the C status
ea9d : 48               [ 3] 	pha
ea9e : 28               [ 4] 	plp							; C unaffected by next ops
                             	
ea9f : bd0101           [ 4] 	lda 0x101,x					; Get low address
eaa2 : bc0201           [ 4] 	ldy 0x102,x					; Get high address
AS65 Assembler for R6502 [1.42].                                     Page  163
-------------------------------- bank\bank1.s --------------------------------

eaa5 : aa               [ 2] 	tax							; X,Y contain address
                             
eaa6 : b00a             [ 3] 	bcs df_rt_vload_ram			; RAM or VRAM?
                             	; Poke to VRAM
eaa8 : 2046c4           [ 6] 	jsr io_get_ch				; Get a character
eaab : b01b             [ 3] 	bcs df_rt_vload_done		; If EOF then done
eaad : 20d6c3           [ 6] 	jsr _vdp_poke				; Write to VRAM
eab0 : 800b             [ 3] 	bra df_rt_vload_next
eab2 :                       df_rt_vload_ram
                             	; Poke to RAM
eab2 : 2046c4           [ 6] 	jsr io_get_ch				; Get a character
eab5 : b011             [ 3] 	bcs df_rt_vload_done		; If EOF then done
eab7 : 86d4             [ 3] 	stx df_tmpptra				; Save address
eab9 : 84d5             [ 3] 	sty df_tmpptra+1
eabb : 92d4             [ 5] 	sta (df_tmpptra)			; Poke byte to RAM
eabd :                       df_rt_vload_next
eabd : ba               [ 2] 	tsx							; Get SP to X
eabe : fe0101           [ 6] 	inc 0x101,x					; Increment low address
eac1 : d003             [ 3] 	bne df_rt_vload_byte_skip
eac3 : fe0201           [ 6] 	inc 0x102,x					; Increment high address
eac6 :                       df_rt_vload_byte_skip
eac6 : 80d1             [ 3] 	bra df_rt_vload_byte		; Back for next video byte
eac8 :                       df_rt_vload_done
                             	; Tidy the stack
eac8 : 68               [ 4] 	pla
eac9 : 68               [ 4] 	pla
eaca : 68               [ 4] 	pla
eacb : 68               [ 4] 	pla
eacc : 4c17ea           [ 3] 	jmp df_rt_file_cleanup
                             
eacf :                       df_rt_dir_string				; Name of a directory
eacf : 3c4449523e202000      	db "<DIR>  ",0				; 7 chars + terminator
ead7 :                       df_rt_dir
ead7 : 206ec2           [ 6] 	jsr _fs_dir_root_start		; Start at root
eada : a216             [ 2] 	ldx #22						; Count of how many files before pa
eadc : da               [ 3] 	phx
eadd :                       df_rt_dir_show_entry
eadd : 18               [ 2] 	clc							; Only looking for valid files
eade : 2056c2           [ 6] 	jsr _fs_dir_find_entry		; Find a valid entry
eae1 : b049             [ 4] 	bcs df_rt_dir_done			; If C then no more entries
eae3 : a291             [ 2] 	ldx #lo(fh_dir)				; Set up pointer to name
eae5 : a90b             [ 2] 	lda #hi(fh_dir)
eae7 : 2091c4           [ 6] 	jsr io_print_line			; Print name
eaea : a920             [ 2] 	lda #' '					; print spaces
eaec :                       df_rt_dir_pad
eaec : 2049c4           [ 6] 	jsr io_put_ch
eaef : c8               [ 2] 	iny							; pad to 13 chars
eaf0 : c00d             [ 2] 	cpy #13
eaf2 : d0f8             [ 3] 	bne df_rt_dir_pad
eaf4 : ada20b           [ 4] 	lda fh_dir+FH_Attr			; Is it a directory?
eaf7 : 2910             [ 2] 	and #0x10					; Bit 4 set?
eaf9 : f009             [ 4] 	beq df_rt_dir_size
eafb : a2cf             [ 2] 	ldx #lo(df_rt_dir_string)	; Set up pointer to na
eafd : a9ea             [ 2] 	lda #hi(df_rt_dir_string)
eaff : 2091c4           [ 6] 	jsr io_print_line			; Print directory indicator
eb02 : 8014             [ 3] 	bra df_rt_dir_line
eb04 :                       df_rt_dir_size
eb04 : ae9e0b           [ 4] 	ldx fh_dir+FH_Size			; Low byte of size
eb07 : ad9f0b           [ 4] 	lda fh_dir+FH_Size+1		; High byte of size
eb0a : 18               [ 2] 	clc							; Don't show leading zeros
eb0b : 2075c9           [ 6] 	jsr print_a_to_d			; Print a string Y=chars
eb0e : a920             [ 2] 	lda #' '
AS65 Assembler for R6502 [1.42].                                     Page  164
-------------------------------- bank\bank1.s --------------------------------

eb10 :                       df_rt_dir_padsz					; Pad to 7 digits
eb10 : 2049c4           [ 6] 	jsr io_put_ch
eb13 : c8               [ 2] 	iny
eb14 : c007             [ 2] 	cpy #7
eb16 : d0f8             [ 3] 	bne df_rt_dir_padsz
                             	; Printed exactly 20 chars per size
eb18 :                       df_rt_dir_line
eb18 : fa               [ 4] 	plx							; Decrement file line counter
eb19 : ca               [ 2] 	dex
eb1a : d00d             [ 3] 	bne df_rt_dir_skip_pause
eb1c : a233             [ 2] 	ldx #lo(df_rt_pausemsg)		; Show pause message
eb1e : a9eb             [ 2] 	lda #hi(df_rt_pausemsg)
eb20 : 2091c4           [ 6] 	jsr io_print_line
eb23 : 38               [ 2] 	sec
eb24 : 2046c4           [ 6] 	jsr io_get_ch				; Wait for any key
eb27 : a216             [ 2] 	ldx #22						; Reset line counter
eb29 :                       df_rt_dir_skip_pause	
eb29 : da               [ 3] 	phx							; Save line counter
eb2a : 80b1             [ 4] 	bra df_rt_dir_show_entry	; Find another entry
eb2c :                       df_rt_dir_done
eb2c : fa               [ 4] 	plx							; Pop line counter
eb2d : a90d             [ 2] 	lda #UTF_CR					; Final CR
eb2f : 2049c4           [ 6] 	jsr io_put_ch
eb32 : 60               [ 6] 	rts
eb33 :                       df_rt_pausemsg
eb33 : 50726573732061..      	db "Press any key for more..",UTF_CR,0
                             	
                             ; reset %var
eb4d :                       df_rt_reset
                             	; now get lvar X,A from current statement
eb4d : 20d2db           [ 6] 	jsr df_rt_getlvar
                             	; save lvar in tmpb, vvt ptr in tmpa
eb50 : 86d6             [ 3] 	stx df_tmpptrb
eb52 : 85d7             [ 3] 	sta df_tmpptrb+1
                             	; load the vdp count as the reset value of timer
                             	; turn off interrupts while reading vdp lo,hi
eb54 : a001             [ 2] 	ldy #1	; This is in readiness to read high byte 
                             	; clear interrupts to access 3 byte vdp counter 
eb56 : 78               [ 2] 	sei
eb57 : a50c             [ 3] 	lda vdp_cnt
eb59 : 92d6             [ 5] 	sta (df_tmpptrb)
eb5b : a50d             [ 3] 	lda vdp_cnt+1
eb5d : 91d6             [ 5] 	sta (df_tmpptrb),y
                             	; restore interrupts asap
eb5f : 58               [ 2] 	cli
eb60 : 60               [ 6] 	rts
                             
                             ;***** FUNCTIONS *****
                             
eb61 :                       df_rt_deek
eb61 : 38               [ 2] 	sec
eb62 : 8001             [ 3] 	bra df_rt_readbyte
eb64 :                       df_rt_peek
eb64 : 18               [ 2] 	clc
eb65 :                       df_rt_readbyte
eb65 : 08               [ 3] 	php
eb66 : e6d1             [ 5] 	inc df_exeoff
eb68 : 2007d8           [ 6] 	jsr df_rt_getnval
eb6b : 86d4             [ 3] 	stx df_tmpptra
eb6d : 85d5             [ 3] 	sta df_tmpptra+1
eb6f : b2d4             [ 5] 	lda (df_tmpptra)
eb71 : aa               [ 2] 	tax
AS65 Assembler for R6502 [1.42].                                     Page  165
-------------------------------- bank\bank1.s --------------------------------

eb72 : a900             [ 2] 	lda #0
eb74 : 28               [ 4] 	plp
eb75 : 9005             [ 3] 	bcc df_rt_readbyte_skip
eb77 : 18               [ 2] 	clc
eb78 : a001             [ 2] 	ldy #1
eb7a : b1d4             [ 5] 	lda (df_tmpptra),y
eb7c :                       df_rt_readbyte_skip
eb7c : 4c43ef           [ 3] 	jmp df_st_pushInt
                             
eb7f :                       df_rt_vpeek
eb7f : e6d1             [ 5] 	inc df_exeoff
eb81 : 2007d8           [ 6] 	jsr df_rt_getnval
eb84 : 20bec3           [ 6] 	jsr _vdp_peek
eb87 : aa               [ 2] 	tax
eb88 : a900             [ 2] 	lda #0
eb8a : 4c43ef           [ 3] 	jmp df_st_pushInt
                             
                             ; Random number generator
                             ; rnd(0) = get next number
                             ; rnd(>0) = set seed
eb8d :                       df_rt_rnd
eb8d : e6d1             [ 5] 	inc df_exeoff
eb8f : 2007d8           [ 6] 	jsr df_rt_getnval
                             	; if input is 0 then generate next random number
eb92 : e000             [ 2] 	cpx #0
eb94 : d017             [ 3] 	bne df_rt_rnd_set
eb96 : c900             [ 2] 	cmp #0
eb98 : d013             [ 3] 	bne df_rt_rnd_set
                             	; generate next number
eb9a : a5eb             [ 3] 	lda df_rnd+1
eb9c : 4a               [ 2] 	lsr a
eb9d : 26ea             [ 5] 	rol df_rnd
eb9f : 9002             [ 3] 	bcc df_rt_rnd_noeor
eba1 : 49b4             [ 2] 	eor #0xb4
eba3 :                       df_rt_rnd_noeor
eba3 : 85eb             [ 3] 	sta df_rnd+1
eba5 : 45ea             [ 3] 	eor df_rnd
eba7 : aa               [ 2] 	tax
eba8 : a900             [ 2] 	lda #0
ebaa : 4c43ef           [ 3] 	jmp df_st_pushInt
                             	; else set the seed to that number and done
ebad :                       df_rt_rnd_set
ebad : 86ea             [ 3] 	stx df_rnd
ebaf : 85eb             [ 3] 	sta df_rnd+1
ebb1 : 4c43ef           [ 3] 	jmp df_st_pushInt
                             
                             
                             ; Get joystick status	
ebb4 :                       df_rt_stick
ebb4 : e6d1             [ 5] 	inc df_exeoff
ebb6 : 2007d8           [ 6] 	jsr df_rt_getnval
                             	; only low byte is used
ebb9 : 86d4             [ 3] 	stx df_tmpptra
ebbb : 208ec3           [ 6] 	jsr _snd_get_joy0
ebbe : 98               [ 2] 	tya
                             	; invert the bits so that 1=switch on
ebbf : 49ff             [ 2] 	eor #0xff
ebc1 : 25d4             [ 3] 	and df_tmpptra
ebc3 : aa               [ 2] 	tax
ebc4 : a900             [ 2] 	lda #0
ebc6 : 4c43ef           [ 3] 	jmp df_st_pushInt
                             
AS65 Assembler for R6502 [1.42].                                     Page  166
-------------------------------- bank\bank1.s --------------------------------

                             ; l = msbyte(x)
ebc9 :                       df_rt_msbyte
ebc9 : e6d1             [ 5] 	inc df_exeoff
ebcb : 2007d8           [ 6] 	jsr df_rt_getnval
                             	; only high byte is used
ebce : aa               [ 2] 	tax
ebcf : a900             [ 2] 	lda #0
ebd1 : 4c43ef           [ 3] 	jmp df_st_pushInt
                             	
                             ; l = lsbyte(x)
ebd4 :                       df_rt_lsbyte
ebd4 : e6d1             [ 5] 	inc df_exeoff
ebd6 : 2007d8           [ 6] 	jsr df_rt_getnval
                             	; only low byte is used
ebd9 : a900             [ 2] 	lda #0
ebdb : 4c43ef           [ 3] 	jmp df_st_pushInt
                             
                             
                             
                             ;* Return memory footprint as follows:
                             ;* 0	Return free memory (start of vvt - end of he
                             ;* 1	Return program size (end of prg - start of p
                             ;* 2	Return size of vars (end of vnt - start of v
ebde :                       df_rt_mem
ebde : e6d1             [ 5] 	inc df_exeoff
ebe0 : 2007d8           [ 6] 	jsr df_rt_getnval
                             	; only low byte is used
ebe3 : e001             [ 2] 	cpx #1
ebe5 : f016             [ 3] 	beq df_rt_mem_prg
ebe7 : e002             [ 2] 	cpx #2
ebe9 : f024             [ 4] 	beq df_rt_mem_var
                             	; default is free memory
ebeb :                       df_rt_mem_free
                             	_cpyZPWord df_vvtstrt,df_tmpptra
                             
                             	_cpyZPWord df_starend,df_tmpptrb
                             
ebfb : 8022             [ 4] 	bra df_rt_mem_calc
ebfd :                       df_rt_mem_prg
                             	_cpyZPWord df_prgend,df_tmpptra
                             
                             	_cpyZPWord df_prgstrt,df_tmpptrb
                             
ec0d : 8010             [ 3] 	bra df_rt_mem_calc
ec0f :                       df_rt_mem_var
                             	_cpyZPWord df_vntend,df_tmpptra
                             
                             	_cpyZPWord df_vvtstrt,df_tmpptrb
                             
ec1f :                       df_rt_mem_calc
                             	; tmpa-tmpb result in X,A
ec1f : 38               [ 2] 	sec
ec20 : a5d4             [ 3] 	lda df_tmpptra
ec22 : e5d6             [ 3] 	sbc df_tmpptrb
ec24 : aa               [ 2] 	tax
ec25 : a5d5             [ 3] 	lda df_tmpptra+1
ec27 : e5d7             [ 3] 	sbc df_tmpptrb+1
ec29 : 4c43ef           [ 3] 	jmp df_st_pushInt
                             
                             ; %k=key(%sync) %sync>=1 means sync
ec2c :                       df_rt_key
ec2c : e6d1             [ 5] 	inc df_exeoff
AS65 Assembler for R6502 [1.42].                                     Page  167
-------------------------------- bank\bank1.s --------------------------------

ec2e : 2007d8           [ 6] 	jsr df_rt_getnval
                             	; only low byte is used, check for sync or async
                             	; c=1 if x==0 else x>0 makes c=0
ec31 : e001             [ 2] 	cpx #1
ec33 : 2046c4           [ 6] 	jsr io_get_ch
ec36 : 9003             [ 3] 	bcc df_rt_key_valid
                             	; zero out A
ec38 : a900             [ 2] 	lda #0
ec3a : 18               [ 2] 	clc
ec3b :                       df_rt_key_valid
ec3b : aa               [ 2] 	tax
ec3c : a900             [ 2] 	lda #0
ec3e : 4c43ef           [ 3] 	jmp df_st_pushInt
                             
                             	
                             ; s = scrn(x,y)
ec41 :                       df_rt_scrn
ec41 : e6d1             [ 5] 	inc df_exeoff
ec43 : 2008da           [ 6] 	jsr df_rt_parm_2ints
ec46 : a6d4             [ 3] 	ldx df_tmpptra
ec48 : a4d6             [ 3] 	ldy df_tmpptrb
ec4a : 2046c3           [ 6] 	jsr _gr_get
ec4d : aa               [ 2] 	tax
ec4e : a900             [ 2] 	lda #0
ec50 : 4c43ef           [ 3] 	jmp df_st_pushInt
                             
                             ; %e=elapsed(%var)
ec53 :                       df_rt_elapsed
                             	; now get lvar X,A from current statement
ec53 : 20d2db           [ 6] 	jsr df_rt_getlvar
ec56 : e6d1             [ 5] 	inc df_exeoff
                             	; save lvar in tmpb, vvt ptr in tmpa
ec58 : 86d6             [ 3] 	stx df_tmpptrb
ec5a : 85d7             [ 3] 	sta df_tmpptrb+1
                             	; subtract vdp counter from value
                             	; turn off interrupts while reading vdp lo,hi
ec5c : a001             [ 2] 	ldy #1	; This is in readiness to read high byte 
ec5e : 38               [ 2] 	sec
                             	; disable interrupts to access vdp counter
ec5f : 78               [ 2] 	sei
ec60 : a50c             [ 3] 	lda vdp_cnt
ec62 : f2d6             [ 5] 	sbc (df_tmpptrb)
ec64 : aa               [ 2] 	tax
ec65 : a50d             [ 3] 	lda vdp_cnt+1
                             	; restore interrupts asap
ec67 : 58               [ 2] 	cli
ec68 : f1d6             [ 5] 	sbc (df_tmpptrb),y
ec6a : 4c43ef           [ 3] 	jmp df_st_pushInt
                             
ec6d :                       df_rt_call
ec6d : e6d1             [ 5] 	inc df_exeoff
ec6f : 2042da           [ 6] 	jsr df_rt_parm_4ints
ec72 : a5d6             [ 3] 	lda df_tmpptrb				; load A
ec74 : a6d8             [ 3] 	ldx	df_tmpptrc				; load X
ec76 : a4da             [ 3] 	ldy df_tmpptrd				; load Y
ec78 : 207eec           [ 6] 	jsr df_rt_calljsr
ec7b : 4c43ef           [ 3] 	jmp df_st_pushInt			; A,X pair is return value	
ec7e :                       df_rt_calljsr
ec7e : 6cd400           [ 6] 	jmp (df_tmpptra)			; tmpptra is address, return 
                             
                             ; string length calculator
                             ; X,A = source
AS65 Assembler for R6502 [1.42].                                     Page  168
-------------------------------- bank\bank1.s --------------------------------

                             ; A = length not including zero
ec81 :                       df_rt_strlen_common
ec81 : 86d4             [ 3] 	stx df_tmpptra
ec83 : 85d5             [ 3] 	sta df_tmpptra+1
ec85 : a0ff             [ 2] 	ldy #0xff
ec87 :                       df_rt_strlen_count
ec87 : c8               [ 2] 	iny
ec88 : b1d4             [ 5] 	lda (df_tmpptra),y
ec8a : d0fb             [ 3] 	bne df_rt_strlen_count
ec8c : 98               [ 2] 	tya
ec8d : 60               [ 6] 	rts
                             	
                             	
                             ; common routine to extract a string
                             ; tmpa = source string
                             ; tmpb = dest string
                             ; tmpc = start pos
                             ; tmpd = endpos	
ec8e :                       df_rt_str_extract
                             	; source string
ec8e : 2078ef           [ 6] 	jsr df_st_popStr
ec91 : 86d4             [ 3] 	stx df_tmpptra
ec93 : 85d5             [ 3] 	sta df_tmpptra+1
                             	; destination is string accumulator
ec95 : a5c3             [ 3] 	lda df_sevalptr
ec97 : 85d6             [ 3] 	sta df_tmpptrb
ec99 : a5c4             [ 3] 	lda df_sevalptr+1
ec9b : 85d7             [ 3] 	sta df_tmpptrb+1
                             	; start pos
ec9d : a4d8             [ 3] 	ldy df_tmpptrc
ec9f :                       df_rt_str_cpy_ch
ec9f : c4da             [ 3] 	cpy df_tmpptrd
eca1 : f011             [ 3] 	beq df_str_src_end
eca3 : b1d4             [ 5] 	lda (df_tmpptra),y
eca5 : f00d             [ 3] 	beq df_str_src_end
eca7 : 92d6             [ 5] 	sta (df_tmpptrb)
                             	_incZPWord df_tmpptrb
                             
ecaf : c8               [ 2] 	iny
ecb0 : d0ed             [ 3] 	bne df_rt_str_cpy_ch
                             	SWBRK DFERR_STRLONG
                             
ecb4 :                       df_str_src_end
ecb4 : a900             [ 2] 	lda #0
ecb6 : 92d6             [ 5] 	sta (df_tmpptrb)
ecb8 : a6c3             [ 3] 	ldx df_sevalptr
ecba : a5c4             [ 3] 	lda df_sevalptr+1
ecbc : 4c48ef           [ 3] 	jmp df_st_pushStr
                             
                             ; $c = chr(x)
ecbf :                       df_rt_chr
ecbf : e6d1             [ 5] 	inc df_exeoff
                             	; get char in X
ecc1 : 2007d8           [ 6] 	jsr df_rt_getnval
ecc4 : a000             [ 2] 	ldy #0
                             	; transfer lo byte to A
ecc6 : 8a               [ 2] 	txa
ecc7 : 91c3             [ 5] 	sta (df_sevalptr),y
ecc9 : c8               [ 2] 	iny
                             	; zero terminator
ecca : a900             [ 2] 	lda #0
eccc : 91c3             [ 5] 	sta (df_sevalptr),y
AS65 Assembler for R6502 [1.42].                                     Page  169
-------------------------------- bank\bank1.s --------------------------------

                             	; point to seval scratch area
ecce : a6c3             [ 3] 	ldx df_sevalptr
ecd0 : a5c4             [ 3] 	lda df_sevalptr+1
ecd2 : 4c48ef           [ 3] 	jmp df_st_pushStr
                             
                             ; $c = hex(x)
ecd5 :                       df_rt_hex
ecd5 : e6d1             [ 5] 	inc df_exeoff
                             	; create hex digits
ecd7 : 2007d8           [ 6] 	jsr df_rt_getnval
ecda : 85d4             [ 3] 	sta df_tmpptra	; Save the high byte
ecdc : 8a               [ 2] 	txa				; Convert low byte first
ecdd : 2022c7           [ 6] 	jsr str_a_to_x	; Hex digits in A,X
ece0 : da               [ 3] 	phx				; Push low digit of low byte
ece1 : 48               [ 3] 	pha				; Push high digit of low byte
ece2 : a5d4             [ 3] 	lda df_tmpptra	; Get the high byte
ece4 : 2022c7           [ 6] 	jsr str_a_to_x	; Hex digits in A,X
                             	; create string
ece7 : a000             [ 2] 	ldy #0			; Index in to string temp area
                             	; hi/hi
ece9 : 91c3             [ 5] 	sta (df_sevalptr),y
eceb : c8               [ 2] 	iny
                             	; hi/lo
ecec : 8a               [ 2] 	txa
eced : 91c3             [ 5] 	sta (df_sevalptr),y
ecef : c8               [ 2] 	iny
                             	; lo/hi
ecf0 : 68               [ 4] 	pla
ecf1 : 91c3             [ 5] 	sta (df_sevalptr),y
ecf3 : c8               [ 2] 	iny
                             	; lo/lo
ecf4 : 68               [ 4] 	pla
ecf5 : 91c3             [ 5] 	sta (df_sevalptr),y
ecf7 : c8               [ 2] 	iny
                             	; zero terminator
ecf8 : a900             [ 2] 	lda #0
ecfa : 91c3             [ 5] 	sta (df_sevalptr),y
                             	; point to seval scratch area
ecfc : a6c3             [ 3] 	ldx df_sevalptr
ecfe : a5c4             [ 3] 	lda df_sevalptr+1
ed00 : 4c48ef           [ 3] 	jmp df_st_pushStr
                             
                             ; $l = left($s, x)
ed03 :                       df_rt_left
ed03 : e6d1             [ 5] 	inc df_exeoff
                             	; first get the string to act on
                             	; point to string accumulator
ed05 : a6c3             [ 3] 	ldx df_sevalptr
ed07 : a5c4             [ 3] 	lda df_sevalptr+1
ed09 : 200dd8           [ 6] 	jsr df_rt_seval
                             	; now get the num of chars
ed0c : e6d1             [ 5] 	inc df_exeoff
ed0e : 2007d8           [ 6] 	jsr df_rt_getnval
                             	; number of chars to extract
ed11 : 86da             [ 3] 	stx df_tmpptrd
                             	; start position
ed13 : 64d8             [ 3] 	stz df_tmpptrc
ed15 : 4c8eec           [ 3] 	jmp df_rt_str_extract
                             
                             ; $r = right($s, x)
ed18 :                       df_rt_right
ed18 : e6d1             [ 5] 	inc df_exeoff
AS65 Assembler for R6502 [1.42].                                     Page  170
-------------------------------- bank\bank1.s --------------------------------

                             	; first get the string to act on
                             	; point to string accumulator
ed1a : a6c3             [ 3] 	ldx df_sevalptr
ed1c : a5c4             [ 3] 	lda df_sevalptr+1
ed1e : 200dd8           [ 6] 	jsr df_rt_seval
                             	; now get the num of chars from the right
ed21 : e6d1             [ 5] 	inc df_exeoff
ed23 : 2007d8           [ 6] 	jsr df_rt_getnval
                             	; number of chars to extract from the right
ed26 : 86d8             [ 3] 	stx df_tmpptrc
                             	; end pos = len
ed28 : a6c3             [ 3] 	ldx df_sevalptr
ed2a : a5c4             [ 3] 	lda df_sevalptr+1
ed2c : 2081ec           [ 6] 	jsr df_rt_strlen_common
ed2f : 85da             [ 3] 	sta df_tmpptrd
                             	; subtract num chars to extract to get start pos
ed31 : 38               [ 2] 	sec
ed32 : e5d8             [ 3] 	sbc df_tmpptrc
ed34 : 85d8             [ 3] 	sta df_tmpptrc
ed36 : 4c8eec           [ 3] 	jmp df_rt_str_extract
                             
                             ; $m = mid($s, x, y)
ed39 :                       df_rt_mid
ed39 : e6d1             [ 5] 	inc df_exeoff
                             	; first get the string to act on
                             	; point to string accumulator
ed3b : a6c3             [ 3] 	ldx df_sevalptr
ed3d : a5c4             [ 3] 	lda df_sevalptr+1
ed3f : 200dd8           [ 6] 	jsr df_rt_seval
                             	; now get start of string segment
ed42 : e6d1             [ 5] 	inc df_exeoff
ed44 : 2061d7           [ 6] 	jsr df_rt_neval
                             	; number of chars to extract
ed47 : e6d1             [ 5] 	inc df_exeoff
ed49 : 2007d8           [ 6] 	jsr df_rt_getnval
ed4c : 86da             [ 3] 	stx df_tmpptrd
                             	; start position
ed4e : 2073ef           [ 6] 	jsr df_st_popInt
ed51 : 86d8             [ 3] 	stx df_tmpptrc
                             	; update end pos by adding start pos
ed53 : 8a               [ 2] 	txa
ed54 : 18               [ 2] 	clc
ed55 : 65da             [ 3] 	adc df_tmpptrd
ed57 : 85da             [ 3] 	sta df_tmpptrd
ed59 : 4c8eec           [ 3] 	jmp df_rt_str_extract
                             
                             ; %l = len($s)
ed5c :                       df_rt_len
ed5c : e6d1             [ 5] 	inc df_exeoff
ed5e : a6c3             [ 3] 	ldx df_sevalptr
ed60 : a5c4             [ 3] 	lda df_sevalptr+1
ed62 : 200dd8           [ 6] 	jsr df_rt_seval
ed65 : 2078ef           [ 6] 	jsr df_st_popStr
ed68 : 2081ec           [ 6] 	jsr df_rt_strlen_common
ed6b : aa               [ 2] 	tax
ed6c : a900             [ 2] 	lda #0
ed6e : 4c43ef           [ 3] 	jmp df_st_pushInt
                             
                             ; %l = asc($s)
ed71 :                       df_rt_asc
ed71 : e6d1             [ 5] 	inc df_exeoff
ed73 : a6c3             [ 3] 	ldx df_sevalptr
AS65 Assembler for R6502 [1.42].                                     Page  171
-------------------------------- bank\bank1.s --------------------------------

ed75 : a5c4             [ 3] 	lda df_sevalptr+1
                             	; Evaluate the string with pointer in X,A
ed77 : 200dd8           [ 6] 	jsr df_rt_seval
ed7a : 2078ef           [ 6] 	jsr df_st_popStr
                             	; Store point in ZP
ed7d : 86d4             [ 3] 	stx df_tmpptra
ed7f : 85d5             [ 3] 	sta df_tmpptra+1
                             	; Find the character at beginning
ed81 : b2d4             [ 5] 	lda (df_tmpptra)
ed83 : aa               [ 2] 	tax
ed84 : a900             [ 2] 	lda #0
                             	; Save as an int
ed86 : 4c43ef           [ 3] 	jmp df_st_pushInt
                             
                             ; %l = val($s)
ed89 :                       df_rt_val
ed89 : e6d1             [ 5] 	inc df_exeoff
ed8b : a6c3             [ 3] 	ldx df_sevalptr
ed8d : a5c4             [ 3] 	lda df_sevalptr+1
ed8f : 200dd8           [ 6] 	jsr df_rt_seval
                             	; X,A = address of string
ed92 : 2078ef           [ 6] 	jsr df_st_popStr
ed95 : a000             [ 2] 	ldy #0				; any numeric format
ed97 : 206dc7           [ 6] 	jsr con_n_to_a		; result in num_a
ed9a : b007             [ 3] 	bcs df_rt_val_err
ed9c : a68e             [ 3] 	ldx num_a
ed9e : a58f             [ 3] 	lda num_a+1
                             	; Save as an int
eda0 : 4c43ef           [ 3] 	jmp df_st_pushInt
eda3 :                       df_rt_val_err
                             	SWBRK DFERR_TYPEMISM
                             
                             
                             ; stop execution
eda5 :                       df_rt_abort
                             	SWBRK DFERR_ABORT
                             
                             	
eda7 :                       mod_sz_rtsubs_e
                             
                             
                             	include "dflat\proc.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  PROC.S
                             ;*  dflat module to handle procedures:
                             ;*  - executing a procedure
                             ;*  - find a proc, pass local and non-local param
                             ;*  - return from a proc, unload locals
                             ;*  - save the definition of a proc in the VNT an
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
AS65 Assembler for R6502 [1.42].                                     Page  172
-------------------------------- bank\bank1.s --------------------------------

                             ; executing a procedure in A
eda7 :                       df_rt_exec_proc
                             	; get pointer to the procedure
eda7 : 20d4ca           [ 6] 	jsr df_var_addr
                             	; need to save all important vars
edaa : a5cf             [ 3] 	lda df_currlin
edac : 48               [ 3] 	pha
edad : a5d0             [ 3] 	lda df_currlin+1
edaf : 48               [ 3] 	pha
edb0 : a5d1             [ 3] 	lda df_exeoff
edb2 : 48               [ 3] 	pha
edb3 : a5c8             [ 3] 	lda df_nxtstidx
edb5 : 48               [ 3] 	pha
edb6 : a5c9             [ 3] 	lda df_curstidx
edb8 : 48               [ 3] 	pha
edb9 : a5c7             [ 3] 	lda df_eolidx
edbb : 48               [ 3] 	pha
edbc : a5e6             [ 3] 	lda df_ifnest
edbe : 48               [ 3] 	pha
                             
                             	; now initialise the data
edbf : a001             [ 2] 	ldy #DFVVT_LO
edc1 : b1d4             [ 5] 	lda (df_tmpptra),y
edc3 : 85cf             [ 3] 	sta df_currlin
edc5 : c8               [ 2] 	iny
edc6 : b1d4             [ 5] 	lda (df_tmpptra),y
edc8 : 85d0             [ 3] 	sta df_currlin+1
edca : c8               [ 2] 	iny
edcb : b1d4             [ 5] 	lda (df_tmpptra),y
edcd : 85d1             [ 3] 	sta df_exeoff
edcf : 85c9             [ 3] 	sta df_curstidx
edd1 : b2cf             [ 5] 	lda (df_currlin)
edd3 : 85c8             [ 3] 	sta df_nxtstidx
                             	; now execute statements
edd5 : 20bdda           [ 6] 	jsr df_rt_exec_stat
                             ;	bcs df_rt_exec_proc_err
                             	; now restore the position
edd8 : 68               [ 4] 	pla
edd9 : 85e6             [ 3] 	sta df_ifnest
eddb : 68               [ 4] 	pla
eddc : 85c7             [ 3] 	sta df_eolidx
edde : 68               [ 4] 	pla
eddf : 85c9             [ 3] 	sta df_curstidx
ede1 : 68               [ 4] 	pla
ede2 : 85c8             [ 3] 	sta df_nxtstidx
ede4 : 68               [ 4] 	pla
ede5 : 85d1             [ 3] 	sta df_exeoff
ede7 : 68               [ 4] 	pla
ede8 : 85d0             [ 3] 	sta df_currlin+1
edea : 68               [ 4] 	pla
edeb : 85cf             [ 3] 	sta df_currlin
                             	; should be all restored, so return
eded : 60               [ 6] 	rts
                             
                             ; call procedure
edee :                       df_rt_proc
                             	; move past escape token
edee : e6d1             [ 5] 	inc df_exeoff
edf0 : a4d1             [ 3] 	ldy df_exeoff
edf2 : b1cf             [ 5] 	lda (df_currlin),y
                             	; save index for later
edf4 : 48               [ 3] 	pha
AS65 Assembler for R6502 [1.42].                                     Page  173
-------------------------------- bank\bank1.s --------------------------------

                             	; get the address of procedure
edf5 : 20d4ca           [ 6] 	jsr df_var_addr
                             	_cpyZPWord df_tmpptra,df_procptr
                             
                             	; is index 0 (dim1)
                             	; then find the procedure
ee00 : a003             [ 2] 	ldy #DFVVT_DIM1
ee02 : b1e1             [ 5] 	lda (df_procptr),y
ee04 : d016             [ 3] 	bne df_rt_proc_addr
                             	; find proc, AXY is returned
ee06 : 68               [ 4] 	pla
ee07 : 48               [ 3] 	pha
ee08 : 2078db           [ 6] 	jsr df_rt_findproc
                             	; save y (line index)
ee0b : 843f             [ 3] 	sty tmp_a
                             	; now go and update the proc vvt address
ee0d : a002             [ 2] 	ldy #DFVVT_HI
ee0f : 91e1             [ 5] 	sta (df_procptr),y
ee11 : a001             [ 2] 	ldy #DFVVT_LO
ee13 : 8a               [ 2] 	txa
ee14 : 91e1             [ 5] 	sta (df_procptr),y
ee16 : a003             [ 2] 	ldy #DFVVT_DIM1
                             	; get back line index in to A
ee18 : a53f             [ 3] 	lda tmp_a
ee1a : 91e1             [ 5] 	sta (df_procptr),y
ee1c :                       df_rt_proc_addr
                             	; move past proc idx and first open bracket
ee1c : e6d1             [ 5] 	inc df_exeoff
ee1e : e6d1             [ 5] 	inc df_exeoff
                             	
                             	; get parm count
ee20 : a004             [ 2] 	ldy #DFVVT_DIM2
ee22 : b1e1             [ 5] 	lda (df_procptr),y
ee24 : f014             [ 3] 	beq df_rt_proc_parm_none
                             	; push the right number of parms on
ee26 : 48               [ 3] 	pha
                             
ee27 :                       df_rt_proc_push_parm
ee27 : 2061d7           [ 6] 	jsr df_rt_neval
                             ;	bcs df_rt_proc_parmother
ee2a : a4d1             [ 3] 	ldy df_exeoff
ee2c : b1cf             [ 5] 	lda (df_currlin),y
ee2e : c929             [ 2] 	cmp #')'
ee30 : f007             [ 3] 	beq df_rt_proc_parm_done
                             	; move past comma
ee32 : e6d1             [ 5] 	inc df_exeoff
                             	; get parm count off stack
ee34 : 68               [ 4] 	pla
                             	; decrement
ee35 : 3a               [ 2] 	dec a
                             	; and put back on stack
ee36 : 48               [ 3] 	pha
                             	; go back and do all required parms
ee37 : d0ee             [ 3] 	bne df_rt_proc_push_parm
                             	; remove parm counter from stack
ee39 :                       df_rt_proc_parm_done
ee39 : 68               [ 4] 	pla
ee3a :                       df_rt_proc_parm_none
                             	; should be at close bracket
ee3a : a4d1             [ 3] 	ldy df_exeoff
ee3c : b1cf             [ 5] 	lda (df_currlin),y
ee3e : c929             [ 2] 	cmp #')'
AS65 Assembler for R6502 [1.42].                                     Page  174
-------------------------------- bank\bank1.s --------------------------------

ee40 : d004             [ 3] 	bne df_rt_proc_parmerr
                             	; should be no more parms
                             	; ok, finally we have all parms on rt stack
                             	; now execute the procedure
                             	; get back the proc index
ee42 : 68               [ 4] 	pla
ee43 : 4ca7ed           [ 3] 	jmp df_rt_exec_proc
                             	
ee46 :                       df_rt_proc_parmerr
                             	SWBRK DFERR_PROCPARM
                             
                             
                             
ee48 :                       df_rt_def
                             	; line offset pointing at DFTK_PROC
                             	; skip over PROC id byte and open bracket
ee48 : e6d1             [ 5] 	inc df_exeoff
ee4a : e6d1             [ 5] 	inc df_exeoff
                             	; parms on stack in reverse order to parm list
                             	; so get each parm and type and save to scratch
ee4c : a201             [ 2] 	ldx #1									; actual # of parms is X-1
ee4e : a4d1             [ 3] 	ldy df_exeoff
ee50 :                       df_rt_def_find_var
ee50 : c8               [ 2] 	iny
ee51 : b1cf             [ 5] 	lda (df_currlin),y
                             	; check if end of parm list
ee53 : c929             [ 2] 	cmp #')'
ee55 : f018             [ 3] 	beq df_rt_def_parm_done
                             	; else check if found a variable escape token (<
ee57 : c911             [ 2] 	cmp #DFTK_VAR
ee59 : f009             [ 3] 	beq df_rt_def_got_var
                             	; else check if non-local specifier
ee5b : c926             [ 2] 	cmp #DFTK_VARPARM						; This is a regular ASCII
ee5d : f002             [ 3] 	beq df_rt_def_got_varparm
ee5f : 80ef             [ 3] 	bra df_rt_def_find_var
ee61 :                       df_rt_def_got_varparm
                             	; set high bit
ee61 : 0980             [ 2] 	ora #0x80
                             	; advance over non-local specifier
ee63 : c8               [ 2] 	iny
ee64 :                       df_rt_def_got_var
                             	; when we get here either A contains DFTK_VAR to
                             	; keep only the MSB
ee64 : 2980             [ 2] 	and #0x80
                             	; skip over DFTK_VAR to var index
ee66 : c8               [ 2] 	iny
                             	; get var index and OR with A which will have MS
ee67 : 11cf             [ 5] 	ora (df_currlin),y
                             	; save the index in scratch
ee69 : 9dbb0b           [ 5] 	sta scratch,x
                             	; increment count
ee6c : e8               [ 2] 	inx
ee6d : 80e1             [ 3] 	bra df_rt_def_find_var
ee6f :                       df_rt_def_parm_done
                             	; save index that we got to
ee6f : 84d1             [ 3] 	sty df_exeoff
                             	; all var indices on the operator stack
                             	; now load up variables with parameters
ee71 : 86df             [ 3] 	stx df_procargs
                             	; initially assume no locals
ee73 : 64e0             [ 3] 	stz df_procloc
ee75 :                       df_rt_def_load_var
AS65 Assembler for R6502 [1.42].                                     Page  175
-------------------------------- bank\bank1.s --------------------------------

ee75 : c6df             [ 5] 	dec df_procargs
ee77 : f02e             [ 3] 	beq df_rt_def_load_var_done
                             	; get var index
ee79 : a6df             [ 3] 	ldx df_procargs
ee7b : bdbb0b           [ 4] 	lda scratch,x
                             	
                             	; save this temporarily
ee7e : 48               [ 3] 	pha
                             	; mask off MSB in case it is set
ee7f : 297f             [ 2] 	and #0x7f
                             	; get vvt slot address
ee81 : 20d4ca           [ 6] 	jsr df_var_addr
                             	; get the var index off the stack
ee84 : 68               [ 4] 	pla
                             	; if MSB is set then this is not a local variabl
ee85 : 3007             [ 3] 	bmi df_rt_def_initialise_parm
                             	; else call the local handling code
                             	; push the var index on to the runtime stack
ee87 : 297f             [ 2] 	and #0x7f
ee89 : 20f4ee           [ 6] 	jsr df_rt_proc_parm_local
                             	; increment number of locals
ee8c : e6e0             [ 5] 	inc df_procloc
ee8e :                       df_rt_def_initialise_parm
                             	; load type
ee8e : b2d4             [ 5] 	lda (df_tmpptra)
                             	; if array or string type then pop pointer from 
ee90 : 2984             [ 2] 	and #DFVVT_STR|DFVVT_ARRY
ee92 : f005             [ 3] 	beq df_rt_def_load_var_int
ee94 : 207def           [ 6] 	jsr df_st_popPtr
ee97 : 8003             [ 3] 	bra df_rt_def_load_var_int_skip
ee99 :                       df_rt_def_load_var_int
                             	; must be int pop it from operator stack
ee99 : 2073ef           [ 6] 	jsr df_st_popInt
ee9c :                       df_rt_def_load_var_int_skip
                             	; update the variable
ee9c : a002             [ 2] 	ldy #DFVVT_HI
ee9e : 91d4             [ 5] 	sta (df_tmpptra),y
eea0 : a001             [ 2] 	ldy #DFVVT_LO
eea2 : 8a               [ 2] 	txa
eea3 : 91d4             [ 5] 	sta (df_tmpptra),y	
eea5 : 80ce             [ 3] 	bra df_rt_def_load_var
eea7 :                       df_rt_def_load_var_done
                             	; save the number of lcoal parameters found so t
                             	; be unloaded when the proc ends
eea7 : a5e0             [ 3] 	lda df_procloc
eea9 : 20faee           [ 6] 	jsr df_st_pushByte
                             	; continue with next statement
eeac : 18               [ 2] 	clc
eead : 60               [ 6] 	rts
                             	; def error - parameter problem
eeae :                       df_rt_def_err
                             	SWBRK DFERR_PROCPARM
                             
                             
                             	
                             ; end def for a proc
eeb0 :                       df_rt_enddef
                             	; unload any locals
eeb0 : 20bcee           [ 6] 	jsr df_rt_proc_unlocal
                             	; nothing to do - main loop will terminate
eeb3 : 18               [ 2] 	clc
eeb4 : 60               [ 6] 	rts
AS65 Assembler for R6502 [1.42].                                     Page  176
-------------------------------- bank\bank1.s --------------------------------

                             	
                             ; return a value
eeb5 :                       df_rt_return
                             	; evaluate the return and put on the parameter s
eeb5 : 2061d7           [ 6] 	jsr df_rt_neval
                             	; process this like an end of procedure
eeb8 : 20b0ee           [ 6] 	jsr df_rt_enddef
eebb : 60               [ 6] 	rts
                             	
                             	
                             ; unload any local variables from runtime stack
eebc :                       df_rt_proc_unlocal
eebc : 2003ef           [ 6] 	jsr df_st_popByte
eebf : aa               [ 2] 	tax
eec0 : f01e             [ 3] 	beq df_rt_proc_unload_done
eec2 :                       df_rt_proc_unloadvar
eec2 : 8a               [ 2] 	txa
eec3 : da               [ 3] 	phx
                             	; var value is popped first then index
                             	; get a word and put in tmpb
eec4 : 2021ef           [ 6] 	jsr df_st_popWord
eec7 : 86d6             [ 3] 	stx df_tmpptrb
eec9 : 85d7             [ 3] 	sta df_tmpptrb+1
                             	; get the var number
eecb : 2003ef           [ 6] 	jsr df_st_popByte
                             	; store address in tmpa
eece : 20d4ca           [ 6] 	jsr df_var_addr
                             	; store lo byte first
eed1 : a001             [ 2] 	ldy #DFVVT_LO
eed3 : a5d6             [ 3] 	lda df_tmpptrb
eed5 : 91d4             [ 5] 	sta (df_tmpptra),y
                             	; then hi
eed7 : c8               [ 2] 	iny
eed8 : a5d7             [ 3] 	lda df_tmpptrb+1
eeda : 91d4             [ 5] 	sta (df_tmpptra),y
                             	; restore counter
eedc : fa               [ 4] 	plx
eedd : ca               [ 2] 	dex
eede : d0e2             [ 3] 	bne df_rt_proc_unloadvar
eee0 :                       df_rt_proc_unload_done
eee0 : 60               [ 6] 	rts
                             	
                             ; push a local variable to the runtime stack
                             ; A = var index
                             ; var index is pushed first, then value
eee1 :                       df_rt_proc_local
                             	; save the var index on rt stack
eee1 : 20faee           [ 6] 	jsr df_st_pushByte
                             	; populate tmpa with var address
eee4 : 20d4ca           [ 6] 	jsr df_var_addr
eee7 :                       df_rt_proc_local_load	
                             	; load x,a with var value lo,hi
eee7 : a001             [ 2] 	ldy #DFVVT_LO
eee9 : b1d4             [ 5] 	lda (df_tmpptra),y
eeeb : aa               [ 2] 	tax
eeec : c8               [ 2] 	iny
eeed : b1d4             [ 5] 	lda (df_tmpptra),y
                             	; push word on to rt stack
eeef : 2013ef           [ 6] 	jsr df_st_pushWord
eef2 : 18               [ 2] 	clc
eef3 : 60               [ 6] 	rts
                             	
AS65 Assembler for R6502 [1.42].                                     Page  177
-------------------------------- bank\bank1.s --------------------------------

eef4 :                       df_rt_proc_parm_local				; Jsr to here in a def s
                             	; save the var index on rt stack
eef4 : 20faee           [ 6] 	jsr df_st_pushByte
eef7 : 4ce7ee           [ 3] 	jmp df_rt_proc_local_load
                             		
                             	
eefa :                       mod_sz_runtime_e
                             
                             
                             
                             	include "dflat\stack.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  STACK.S
                             ;*  This module implements the dflat software sta
                             ;*  needs a few stacks:
                             ;*  - 6502 stack for expression parsing and reent
                             ;*  - dflat runtime stack for things like for/nex
                             ;*  - dflat parameter stack for passing parameter
                             ;*  The two software stacks are implemented in th
                             ;*  with the runtime stack growing up from 0 and 
                             ;*  operator stack growing down from 255.  Hopefu
                             ;*  don't meet as there are no checks for this at
                             ;*  purely because I want speed over friendliness
                             ;*  I may come to regret this.
                             ;*  I have also added the only runtime memory all
                             ;*  needed by dflat here.  Humourously I have cal
                             ;*  which is taken from the C language, but it on
                             ;*  grab some memory after the of dflat program c
                             ;*  arrays - which of course cannot have storage 
                             ;*  tokenisation time (e.g. because I dimension a
                             ;*  a size from a variable).
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
                             
                             ;****************************************
                             ;* Push a byte on to runtime stack
                             ;* A = byte
                             ;****************************************
eefa :                       df_st_pushByte
eefa : a4bf             [ 3] 	ldy df_rtstop
eefc : 99000a           [ 5] 	sta df_rtstck,y
eeff : c8               [ 2] 	iny
ef00 : 84bf             [ 3] 	sty df_rtstop
ef02 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Pop a byte off runtime stack
                             ;* A = byte
                             ;****************************************
ef03 :                       df_st_popByte
ef03 : a4bf             [ 3] 	ldy df_rtstop
AS65 Assembler for R6502 [1.42].                                     Page  178
-------------------------------- bank\bank1.s --------------------------------

ef05 : 88               [ 2] 	dey
ef06 : b9000a           [ 4] 	lda df_rtstck,y
ef09 : 84bf             [ 3] 	sty df_rtstop
ef0b : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Peek a byte off runtime stack
                             ;* A = byte
                             ;****************************************
ef0c :                       df_st_peekByte
ef0c : a4bf             [ 3] 	ldy df_rtstop
ef0e : 88               [ 2] 	dey
ef0f : b9000a           [ 4] 	lda df_rtstck,y
ef12 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* Push a word on to runtime stack
                             ;* X,A = word lo,hi
                             ;****************************************
ef13 :                       df_st_pushWord
ef13 : a4bf             [ 3] 	ldy df_rtstop
ef15 : 99000a           [ 5] 	sta df_rtstck,y
ef18 : c8               [ 2] 	iny
ef19 : 8a               [ 2] 	txa
ef1a : 99000a           [ 5] 	sta df_rtstck,y
ef1d : c8               [ 2] 	iny
ef1e : 84bf             [ 3] 	sty df_rtstop
ef20 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Pop a word off runtime stack
                             ;* X,A = word lo,hi
                             ;****************************************
ef21 :                       df_st_popWord
ef21 : a4bf             [ 3] 	ldy df_rtstop
ef23 : 88               [ 2] 	dey
ef24 : b9000a           [ 4] 	lda df_rtstck,y
ef27 : aa               [ 2] 	tax
ef28 : 88               [ 2] 	dey
ef29 : b9000a           [ 4] 	lda df_rtstck,y
ef2c : 84bf             [ 3] 	sty df_rtstop
ef2e : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Push a parameter on to parm stack
                             ;* X,A - int
                             ;* Y - type
                             ;****************************************
ef2f :                       df_st_pushParmX
ef2f : 5a               [ 3] 	phy
ef30 : a4c0             [ 3] 	ldy df_parmtop
                             	; push high byte first
ef32 : 99000b           [ 5] 	sta df_opstck,y
ef35 : c8               [ 2] 	iny
                             	; push low byte next (xfer from X)
ef36 : 8a               [ 2] 	txa
ef37 : 99000b           [ 5] 	sta df_opstck,y
ef3a : c8               [ 2] 	iny
                             	; push type
ef3b : 68               [ 4] 	pla
ef3c : 99000b           [ 5] 	sta df_opstck,y
ef3f : c8               [ 2] 	iny
AS65 Assembler for R6502 [1.42].                                     Page  179
-------------------------------- bank\bank1.s --------------------------------

                             	; save new top of stack
ef40 : 84c0             [ 3] 	sty df_parmtop
ef42 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Push an int on to parm stack
                             ;* X,A - int
                             ;****************************************
ef43 :                       df_st_pushInt
ef43 : a001             [ 2] 	ldy #DFST_INT
ef45 : 4c2fef           [ 3] 	jmp df_st_pushParmX
                             
                             ;****************************************
                             ;* Push a string pointer on to parm stack
                             ;* X,A - int
                             ;****************************************
ef48 :                       df_st_pushStr
ef48 : a080             [ 2] 	ldy #DFST_STR
ef4a : 4c2fef           [ 3] 	jmp df_st_pushParmX
                             
                             ;****************************************
                             ;* Push a general pointer on to parm stack
                             ;* X,A - int
                             ;****************************************
ef4d :                       df_st_pushPtr
ef4d : a0ff             [ 2] 	ldy #0xff
ef4f : 4c2fef           [ 3] 	jmp df_st_pushParmX
                             	
                             ;****************************************
                             ;* Pop parameter from the stack
                             ;* X,A - int
                             ;* Y - type expected
                             ;****************************************
ef52 :                       df_st_popParmX
ef52 : 5a               [ 3] 	phy
ef53 : a4c0             [ 3] 	ldy df_parmtop
                             	; pull low byte first
ef55 : 68               [ 4] 	pla
ef56 : 88               [ 2] 	dey
ef57 : 39000b           [ 4] 	and df_opstck,y
ef5a : f00d             [ 3] 	beq df_st_typemismatcherr
                             	; pull low byte first
ef5c : 88               [ 2] 	dey
ef5d : b9000b           [ 4] 	lda df_opstck,y
ef60 : aa               [ 2] 	tax
                             	; pull high byte next
ef61 : 88               [ 2] 	dey
ef62 : b9000b           [ 4] 	lda df_opstck,y
                             	; save new top of stack
ef65 : 84c0             [ 3] 	sty df_parmtop
ef67 : 18               [ 2] 	clc
ef68 : 60               [ 6] 	rts
ef69 :                       df_st_typemismatcherr
                             	SWBRK DFERR_TYPEMISM
                             
                             
                             ;****************************************
                             ;* Return type on top of stack
                             ;* Y - type
                             ;****************************************
ef6b :                       df_st_peekType
ef6b : a4c0             [ 3] 	ldy df_parmtop
AS65 Assembler for R6502 [1.42].                                     Page  180
-------------------------------- bank\bank1.s --------------------------------

ef6d : 88               [ 2] 	dey
ef6e : b9000b           [ 4] 	lda df_opstck,y
ef71 : a8               [ 2] 	tay
ef72 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Pop an int off parm stack
                             ;* X,A - int
                             ;****************************************
ef73 :                       df_st_popInt
ef73 : a001             [ 2] 	ldy #DFST_INT
ef75 : 4c52ef           [ 3] 	jmp df_st_popParmX
                             
                             ;****************************************
                             ;* Pop a string pointer off parm stack
                             ;* X,A - int
                             ;****************************************
ef78 :                       df_st_popStr
ef78 : a080             [ 2] 	ldy #DFST_STR
ef7a : 4c52ef           [ 3] 	jmp df_st_popParmX
                             	
                             ;****************************************
                             ;* Pop a general pointer off parm stack
                             ;* X,A - int
                             ;****************************************
ef7d :                       df_st_popPtr
ef7d : a0ff             [ 2] 	ldy #0xff
ef7f : 4c52ef           [ 3] 	jmp df_st_popParmX
                             	
                             	
                             ;****************************************
                             ;* Allocate space on the heap
                             ;* X, A = Number of bytes to allocate
                             ;* X, A return address of allocated space
                             ;****************************************
ef82 :                       df_st_malloc
                             	; save A in Y
ef82 : a8               [ 2] 	tay
                             	; save old starend
ef83 : a5be             [ 3] 	lda df_starend+1
ef85 : 48               [ 3] 	pha
ef86 : a5bd             [ 3] 	lda df_starend
ef88 : 48               [ 3] 	pha
                             	; restore A from Y
ef89 : 98               [ 2] 	tya
                             	; add X,A to starend
ef8a : 48               [ 3] 	pha
ef8b : 8a               [ 2] 	txa
ef8c : 18               [ 2] 	clc
ef8d : 65bd             [ 3] 	adc df_starend
ef8f : 85bd             [ 3] 	sta df_starend
ef91 : 68               [ 4] 	pla
ef92 : 65be             [ 3] 	adc df_starend+1
ef94 : 85be             [ 3] 	sta df_starend+1
                             	; return old starend as start of space
ef96 : 68               [ 4] 	pla
ef97 : aa               [ 2] 	tax
ef98 : 68               [ 4] 	pla
ef99 : 60               [ 6] 	rts
                             	
                             
                             ;****************************************
AS65 Assembler for R6502 [1.42].                                     Page  181
-------------------------------- bank\bank1.s --------------------------------

                             ;* df_init
                             ;* Initialise dflat language settings
                             ;****************************************
ef9a :                       df_init
                             	; Initialise top of memory to default
                             	; This can be overridden by himem command
ef9a : a900             [ 2] 	lda #lo(DF_MEMTOP)
ef9c : 8db90b           [ 4] 	sta df_memtop
ef9f : a9c0             [ 2] 	lda #hi(DF_MEMTOP)
efa1 : 8dba0b           [ 4] 	sta df_memtop+1
                             	
                             	; Init program space
efa4 : 20abef           [ 6] 	jsr df_clear
                             	
                             	; Initialise assembler
efa7 : 2082f9           [ 6] 	jsr asm_init
                             
efaa : 60               [ 6] 	rts
                             	
                             	
                             ;****************************************
                             ;* df_clear
                             ;* Initialise program space
                             ;****************************************
efab :                       df_clear
                             	; Start of program space
efab : a9bb             [ 2] 	lda #lo(DF_PROGSTART)
efad : 85ae             [ 3] 	sta df_prgstrt
efaf : 85b0             [ 3] 	sta df_prgend
efb1 : a90c             [ 2] 	lda #hi(DF_PROGSTART)
efb3 : 85af             [ 3] 	sta df_prgstrt+1
efb5 : 85b1             [ 3] 	sta df_prgend+1
                             	; Terminal value in prog space
efb7 : a900             [ 2] 	lda #0
efb9 : 92ae             [ 5] 	sta (df_prgstrt)
                             
                             	; Variable name table
                             	; Grows down from mem top
efbb : adb90b           [ 4] 	lda df_memtop
efbe : 85b2             [ 3] 	sta df_vntstrt
efc0 : 85b4             [ 3] 	sta df_vntend
efc2 : adba0b           [ 4] 	lda df_memtop+1
efc5 : 85b3             [ 3] 	sta df_vntstrt+1
efc7 : 85b5             [ 3] 	sta df_vntend+1
                             
                             	; Variable value table
                             	; Grows down from vnt
efc9 : a5b2             [ 3] 	lda df_vntstrt
efcb : 85b6             [ 3] 	sta df_vvtstrt
efcd : 85b8             [ 3] 	sta df_vvtend
efcf : a5b3             [ 3] 	lda df_vntstrt+1
efd1 : 85b7             [ 3] 	sta df_vvtstrt+1
efd3 : 85b9             [ 3] 	sta df_vvtend+1
                             	
                             	; No variables - zero the count
efd5 : 64ba             [ 3] 	stz df_varcnt
                             	
                             	; String accumulator
efd7 : a900             [ 2] 	lda #lo(df_raw)
efd9 : 85c3             [ 3] 	sta df_sevalptr
efdb : a909             [ 2] 	lda #hi(df_raw)
efdd : 85c4             [ 3] 	sta df_sevalptr+1
AS65 Assembler for R6502 [1.42].                                     Page  182
-------------------------------- bank\bank1.s --------------------------------

                             
efdf : 60               [ 6] 	rts
                             	
                             
                             	include "dflat\error.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  ERROR.S
                             ;*  Error handling module.
                             ;*  Whan an error is thrown using BRK, this modul
                             ;*  displaying the error plus any associated line
                             ;*  if it was running a program.  It then resets 
                             ;*  settings and takes the system back to program
                             ;*  mode.  The message uses the general IO handle
                             ;*  output will be to either screen or serial dep
                             ;*  the BBC keyboard DIP switch.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             	include "dflat\error.i"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  ERROR.I
                             ;*  Error definitions file.
                             ;*  The macro to throw an error is elswhere, but 
                             ;*  it issues a 6502 BRK commmand with the next b
                             ;*  the error code.  The BRK handler then picks u
                             ;*  code and shows the appropriate message plus a
                             ;*  number if a program was running.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
                             ; Error message numbers
0000 =                       DFERR_OK		=	0
0001 =                       DFERR_ERROR		=	1
0002 =                       DFERR_SYNTAX	=	2
0003 =                       DFERR_RUNTIME	=	3
0004 =                       DFERR_TYPEMISM	=	4
0005 =                       DFERR_DIM		=	5
0006 =                       DFERR_UNTIL		=	6
0007 =                       DFERR_NOPROC	=	7
0008 =                       DFERR_PROCPARM	=	8
0009 =                       DFERR_IMMEDIATE	=	9
000a =                       DFERR_UNCLOSEDIF=	10
000b =                       DFERR_NOIF		=	11
AS65 Assembler for R6502 [1.42].                                     Page  183
-------------------------------- bank\bank1.s --------------------------------

000c =                       DFERR_NEXTFOR	=	12
000d =                       DFERR_FNAME		=	13
000e =                       DFERR_STRLONG	=	14
000f =                       DFERR_BREAK		=	15
0010 =                       DFERR_NODATA	=	16
0011 =                       DFERR_WEND		=	17
0012 =                       DFERR_NOLINE	=	18
0013 =                       DFERR_RETURN	=	19
0014 =                       DFERR_ABORT		=	20
0015 =                       DFERR_QUANTITY	=	21
0016 =                       DFERR_NOORG		=	22
0017 =                       DFERR_ADDRMODE	=	23
                             
                             
                             
                             
                             	
                             	
                             	
                             	
                             ; Error message table, each msg null terminated
efe0 :                       df_tk_errortab
efe0 : 4f6b00                	db	"Ok", 0
efe3 : 47656e6572616c00      	db	"General", 0
efeb : 53796e74617800        	db	"Syntax", 0
eff2 : 52756e74696d6500      	db	"Runtime", 0
effa : 54797065206d69..      	db	"Type mismatch", 0
f008 : 52652d64696d00        	db	"Re-dim", 0
f00f : 4e6f2072657065..      	db	"No repeat", 0
f019 : 50726f63206e6f..      	db	"Proc not found", 0
f028 : 50726f63207061..      	db	"Proc parm mismatch", 0
f03b : 556e6578706563..      	db	"Unexpected end", 0
f04a : 556e636c6f7365..      	db	"Unclosed if", 0
f056 : 4e6f20696600          	db	"No if", 0
f05c : 4e6f20666f7200        	db	"No for", 0
f063 : 46696c656e616d..      	db	"Filename not found", 0
f076 : 537472696e6720..      	db	"String too long", 0
f086 : 427265616b00          	db	"Break", 0
f08c : 4f7574206f6620..      	db	"Out of data", 0
f098 : 4e6f207768696c..      	db	"No while", 0
f0a1 : 4e6f206c696e6500      	db	"No line", 0
f0a9 : 4e6f2072657475..      	db	"No return value", 0
f0b9 : 50726f6772616d..      	db	"Program aborted", 0
f0c9 : 4f7574206f6620..      	db	"Out of bounds", 0
f0d7 : 4e6f2061737365..      	db	"No assembly origin", 0
f0ea : 4e6f2061646472..      	db	"No addresing mode", 0
f0fc : 00                    	db	0
                             
f0fd :                       df_tk_error_inline
f0fd : 20696e206c696e..      	db	" in line ", 0
f107 :                       df_tk_error_atpos
f107 : 20706f732000          	db	" pos ", 0
f10d :                       df_tk_error_error
f10d : 206572726f7200        	db	" error", 0
                             
                             ;****************************************
                             ;* df_trap_error
                             ;* Show an error message
                             ;* errno is error number
                             ;* currlin = Line number
                             ;* exeoff = offset
                             ;* at the end jump to program editor
AS65 Assembler for R6502 [1.42].                                     Page  184
-------------------------------- bank\bank1.s --------------------------------

                             ;****************************************
f114 :                       df_trap_error
                             	; reset SP
f114 : a6a8             [ 3] 	ldx df_sp
f116 : 9a               [ 2] 	txs
                             	; set IO back to normal
f117 : 201fc4           [ 6] 	jsr io_set_default
                             	
f11a : a9e0             [ 2] 	lda #lo(df_tk_errortab)
f11c : 85d4             [ 3] 	sta df_tmpptra
f11e : a9ef             [ 2] 	lda #hi(df_tk_errortab)
f120 : 85d5             [ 3] 	sta df_tmpptra+1
f122 : a6a6             [ 3] 	ldx errno				; 0 or >=128 goes to monitor
f124 : f070             [ 3] 	beq df_trap_monitor
f126 : 306e             [ 3] 	bmi df_trap_monitor
f128 :                       df_show_err_find
f128 : e000             [ 2] 	cpx #0
f12a : f017             [ 3] 	beq df_show_err_found
                             	; If on a zero, then error table exhausted
                             	; so drop in to the monitor
f12c : b2d4             [ 5] 	lda (df_tmpptra)
f12e : f066             [ 3] 	beq df_trap_monitor
f130 :                       df_show_err_skip
                             	_incZPWord df_tmpptra
                             
f136 : b2d4             [ 5] 	lda (df_tmpptra)
f138 : d0f6             [ 3] 	bne df_show_err_skip
                             	_incZPWord df_tmpptra
                             
f140 : ca               [ 2] 	dex
f141 : 80e5             [ 3] 	bra df_show_err_find
f143 :                       df_show_err_found
f143 : a6d4             [ 3] 	ldx df_tmpptra
f145 : a5d5             [ 3] 	lda df_tmpptra+1
f147 : 2091c4           [ 6] 	jsr io_print_line
f14a : a20d             [ 2] 	ldx #lo(df_tk_error_error)
f14c : a9f1             [ 2] 	lda #hi(df_tk_error_error)
f14e : 2091c4           [ 6] 	jsr io_print_line
                             	; if line number <> 0 then print it
f151 : a001             [ 2] 	ldy #DFTK_LINNUM
f153 : b1cf             [ 5] 	lda (df_currlin),y
f155 : aa               [ 2] 	tax
f156 : c8               [ 2] 	iny
f157 : b1cf             [ 5] 	lda (df_currlin),y
f159 : c900             [ 2] 	cmp #0x00
f15b : d006             [ 3] 	bne df_show_err_linnum
f15d : e000             [ 2] 	cpx #0x00
f15f : d002             [ 3] 	bne df_show_err_linnum
f161 : 8011             [ 3] 	bra df_show_err_fin
f163 :                       df_show_err_linnum
                             	_println df_tk_error_inline
                             
f170 : 18               [ 2] 	clc
f171 : 2075c9           [ 6] 	jsr print_a_to_d
f174 :                       df_show_err_fin
f174 : a4d1             [ 3] 	ldy df_exeoff
f176 : f015             [ 3] 	beq df_show_err_done
                             	_println df_tk_error_atpos
                             
f185 : 98               [ 2] 	tya
f186 : aa               [ 2] 	tax
f187 : a900             [ 2] 	lda #0
AS65 Assembler for R6502 [1.42].                                     Page  185
-------------------------------- bank\bank1.s --------------------------------

f189 : 18               [ 2] 	clc
f18a : 2075c9           [ 6] 	jsr print_a_to_d	
f18d :                       df_show_err_done
f18d : a90d             [ 2] 	lda #UTF_CR
f18f : 2049c4           [ 6] 	jsr io_put_ch
f192 : 18               [ 2] 	clc
                             	; back to editor
f193 : 4c77d6           [ 3] 	jmp df_pg_dflat
                             
                             ; For unknown errors, jump to monitor
f196 :                       df_trap_monitor
                             	; Print PC
f196 : a950             [ 2] 	lda #'P'
f198 : 2049c4           [ 6] 	jsr io_put_ch
f19b : a943             [ 2] 	lda #'C'
f19d : 2049c4           [ 6] 	jsr io_put_ch
f1a0 : a93a             [ 2] 	lda #':'
f1a2 : 2049c4           [ 6] 	jsr io_put_ch
f1a5 : a5ac             [ 3] 	lda df_brkpc+1
f1a7 : 2003c7           [ 6] 	jsr jsrPrintA
f1aa : a5ab             [ 3] 	lda df_brkpc
f1ac : 2003c7           [ 6] 	jsr jsrPrintA
f1af : a920             [ 2] 	lda #' '
f1b1 : 2049c4           [ 6] 	jsr io_put_ch
                             
                             	; Print A
f1b4 : a941             [ 2] 	lda #'A'
f1b6 : 2049c4           [ 6] 	jsr io_put_ch
f1b9 : a93a             [ 2] 	lda #':'
f1bb : 2049c4           [ 6] 	jsr io_put_ch
f1be : a58e             [ 3] 	lda num_a
f1c0 : 2003c7           [ 6] 	jsr jsrPrintA
f1c3 : a920             [ 2] 	lda #' '
f1c5 : 2049c4           [ 6] 	jsr io_put_ch
                             
                             	; Print X
f1c8 : a958             [ 2] 	lda #'X'
f1ca : 2049c4           [ 6] 	jsr io_put_ch
f1cd : a93a             [ 2] 	lda #':'
f1cf : 2049c4           [ 6] 	jsr io_put_ch
f1d2 : a58f             [ 3] 	lda num_a+1
f1d4 : 2003c7           [ 6] 	jsr jsrPrintA
f1d7 : a920             [ 2] 	lda #' '
f1d9 : 2049c4           [ 6] 	jsr io_put_ch
                             
                             	; Print Y
f1dc : a959             [ 2] 	lda #'Y'
f1de : 2049c4           [ 6] 	jsr io_put_ch
f1e1 : a93a             [ 2] 	lda #':'
f1e3 : 2049c4           [ 6] 	jsr io_put_ch
f1e6 : a590             [ 3] 	lda num_a+2
f1e8 : 2003c7           [ 6] 	jsr jsrPrintA
f1eb : a90d             [ 2] 	lda #UTF_CR
f1ed : 2049c4           [ 6] 	jsr io_put_ch
                             	
f1f0 : 200adf           [ 6] 	jsr df_rt_monitor
                             	; back to editor
f1f3 : 4c77d6           [ 3] 	jmp df_pg_dflat
                             
                             	include	"dflat\asm.s"
                             ;************************************************
                             ;*
AS65 Assembler for R6502 [1.42].                                     Page  186
-------------------------------- bank\bank1.s --------------------------------

                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  ASM.S
                             ;*  This is the main controller code file for the
                             ;*  This file includes all the required source fi
                             ;*	in addition to dflat.s
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
f1f6 :                       mod_sz_asm_s
                             
                             	;	dflat.s is already included, so just the addit
                             	include "dflat\asm.i"
                             ;*	BBC-128 BREADBOARD COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             
                             ;* Addressing modes - 15 in total, 16 with direct
                             ;*  0   Nothing
                             ;*	1 	Absolute			XXX <word>
                             ;*	2 	Absolute,X			XXX <word>,x
                             ;*	3 	Absolute,Y			XXX <word>,y
                             ;*	4	Zeropage			XXX	<byte>
                             ;*	5	Zeropage,X			XXX	<byte>,x
                             ;*	6	Zeropage,Y			XXX	<byte>,y
                             ;*	7	Indirect			XXX	(<byte>)
                             ;*	8	Indirect,X			XXX	(<byte>,x)
                             ;*	9	Indirect,Y			XXX	(<byte>),y
                             ;*	A	Absolute indirect	XXX	(<word>)
                             ;*	B	Absolute indirect,x	XXX	(<word>,x)
                             ;*	C	Immediate			XXX #<byte>
                             ;*	D	Accumulator			XXX (same as implied)
                             ;*	E	Implied				XXX
                             ;*	F	Relative			XXX	<byte>
                             ;*	10	Assembler directive	XXX .......
                             
0000 =                       AM_NONE		= 0
0001 =                       AM_ABS	 	= 1
0002 =                       AM_ABSX		= 2
0003 =                       AM_ABSY		= 3
0004 =                       AM_ZP		= 4
0005 =                       AM_ZPX		= 5
0006 =                       AM_ZPY		= 6
0007 =                       AM_ZPIND	= 7
0008 =                       AM_ZPINDX	= 8
0009 =                       AM_ZPINDY	= 9
000a =                       AM_ABSIND	= 10
000b =                       AM_ABSINDX	= 11
000c =                       AM_IMM		= 12
000d =                       AM_ACC		= 13
000d =                       AM_IMP		= AM_ACC
000f =                       AM_REL		= 15
0010 =                       AM_DIR		= 16
AS65 Assembler for R6502 [1.42].                                     Page  187
-------------------------------- bank\bank1.s --------------------------------

                             
                             
                             
                             	include "dflat\tkasm.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  ASM.S
                             ;*	Module that implements tokenisation of the ass
                             ;* 	The assembler is an extension to dflat, almos
                             ;*	almost a language within a language, as it has
                             ;*	own symbol tables to allow adding new keywords
                             ;*	running out of space in the main symtol table 
                             ;*	for normal 6502 asembler syntax which is at od
                             ;*	regular dflat.
                             ;*	Hence, this module has to do its own additiona
                             ;*	to tokenise the assembly.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
f1f6 :                       mod_sz_tkasm_s
                             
                             	; if didn't find regular keywords then try assen
f1f6 :                       df_tk_asm_parse_command
                             	; skip the white space after the dot
f1f6 : 20c9cd           [ 6] 	jsr df_tk_skip_ws
                             	; find the assembler symbol
f1f9 : 2025f2           [ 6] 	jsr df_tk_asm_matchtok
                             	; if not found then must be a label assignment
f1fc : b021             [ 4] 	bcs df_tk_asm_parse_command_symbol
                             	; Get the assembler symbol and put the token
f1fe : a5cc             [ 3] 	lda df_symoff
                             	; Set the MSB
f200 : 0980             [ 2] 	ora #0x80
f202 : 206fcd           [ 6] 	jsr df_tk_put_tok
                             	; check the first addressing mode code
                             	; remember to jump over the offset byte
f205 : a001             [ 2] 	ldy #1
f207 : b1ca             [ 5] 	lda (df_symtab),y
                             	; Directive?
f209 : c910             [ 2] 	cmp #AM_DIR
f20b : d00c             [ 3] 	bne df_tk_asm_mnemonic
                             	; if directive then process it
f20d : a5cc             [ 3] 	lda df_symoff
f20f : 2076f2           [ 6] 	jsr df_tk_asm_exec_parser
f212 : b004             [ 3] 	bcs df_tk_asm_parse_command_err
                             	; [1] ignore white space but keep it
f214 : 20c9cd           [ 6] 	jsr df_tk_skip_ws
                             	; No error in parsing this command
f217 : 18               [ 2] 	clc
f218 :                       df_tk_asm_parse_command_err
f218 : 60               [ 6] 	rts
f219 :                       df_tk_asm_mnemonic
                             	; for all nmemonics, work out the addressing mod
AS65 Assembler for R6502 [1.42].                                     Page  188
-------------------------------- bank\bank1.s --------------------------------

f219 : 207bf2           [ 6] 	jsr df_tk_asm_addr_mode
f21c : b0fa             [ 3] 	bcs df_tk_asm_parse_command_err
f21e : 60               [ 6] 	rts
f21f :                       df_tk_asm_parse_command_symbol
                             	; No mask
f21f : a900             [ 2] 	lda #0
f221 : 20bbce           [ 6] 	jsr df_tk_var
f224 : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* df_tk_asm_matchtok
                             ;* Try and find a token match against the table d
                             ;* Input:
                             ;*			Current df_linbuff and df_linoff
                             ;* Return: 	CC = No Error, CS = Error
                             ;*			df_linoff points to next char if CC else unc
                             ;****************************************
f225 :                       df_tk_asm_matchtok
                             	; Start at token symbols beginning
f225 : a902             [ 2] 	lda #lo(df_asm_tokensyms)
f227 : 85ca             [ 3] 	sta df_symtab
f229 : a9f6             [ 2] 	lda #hi(df_asm_tokensyms)
f22b : 85cb             [ 3] 	sta df_symtab+1
f22d : 64cc             [ 3] 	stz df_symoff
f22f :                       df_tk_asm_checknexttok
                             	; From the line buffer current pointer
                             	; Check for a token match
f22f : a4c5             [ 3] 	ldy df_linoff
f231 :                       df_tk_asm_checktokch
                             	; Get symtable char
f231 : b2ca             [ 5] 	lda (df_symtab)
                             	; if less than ascii ' ' then reached end of
                             	; this symbol and everything matched so found!
f233 : c920             [ 2] 	cmp #' '
f235 : 9031             [ 3] 	bcc df_tk_asm_symfound
                             	; Else compare with current line buffer char
f237 : d90009           [ 4] 	cmp df_linbuff,y
                             	; If chars not match then this symbol fails
f23a : d009             [ 3] 	bne df_tk_asm_symnomatch
                             	; else more chars to match
                             	; so increment line buffer pointers
                             	_incZPWord df_symtab
                             
f242 : c8               [ 2] 	iny
f243 : 80ec             [ 3] 	bra df_tk_asm_checktokch
f245 :                       df_tk_asm_symnomatch
                             	; Increment symbol counter to next symbol
f245 : e6cc             [ 5] 	inc df_symoff
f247 :                       df_tk_asm_symnextentry
f247 : b2ca             [ 5] 	lda (df_symtab)
                             	; End of symbol is < ' '
f249 : c920             [ 2] 	cmp #' '
f24b : 9008             [ 3] 	bcc  df_tk_asm_foundsymend
                             	_incZPWord df_symtab
                             
f253 : 80f2             [ 3] 	bra df_tk_asm_symnextentry
f255 :                       df_tk_asm_foundsymend
                             	; Now at the offset to jump over addressing
                             	; mode and opcode values. Add offset to ptr
                             	; remember than C is clear and A has offset
                             	; set C so always jump over the offset
AS65 Assembler for R6502 [1.42].                                     Page  189
-------------------------------- bank\bank1.s --------------------------------

f255 : 38               [ 2] 	sec
f256 : 65ca             [ 3] 	adc df_symtab
f258 : 85ca             [ 3] 	sta df_symtab
f25a : a5cb             [ 3] 	lda df_symtab+1
f25c : 6900             [ 2] 	adc #0
f25e : 85cb             [ 3] 	sta df_symtab+1
                             	; If next char is not zero then
                             	; try and match with line buffer
f260 : b2ca             [ 5] 	lda (df_symtab)
f262 : d0cb             [ 3] 	bne df_tk_asm_checknexttok
                             	; else symbol table exhausted
                             	; so no match found
                             	; Zero symbol counter
f264 : 64cc             [ 3] 	stz df_symoff
                             	; Set C to indicate error (no match)
f266 : 38               [ 2] 	sec
f267 : 60               [ 6] 	rts
f268 :                       df_tk_asm_symfound
                             	; Full match with keyword in symtable but
                             	; check the next buffer char is not alphanum
                             	; as this could be part of a symbol
                             	; Point to next buffer char in any case
                             	; y already points to char after keyword
f268 : b90009           [ 4] 	lda df_linbuff,y
                             	; if it is an alphanum then
f26b : 20b7cd           [ 6] 	jsr df_tk_isalphanum
                             	; do not count as a match
f26e : b0d5             [ 3] 	bcs df_tk_asm_symnomatch
                             	; Save line buffer pointer (points to next char)
                             	; Clear C to indicate success (match)
f270 : 84c5             [ 3] 	sty df_linoff
f272 : a5cc             [ 3] 	lda df_symoff
                             	; df_symtab points to the offset
f274 : 18               [ 2] 	clc
f275 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* df_tk_asm_exec_parser
                             ;* Execute parse routine for this statement
                             ;* Input: a is the token found
                             ;* Return: CC = Parsed ok, CS = Error
                             ;****************************************
f276 :                       df_tk_asm_exec_parser
f276 : 0a               [ 2] 	asl a
f277 : aa               [ 2] 	tax
f278 : 7c6ef9           [ 6] 	jmp (df_tk_asm_tokenjmp,x)
                             
                             
                             ;****************************************
                             ;* df_tk_asm_addr_mode
                             ;* Tokenise the addressing mode
                             ;* Input: a is the token found
                             ;* Return: CC = Parsed ok, CS = Error
                             ;****************************************
f27b :                       df_tk_asm_addr_mode
f27b : 20c9cd           [ 6] 	jsr df_tk_skip_ws		;Skip whitespace
f27e : c900             [ 2] 	cmp #0					;End of line?
f280 : f02e             [ 3] 	beq df_tk_asm_addr_mode_ok
f282 : c93a             [ 2] 	cmp #':'				;End of statement?
f284 : f02a             [ 3] 	beq df_tk_asm_addr_mode_ok
f286 : a923             [ 2] 	lda #'#'				; Check for immediate
f288 : 20fecd           [ 6] 	jsr df_tk_expect_tok
AS65 Assembler for R6502 [1.42].                                     Page  190
-------------------------------- bank\bank1.s --------------------------------

f28b : b003             [ 3] 	bcs df_tk_asm_addr_mode_1
f28d : 4cb2f2           [ 3] 	jmp df_tk_imm		; Process immediate
f290 :                       df_tk_asm_addr_mode_1
f290 : a928             [ 2] 	lda #'('				; One of indirect modes?
f292 : 20fecd           [ 6] 	jsr df_tk_expect_tok
f295 : b003             [ 3] 	bcs df_tk_asm_addr_mode_2
f297 : 4cb7f2           [ 3] 	jmp df_tk_indirect
f29a :                       df_tk_asm_addr_mode_2
                             	; here just a regular address
                             	; Just one expression expected
f29a : 20e4cf           [ 6] 	jsr df_tk_expression
                             	; Is there a comma after the expression
f29d : a92c             [ 2] 	lda #','
f29f : 20fecd           [ 6] 	jsr df_tk_expect_tok
f2a2 : b00c             [ 3] 	bcs df_tk_asm_addr_mode_ok
                             	; must be x or y
f2a4 : a978             [ 2] 	lda #'x'
f2a6 : 20fecd           [ 6] 	jsr df_tk_expect_tok
f2a9 : 9005             [ 3] 	bcc df_tk_asm_addr_mode_ok
                             	; got to here, must be y
f2ab : a979             [ 2] 	lda #'y'
f2ad : 200bce           [ 6] 	jsr df_tk_expect_tok_err
f2b0 :                       df_tk_asm_addr_mode_ok
f2b0 : 18               [ 2] 	clc
f2b1 : 60               [ 6] 	rts
                             	
                             	
                             ;* Toeknise immediate addressing mode	
f2b2 :                       df_tk_imm
                             	; Just one expression expected
f2b2 : 20e4cf           [ 6] 	jsr df_tk_expression
f2b5 : 18               [ 2] 	clc
f2b6 : 60               [ 6] 	rts
                             	
                             ;* Tokenise indirect
f2b7 :                       df_tk_indirect
                             	; Just one expression expected
f2b7 : 20e4cf           [ 6] 	jsr df_tk_expression
                             	; Is there a comma after the expression
f2ba : a92c             [ 2] 	lda #','
f2bc : 20fecd           [ 6] 	jsr df_tk_expect_tok
                             	; if not then might be indirect Y
f2bf : b00c             [ 3] 	bcs df_tk_indirect_y
                             	; Else must have be indirect "x)"
f2c1 : a978             [ 2] 	lda #'x'
f2c3 : 200bce           [ 6] 	jsr df_tk_expect_tok_err
f2c6 : a929             [ 2] 	lda #')'
f2c8 : 200bce           [ 6] 	jsr df_tk_expect_tok_err
f2cb : 18               [ 2] 	clc
f2cc : 60               [ 6] 	rts
                             	
f2cd :                       df_tk_indirect_y
                             	; Definitely has a close bracket
f2cd : a929             [ 2] 	lda #')'
f2cf : 200bce           [ 6] 	jsr df_tk_expect_tok_err
                             	; Is there a comma after the expression
f2d2 : a92c             [ 2] 	lda #','
f2d4 : 20fecd           [ 6] 	jsr df_tk_expect_tok
f2d7 : b007             [ 3] 	bcs df_tk_indirect_done
                             	; if comma then must be indirect y
f2d9 : a979             [ 2] 	lda #'y'
f2db : 200bce           [ 6] 	jsr df_tk_expect_tok_err
AS65 Assembler for R6502 [1.42].                                     Page  191
-------------------------------- bank\bank1.s --------------------------------

f2de : 18               [ 2] 	clc
f2df : 60               [ 6] 	rts
                             
f2e0 :                       df_tk_indirect_done
f2e0 : 18               [ 2] 	clc
f2e1 : 60               [ 6] 	rts
                             	
                             
                             	
                             
                             
                             ;************************************************
                             ;*           TOKENISATION SUBROUTINES
                             ;************************************************
                             
                             
                             ;* HANDLE DIRECTIVES
                             
                             ;* All tokenisation is part of regular toksub rou
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
f2e2 :                       mod_sz_tkasm_e
                             
                             
                             	include "dflat\rtasm.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  RTASM.S
                             ;*  Module that implements the runtime execution 
                             ;*  assembler.
AS65 Assembler for R6502 [1.42].                                     Page  192
-------------------------------- bank\bank1.s --------------------------------

                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
f2e2 :                       mod_sz_rtasm_s
                             
f2e2 :                       df_rt_asm_assemble
                             	; check if >=0x80 (directive or mnemonic)
f2e2 : a4d1             [ 3] 	ldy df_exeoff
f2e4 : b1cf             [ 5] 	lda (df_currlin),y
f2e6 : c980             [ 2] 	cmp #0x80
f2e8 : 9008             [ 3] 	bcc df_rt_asm_do_label
f2ea : 20f6f2           [ 6] 	jsr df_rt_asm_command
f2ed : 20e8f4           [ 6] 	jsr df_rt_asm_printCR
f2f0 : 8003             [ 3] 	bra df_rt_asm_assemble_done
f2f2 :                       df_rt_asm_do_label
f2f2 : 2010f3           [ 6] 	jsr df_rt_asm_label
f2f5 :                       df_rt_asm_assemble_done
                             	; any clean up here
f2f5 : 60               [ 6] 	rts
                             
                             ; Jump to mnemonic or 
                             ; directive with index in A ignoring MSB
f2f6 :                       df_rt_asm_command
f2f6 : 297f             [ 2] 	and #0x7f
f2f8 : 48               [ 3] 	pha
f2f9 : aa               [ 2] 	tax
                             	; Point to Xth symtable entry of addr modes and 
f2fa : 20b6f5           [ 6] 	jsr df_rt_asm_skip_to_sym
                             
                             	; Get first addressing mode (ignoring offset byt
f2fd : a001             [ 2] 	ldy #1
f2ff : b1ca             [ 5] 	lda (df_symtab),y
                             	; is it a directive?
f301 : c910             [ 2] 	cmp #AM_DIR
                             	; if directive
f303 : f003             [ 3] 	beq df_rt_asm_dir
                             	; Else must be a normal mnemonic
f305 : 4cd3f3           [ 3] 	jmp df_rt_asm_mnem
                             
                             ; Jump to the appropriate directive
f308 :                       df_rt_asm_dir
                             	; Get the index and *2
                             	; to get jump vector
f308 : 68               [ 4] 	pla
f309 : 0a               [ 2] 	asl a
f30a : aa               [ 2] 	tax
                             	; jump over directive code
f30b : e6d1             [ 5] 	inc df_exeoff
                             	; jump to directive handler
f30d : 7c78f9           [ 6] 	jmp (df_rt_asm_tokenjmp,x)
                             
                             ; Process label
                             ; Set the label to the PC
f310 :                       df_rt_asm_label
                             	; Get the address of the variable in A,X
f310 : 203de4           [ 6] 	jsr df_rt_generate_lvar
f313 : 86f1             [ 3] 	stx df_asmoprnd
f315 : 85f2             [ 3] 	sta df_asmoprnd+1
                             	; Assign to value of PC
AS65 Assembler for R6502 [1.42].                                     Page  193
-------------------------------- bank\bank1.s --------------------------------

f317 : a5ec             [ 3] 	lda df_asmpc
f319 : 92f1             [ 5] 	sta (df_asmoprnd)
f31b : a001             [ 2] 	ldy #1
f31d : a5ed             [ 3] 	lda df_asmpc+1
f31f : 91f1             [ 5] 	sta (df_asmoprnd),y
f321 : 60               [ 6] 	rts	
                             
                             ;* Set the code origin
f322 :                       df_rt_asm_org
                             	; Get the address from expression
f322 : 2095f5           [ 6] 	jsr df_rt_asm_get_operand
                             	; Put this in to PC
f325 : a5f1             [ 3] 	lda df_asmoprnd
f327 : 85ec             [ 3] 	sta df_asmpc
f329 : a5f2             [ 3] 	lda df_asmoprnd+1
f32b : 85ed             [ 3] 	sta df_asmpc+1
f32d : a903             [ 2] 	lda #3
f32f : 85f3             [ 3] 	sta df_asmlen
f331 : 20a4f4           [ 6] 	jsr df_rt_asm_printPC
f334 : 60               [ 6] 	rts
                             
                             ; Set the assembly option
                             ; Bit 0 set = Print code to console
                             ; But 1 set = Write code to memory
                             ; Be sure to run 2 non-write passes
                             ; before a write pass
                             ; First pass may result in ZP used a lot
                             ; Second pass resolves forward refs to ABS
                             ; Final write pass then stores the code
f335 :                       df_rt_asm_opt
                             	; Get the value from expression
f335 : 2095f5           [ 6] 	jsr df_rt_asm_get_operand
                             	; Put this in to OPT
f338 : a5f1             [ 3] 	lda df_asmoprnd
f33a : 85ee             [ 3] 	sta df_asmopt
f33c : 60               [ 6] 	rts
                             
                             ; dw and db handled here
                             ; keep going through comma separated
                             ; list and write bytes or words
                             ; string expansion also handled
f33d :                       df_rt_asm_db
f33d : a902             [ 2] 	lda #2
f33f : 85f3             [ 3] 	sta df_asmlen
f341 : 8004             [ 3] 	bra df_rt_asm_db_start
f343 :                       df_rt_asm_dw
f343 : a903             [ 2] 	lda #3
f345 : 85f3             [ 3] 	sta df_asmlen
f347 :                       df_rt_asm_db_start
f347 : 20a4f4           [ 6] 	jsr df_rt_asm_printPC
f34a : 20c1f4           [ 6] 	jsr df_rt_asm_printSPC
f34d :                       df_rt_asm_data
f34d : 2061d7           [ 6] 	jsr df_rt_neval		; Evaluate expression
f350 : 206bef           [ 6] 	jsr df_st_peekType	; What is the type
f353 : c080             [ 2] 	cpy #0x80			; If string
f355 : b00c             [ 3] 	bcs df_rt_asm_string
f357 : 2073ef           [ 6] 	jsr df_st_popInt	; else get number in A,X
f35a : 86f1             [ 3] 	stx df_asmoprnd		; store low value
f35c : 85f2             [ 3] 	sta df_asmoprnd+1	; store high value
f35e : 2087f3           [ 6] 	jsr df_rt_asm_data_write
f361 : 801a             [ 3] 	bra df_rt_asm_data_next
f363 :                       df_rt_asm_string
AS65 Assembler for R6502 [1.42].                                     Page  194
-------------------------------- bank\bank1.s --------------------------------

f363 : 207def           [ 6] 	jsr df_st_popPtr	; pop string pointer
f366 : 86d4             [ 3] 	stx df_tmpptra		; save pointer to tmpa
f368 : 85d5             [ 3] 	sta df_tmpptra+1
f36a :                       df_rt_asm_string_ch
f36a : b2d4             [ 5] 	lda (df_tmpptra)	; Get string char, 0=done
f36c : f00f             [ 3] 	beq df_rt_asm_data_next
f36e : 85f1             [ 3] 	sta df_asmoprnd		; Save as operand
f370 : 86f2             [ 3] 	stx df_asmoprnd+1	; High is always zero
f372 : 2087f3           [ 6] 	jsr df_rt_asm_data_write
                             	_incZPWord df_tmpptra
                             
f37b : 80ed             [ 3] 	bra df_rt_asm_string_ch
f37d :                       df_rt_asm_data_next
f37d : 206ae4           [ 6] 	jsr df_rt_eos		; End?
f380 : b004             [ 3] 	bcs df_rt_asm_data_done
f382 : e6d1             [ 5] 	inc df_exeoff		; Jump over ','
f384 : 80c7             [ 3] 	bra df_rt_asm_data
f386 :                       df_rt_asm_data_done
f386 : 60               [ 6] 	rts	
                             
                             ; Write one db or dw value
                             ; Check for value too big for db
                             ; Advance PC by df_asmlen
f387 :                       df_rt_asm_data_write
f387 : 20cdf4           [ 6] 	jsr df_rt_asm_printOPR
f38a :                       df_rt_asm_data_write_skip1
f38a : a902             [ 2] 	lda #2
f38c : 25ee             [ 3] 	and df_asmopt
f38e : f014             [ 3] 	beq df_rt_asm_data_write_skip2
f390 : a5f1             [ 3] 	lda df_asmoprnd
f392 : 92ec             [ 5] 	sta (df_asmpc)
f394 : a001             [ 2] 	ldy #1
f396 : a902             [ 2] 	lda #2
f398 : c5f3             [ 3] 	cmp df_asmlen
f39a : f004             [ 3] 	beq df_rt_asm_data_write_hi
f39c : a5f2             [ 3] 	lda df_asmoprnd+1
f39e : d013             [ 3] 	bne df_rt_asm_data_write_err
f3a0 :                       df_rt_asm_data_write_hi
f3a0 : a5f2             [ 3] 	lda df_asmoprnd+1
f3a2 : 91ec             [ 5] 	sta (df_asmpc),y
f3a4 :                       df_rt_asm_data_write_skip2
f3a4 : a5f3             [ 3] 	lda df_asmlen
f3a6 : 3a               [ 2] 	dec a				; Add 1 less!
f3a7 : 18               [ 2] 	clc
f3a8 : 65ec             [ 3] 	adc df_asmpc
f3aa : 85ec             [ 3] 	sta df_asmpc
f3ac : a5ed             [ 3] 	lda df_asmpc+1
f3ae : 6900             [ 2] 	adc #0
f3b0 : 85ed             [ 3] 	sta df_asmpc+1
f3b2 : 60               [ 6] 	rts
f3b3 :                       df_rt_asm_data_write_err	
                             	SWBRK DFERR_QUANTITY
                             
                             	
                             	
f3b5 :                       df_rt_asm_ds
f3b5 : 20a4f4           [ 6] 	jsr df_rt_asm_printPC
f3b8 : 20c1f4           [ 6] 	jsr df_rt_asm_printSPC
                             	; Get the address from expression
f3bb : 2095f5           [ 6] 	jsr df_rt_asm_get_operand
                             	; ADD this in to PC
f3be : 18               [ 2] 	clc
AS65 Assembler for R6502 [1.42].                                     Page  195
-------------------------------- bank\bank1.s --------------------------------

f3bf : a5f1             [ 3] 	lda df_asmoprnd
f3c1 : 65ec             [ 3] 	adc df_asmpc
f3c3 : 85ec             [ 3] 	sta df_asmpc
f3c5 : a5f2             [ 3] 	lda df_asmoprnd+1
f3c7 : 65ed             [ 3] 	adc df_asmpc+1
f3c9 : 85ed             [ 3] 	sta df_asmpc+1
                             	; len=1 for printing
f3cb : a903             [ 2] 	lda #3
f3cd : 85f3             [ 3] 	sta df_asmlen
f3cf : 20cdf4           [ 6] 	jsr df_rt_asm_printOPR
f3d2 : 60               [ 6] 	rts
                             
                             
                             ; Process a normal assembler mnemonic
f3d3 :                       df_rt_asm_mnem
f3d3 : 68               [ 4] 	pla				; Throw away previous temp variable
                             	; jump over mnemonic code
f3d4 : e6d1             [ 5] 	inc df_exeoff
                             	; work out the addressing mode and get operand
f3d6 : 201af5           [ 6] 	jsr df_rt_asm_addrmode
                             
f3d9 :                       df_rt_asm_mnem_try
f3d9 : a5ef             [ 3] 	lda df_asmadmd					; With the addressing mode
f3db : 20a0f5           [ 6] 	jsr df_rt_asm_find_addr_mode	; Find it for this 
f3de : c900             [ 2] 	cmp #AM_NONE					; Exists?
f3e0 : d014             [ 3] 	bne	df_rt_asm_mnem_chk			; If does then check it
f3e2 :                       df_rt_asm_check_alt
f3e2 : a6ef             [ 3] 	ldx df_asmadmd					; Use ad mode as an index
f3e4 : bdf1f5           [ 4] 	lda df_asm_altaddrmode,x		; Else get alternate
f3e7 : c900             [ 2] 	cmp #AM_NONE					; Is there an alternate?
f3e9 : f02e             [ 4] 	beq df_rt_asm_mnem_err			; If no then error
f3eb : 20a0f5           [ 6] 	jsr df_rt_asm_find_addr_mode	; Check does mode e
f3ee : c900             [ 2] 	cmp #AM_NONE					; this instruction
f3f0 : f027             [ 4] 	beq df_rt_asm_mnem_err			; if no then error
f3f2 : c5ef             [ 3] 	cmp df_asmadmd					; Same as the original?
f3f4 : f00e             [ 4] 	beq df_rt_asm_mnem_done			; if so then done
f3f6 :                       df_rt_asm_mnem_chk
f3f6 : 85ef             [ 3] 	sta df_asmadmd					; This is the final mode
f3f8 : aa               [ 2] 	tax								; Get the length
f3f9 : bde0f5           [ 4] 	lda df_asm_length,x
f3fc : a6f2             [ 3] 	ldx df_asmoprnd+1				; Is operand hi non-zero?
f3fe : f004             [ 4] 	beq df_rt_asm_mnem_done			; If zero then done
f400 : c903             [ 2] 	cmp #3							; Else must be len 3?
f402 : d0de             [ 4] 	bne df_rt_asm_check_alt			; Try an alternate
f404 :                       df_rt_asm_mnem_done
f404 : a6ef             [ 3] 	ldx df_asmadmd					; Get the final mode index
f406 : bde0f5           [ 4] 	lda df_asm_length,x				; Get the length
f409 : 85f3             [ 3] 	sta df_asmlen
f40b : a5ef             [ 3] 	lda df_asmadmd					; Get the final mode
f40d : 20a0f5           [ 6] 	jsr df_rt_asm_find_addr_mode	; Get the Y index o
                             	; Ok now get the opcode
f410 : c8               [ 2] 	iny
f411 : b1ca             [ 5] 	lda (df_symtab),y
f413 : 85f0             [ 3] 	sta df_asmopcde
                             	; Now have all information to assemble
f415 : 201bf4           [ 6] 	jsr df_rt_asm_encode
                             	
f418 : 60               [ 6] 	rts
f419 :                       df_rt_asm_mnem_err
                             	SWBRK DFERR_ADDRMODE
                             
                             	
AS65 Assembler for R6502 [1.42].                                     Page  196
-------------------------------- bank\bank1.s --------------------------------

                             ; Take assembler data and encode it
                             ; depending on the current option
                             ; Option 0 = No write
                             ; Option 1 = No write, Print
                             ; Option 2 = Write
                             ; Option 3 = Write, Print
f41b :                       df_rt_asm_encode
                             	; If relative then need to calculate offset
f41b : a5ef             [ 3] 	lda df_asmadmd
f41d : c90f             [ 2] 	cmp #AM_REL
f41f : d034             [ 3] 	bne df_rt_asm_encode_skiprel
                             	; If high byte is 0 then do nothing
f421 : a5f2             [ 3] 	lda df_asmoprnd+1
f423 : f030             [ 3] 	beq df_rt_asm_encode_skiprel
                             	; else calculate distance from PC
                             	; first take 2 off operand
f425 : 38               [ 2] 	sec
f426 : a5f1             [ 3] 	lda df_asmoprnd
f428 : e902             [ 2] 	sbc #2
f42a : 85f1             [ 3] 	sta df_asmoprnd
f42c : a5f2             [ 3] 	lda df_asmoprnd+1
f42e : e900             [ 2] 	sbc #0
f430 : 85f2             [ 3] 	sta df_asmoprnd+1
                             	; now calculate current operand-PC
f432 : 38               [ 2] 	sec
f433 : a5f1             [ 3] 	lda df_asmoprnd
f435 : e5ec             [ 3] 	sbc df_asmpc
f437 : 85f1             [ 3] 	sta df_asmoprnd
f439 : a5f2             [ 3] 	lda df_asmoprnd+1
f43b : e5ed             [ 3] 	sbc df_asmpc+1
                             	; put 0 in high operand storage
                             	; but A contains result of subtraction
                             	; so check that for out of range
f43d : 64f2             [ 3] 	stz df_asmoprnd+1
                             	; detect too far; high byte is either 0 or 255
                             	; else it's an error
f43f : c900             [ 2] 	cmp #0
f441 : f00a             [ 3] 	beq df_rt_asm_encode_relpos
f443 : c9ff             [ 2] 	cmp #0xff
f445 : d00a             [ 3] 	bne df_rt_asm_encode_relfar
                             	; if high is ff then low must be same -ve
f447 : a5f1             [ 3] 	lda df_asmoprnd
f449 : 300a             [ 3] 	bmi df_rt_asm_encode_skiprel
                             	; else error
f44b : 8004             [ 3] 	bra df_rt_asm_encode_relfar
f44d :                       df_rt_asm_encode_relpos
                             	; if high is 00 then low must be same +ve
f44d : a5f1             [ 3] 	lda df_asmoprnd
f44f : 1004             [ 3] 	bpl df_rt_asm_encode_skiprel
                             	; else error
f451 :                       df_rt_asm_encode_relfar
                             	; set to non-zero value
f451 : a9ff             [ 2] 	lda #0xff
f453 : 85f2             [ 3] 	sta df_asmoprnd+1
f455 :                       df_rt_asm_encode_skiprel
                             	; Only write the code if bit 1=1
f455 : a902             [ 2] 	lda #0x02
f457 : 25ee             [ 3] 	and df_asmopt
f459 : f027             [ 3] 	beq df_rt_asm_encode_print
f45b : a000             [ 2] 	ldy #0
f45d : a5f0             [ 3] 	lda df_asmopcde
f45f : 91ec             [ 5] 	sta (df_asmpc),y
AS65 Assembler for R6502 [1.42].                                     Page  197
-------------------------------- bank\bank1.s --------------------------------

f461 : a5f3             [ 3] 	lda df_asmlen
f463 : c901             [ 2] 	cmp #1						; No operand
f465 : f01b             [ 3] 	beq df_rt_asm_encode_print
f467 : c903             [ 2] 	cmp #3						; Word operand
f469 : f00d             [ 3] 	beq df_rt_asm_encode_writeword
                             	; byte operand, high byte must be zero
f46b : a5f2             [ 3] 	lda df_asmoprnd+1
f46d : f002             [ 3] 	beq df_rt_asm_encode_writebyte
                             	SWBRK DFERR_QUANTITY
                             
f471 :                       df_rt_asm_encode_writebyte
f471 : c8               [ 2] 	iny 
f472 : a5f1             [ 3] 	lda df_asmoprnd
f474 : 91ec             [ 5] 	sta (df_asmpc),y
f476 : 800a             [ 3] 	bra df_rt_asm_encode_print
f478 :                       df_rt_asm_encode_writeword
f478 : c8               [ 2] 	iny 
f479 : a5f1             [ 3] 	lda df_asmoprnd
f47b : 91ec             [ 5] 	sta (df_asmpc),y
f47d : c8               [ 2] 	iny 
f47e : a5f2             [ 3] 	lda df_asmoprnd+1
f480 : 91ec             [ 5] 	sta (df_asmpc),y	
f482 :                       df_rt_asm_encode_print
f482 : 2094f4           [ 6] 	jsr df_rt_asm_print_mmen
                             	; advance pc
f485 : 18               [ 2] 	clc
f486 : a5ec             [ 3] 	lda df_asmpc
f488 : 65f3             [ 3] 	adc df_asmlen
f48a : 85ec             [ 3] 	sta df_asmpc
f48c : a5ed             [ 3] 	lda df_asmpc+1
f48e : 6900             [ 2] 	adc #0
f490 : 85ed             [ 3] 	sta df_asmpc+1
f492 : 18               [ 2] 	clc
f493 : 60               [ 6] 	rts
                             
                             
                             ; Print the full 1,2,3 byte instruction
                             ; depends on df_asmopt
f494 :                       df_rt_asm_print_mmen
f494 : 20a4f4           [ 6] 	jsr df_rt_asm_printPC
f497 : 20c1f4           [ 6] 	jsr df_rt_asm_printSPC
f49a : 20b5f4           [ 6] 	jsr df_rt_asm_printOPC
f49d : 20c1f4           [ 6] 	jsr df_rt_asm_printSPC
f4a0 : 20cdf4           [ 6] 	jsr df_rt_asm_printOPR
f4a3 :                       df_rt_asm_print_rts			; Hopefull subs can get her
f4a3 : 60               [ 6] 	rts
                             
f4a4 :                       df_rt_asm_printPC
                             	; Check the option bit 0 (Print)
f4a4 : a901             [ 2] 	lda #0x01
f4a6 : 25ee             [ 3] 	and df_asmopt
f4a8 : f0f9             [ 3] 	beq df_rt_asm_print_rts
                             	; Print current PC
f4aa : a5ed             [ 3] 	lda df_asmpc+1
f4ac : 2003c7           [ 6] 	jsr jsrPrintA
f4af : a5ec             [ 3] 	lda df_asmpc
f4b1 : 2003c7           [ 6] 	jsr jsrPrintA
f4b4 : 60               [ 6] 	rts
                             
f4b5 :                       df_rt_asm_printOPC
                             	; Check the option bit 0 (Print)
f4b5 : a901             [ 2] 	lda #0x01
AS65 Assembler for R6502 [1.42].                                     Page  198
-------------------------------- bank\bank1.s --------------------------------

f4b7 : 25ee             [ 3] 	and df_asmopt
f4b9 : f0e8             [ 3] 	beq df_rt_asm_print_rts
f4bb : a5f0             [ 3] 	lda df_asmopcde
f4bd : 2003c7           [ 6] 	jsr jsrPrintA
f4c0 : 60               [ 6] 	rts
                             
f4c1 :                       df_rt_asm_printSPC
                             	; Check the option bit 0 (Print)
f4c1 : a901             [ 2] 	lda #0x01
f4c3 : 25ee             [ 3] 	and df_asmopt
f4c5 : f0dc             [ 3] 	beq df_rt_asm_print_rts
f4c7 : a920             [ 2] 	lda #' '
f4c9 : 2049c4           [ 6] 	jsr io_put_ch
f4cc : 60               [ 6] 	rts
                             	
                             	
f4cd :                       df_rt_asm_printOPR
                             	; Check the option bit 0 (Print)
f4cd : a901             [ 2] 	lda #0x01
f4cf : 25ee             [ 3] 	and df_asmopt
f4d1 : f0d0             [ 3] 	beq df_rt_asm_print_rts	
f4d3 : a5f3             [ 3] 	lda df_asmlen				; check how may operand bytes
f4d5 : c901             [ 2] 	cmp #1						; if only opcode, done
f4d7 : f0ca             [ 3] 	beq df_rt_asm_print_rts	
f4d9 : c902             [ 2] 	cmp #2
f4db : f005             [ 3] 	beq df_rt_asm_printOPR_1	; if only 2 do low byte
f4dd : a5f2             [ 3] 	lda df_asmoprnd+1
f4df : 2003c7           [ 6] 	jsr jsrPrintA
f4e2 :                       df_rt_asm_printOPR_1
f4e2 : a5f1             [ 3] 	lda df_asmoprnd
f4e4 : 2003c7           [ 6] 	jsr jsrPrintA
f4e7 : 60               [ 6] 	rts
                             
f4e8 :                       df_rt_asm_printCR
                             	; Check the option bit 0 (Print)
f4e8 : a901             [ 2] 	lda #0x01
f4ea : 25ee             [ 3] 	and df_asmopt
f4ec : f0b5             [ 3] 	beq df_rt_asm_print_rts
f4ee : a90d             [ 2] 	lda #UTF_CR
f4f0 : 2049c4           [ 6] 	jsr io_put_ch
f4f3 : 60               [ 6] 	rts
                             
f4f4 :                       df_rt_asm_printCH
f4f4 : 853f             [ 3] 	sta tmp_a
                             	; Check the option bit 0 (Print)
f4f6 : a901             [ 2] 	lda #0x01
f4f8 : 25ee             [ 3] 	and df_asmopt
f4fa : f0a7             [ 3] 	beq df_rt_asm_print_rts
f4fc : a53f             [ 3] 	lda tmp_a
f4fe : 4c49c4           [ 3] 	jmp io_put_ch
f501 : 60               [ 6] 	rts
                             
                             ; Print an entire line, but save df_exeoff
f502 :                       df_rt_asm_printline
                             	; Check the option bit 0 (Print)
f502 : a901             [ 2] 	lda #0x01
f504 : 25ee             [ 3] 	and df_asmopt
f506 : f09b             [ 4] 	beq df_rt_asm_print_rts
f508 : a5d1             [ 3] 	lda df_exeoff
f50a : 48               [ 3] 	pha
                             	; use df_tmpptra
                             	_cpyZPWord df_currlin, df_tmpptra
AS65 Assembler for R6502 [1.42].                                     Page  199
-------------------------------- bank\bank1.s --------------------------------

                             
f513 : 2014e6           [ 6] 	jsr df_rt_list_line_only
f516 : 68               [ 4] 	pla
f517 : 85d1             [ 3] 	sta df_exeoff
f519 : 60               [ 6] 	rts
                             
                             
                             ; Calculate the addressing mode
                             ; Populate the operand as needed
                             ; A and df_asmadmd contain Addressing Mode
f51a :                       df_rt_asm_addrmode	
                             	; Store nothing in address mode
f51a : a900             [ 2] 	lda #AM_NONE
f51c : 85ef             [ 3] 	sta df_asmadmd
                             	; zero out the operand
f51e : 64f1             [ 3] 	stz df_asmoprnd
f520 : 64f2             [ 3] 	stz df_asmoprnd+1
                             	; jump over whitespace
f522 : 20c5db           [ 6] 	jsr df_rt_skip_ws
f525 : 206ae4           [ 6] 	jsr df_rt_eos			; End of statement?
f528 : b00a             [ 3] 	bcs df_rt_asm_AM_IMP
                             	; Check what it is
f52a : c923             [ 2] 	cmp #'#'				; Immediate?
f52c : f034             [ 3] 	beq df_rt_asm_AM_IMM
f52e : c928             [ 2] 	cmp #'('				; Indirect something?
f530 : f03a             [ 3] 	beq df_rt_asm_AM_INDIRECT
                             	; Must be ABS,ZP or REL
f532 : 8005             [ 3] 	bra df_rt_asm_ABSREL
                             ; Process IMP/ACC
f534 :                       df_rt_asm_AM_IMP
f534 : a90d             [ 2] 	lda #AM_IMP
f536 : 85ef             [ 3] 	sta df_asmadmd
f538 : 60               [ 6] 	rts
                             ; Process ABS or REL
f539 :                       df_rt_asm_ABSREL	
                             	; Evaluate operand
f539 : 2095f5           [ 6] 	jsr df_rt_asm_get_operand
f53c : 206ae4           [ 6] 	jsr df_rt_eos			; End of statement?
f53f : b00f             [ 3] 	bcs df_rt_asm_AM_ABS
f541 : c8               [ 2] 	iny						; Jump over ","
f542 : b1cf             [ 5] 	lda (df_currlin),y		; Load X or Y
f544 : c8               [ 2] 	iny						; Jump over index reg
f545 : 85d1             [ 3] 	sta df_exeoff			; Save exe offset
f547 : c978             [ 2] 	cmp #'x'				; Indirect X?
f549 : f012             [ 3] 	beq df_rt_asm_AM_ABSX
                             ; Process ABSY
f54b :                       df_rt_asm_AM_ABSY
f54b : a906             [ 2] 	lda #AM_ZPY				; Go for smallest modes
f54d : 85ef             [ 3] 	sta df_asmadmd
f54f : 60               [ 6] 	rts
                             ; Process what looks like pure ABS, could be REL
f550 :                       df_rt_asm_AM_ABS
f550 : a001             [ 2] 	ldy #1					; Check first addressing mode
f552 : b1ca             [ 5] 	lda (df_symtab),y
f554 : c90f             [ 2] 	cmp #AM_REL
f556 : f002             [ 3] 	beq df_rt_asm_AM_REL
f558 : a904             [ 2] 	lda #AM_ZP				; Go for smallest modes
f55a :                       df_rt_asm_AM_REL
f55a : 85ef             [ 3] 	sta df_asmadmd
f55c : 60               [ 6] 	rts
                             ; Process ABSX
f55d :                       df_rt_asm_AM_ABSX
AS65 Assembler for R6502 [1.42].                                     Page  200
-------------------------------- bank\bank1.s --------------------------------

f55d : a905             [ 2] 	lda #AM_ZPX				; Go for smallest modes
f55f : 85ef             [ 3] 	sta df_asmadmd
f561 : 60               [ 6] 	rts
                             ; Process Immediate
f562 :                       df_rt_asm_AM_IMM
                             	; skip over #
f562 : e6d1             [ 5] 	inc df_exeoff
                             	; Get operand
f564 : 2095f5           [ 6] 	jsr df_rt_asm_get_operand
                             	; Mark as immediate
f567 : a90c             [ 2] 	lda #AM_IMM
f569 : 85ef             [ 3] 	sta df_asmadmd
f56b : 60               [ 6] 	rts
                             ; Process indirect
f56c :                       df_rt_asm_AM_INDIRECT
                             	; skip over (
f56c : e6d1             [ 5] 	inc df_exeoff
                             	; Calculate the operand
f56e : 2095f5           [ 6] 	jsr df_rt_asm_get_operand
                             	; what is next char?
f571 : a4d1             [ 3] 	ldy df_exeoff
f573 : b1cf             [ 5] 	lda (df_currlin),y
f575 : c929             [ 2] 	cmp #')'			; Could be IND or INDY
f577 : f009             [ 3] 	beq df_rt_asm_AM_ZPINDORY
                             	; else must be INDX
                             	; skip 'x)'
f579 : c8               [ 2] 	iny
f57a : c8               [ 2] 	iny
f57b : 84d1             [ 3] 	sty df_exeoff
f57d : a908             [ 2] 	lda #AM_ZPINDX
f57f : 85ef             [ 3] 	sta df_asmadmd
f581 : 60               [ 6] 	rts
                             ; Pure indirect mode found
f582 :                       df_rt_asm_AM_ZPINDORY
f582 : a907             [ 2] 	lda #AM_ZPIND			; Assume ZPIND
f584 : c8               [ 2] 	iny
f585 : 84d1             [ 3] 	sty df_exeoff
                             	; if at end of line/statement then pure indirect
f587 : 206ae4           [ 6] 	jsr df_rt_eos			; End of statement?
f58a : b006             [ 3] 	bcs df_rt_asm_AM_ZPIND
                             	; else must be INDY
f58c : a909             [ 2] 	lda #AM_ZPINDY
                             	; skip ',Y'
f58e : c8               [ 2] 	iny
f58f : c8               [ 2] 	iny
f590 : 84d1             [ 3] 	sty df_exeoff
f592 :                       df_rt_asm_AM_ZPIND
f592 : 85ef             [ 3] 	sta df_asmadmd
f594 : 60               [ 6] 	rts
                             
                             ; Get and save the operand
                             ; df_asmoprnd contains the result
f595 :                       df_rt_asm_get_operand
                             	; evaluate
f595 : 2061d7           [ 6] 	jsr df_rt_neval
                             	; Get the parameter from stack
f598 : 2073ef           [ 6] 	jsr df_st_popInt
                             	; put in the operand
f59b : 86f1             [ 3] 	stx df_asmoprnd
f59d : 85f2             [ 3] 	sta df_asmoprnd+1
f59f : 60               [ 6] 	rts
                             	
AS65 Assembler for R6502 [1.42].                                     Page  201
-------------------------------- bank\bank1.s --------------------------------

                             ; From current symtab entry, find addressing
                             ; mode in A.  AM_NONE=Not found, Y=index
f5a0 :                       df_rt_asm_find_addr_mode
                             	; save A in tmp
f5a0 : 853f             [ 3] 	sta tmp_a
                             	; Start first entry (1) - 2 = 0xff
f5a2 : a0ff             [ 2] 	ldy #0xff
f5a4 :                       df_rt_asm_find_addr_mode_loop
                             	; next entry
f5a4 : c8               [ 2] 	iny
f5a5 : c8               [ 2] 	iny
                             	; if current index > num entries then error
f5a6 : 98               [ 2] 	tya
f5a7 : 38               [ 2] 	sec
f5a8 : f2ca             [ 5] 	sbc (df_symtab)
f5aa : b007             [ 3] 	bcs df_rt_asm_find_addr_mode_err
                             	; is symtab addressing mode what we want?
f5ac : b1ca             [ 5] 	lda (df_symtab),y
f5ae : c53f             [ 3] 	cmp tmp_a
f5b0 : d0f2             [ 3] 	bne df_rt_asm_find_addr_mode_loop
                             	; done A=mode, y=index in to df_symtab
f5b2 : 60               [ 6] 	rts
f5b3 :                       df_rt_asm_find_addr_mode_err
f5b3 : a900             [ 2] 	lda #AM_NONE
f5b5 : 60               [ 6] 	rts
                             
                             
                             ; Skip X amount of symbols in table
                             ; A contains how many addr mode and op code bytes
                             ; df_symtab points to offset byte
f5b6 :                       df_rt_asm_skip_to_sym
f5b6 : e8               [ 2] 	inx				; so done when X=0
                             	; Start at token symbols beginning
f5b7 : a902             [ 2] 	lda #lo(df_asm_tokensyms)
f5b9 : 85ca             [ 3] 	sta df_symtab
f5bb : a9f6             [ 2] 	lda #hi(df_asm_tokensyms)
f5bd : 85cb             [ 3] 	sta df_symtab+1
f5bf : 64cc             [ 3] 	stz df_symoff
f5c1 :                       df_rt_asm_skip_to_sym_next
                             	; Get symtable char
f5c1 : b2ca             [ 5] 	lda (df_symtab)
                             	; if < ' ' then jumped over symbol chars
f5c3 : c920             [ 2] 	cmp #' '
f5c5 : 9008             [ 3] 	bcc df_rt_asm_skip_to_sym_end
                             	;else next smy tab char
                             	_incZPWord df_symtab
                             
f5cd : 80f2             [ 3] 	bra df_rt_asm_skip_to_sym_next
                             	; Found end of symbol
f5cf :                       df_rt_asm_skip_to_sym_end
                             	;if done then return
f5cf : ca               [ 2] 	dex
f5d0 : f00d             [ 3] 	beq df_rt_asm_skip_to_sym_done
                             	;jump over addr and op code by A bytes
f5d2 : 38               [ 2] 	sec
f5d3 : 65ca             [ 3] 	adc df_symtab
f5d5 : 85ca             [ 3] 	sta df_symtab
f5d7 : a5cb             [ 3] 	lda df_symtab+1
f5d9 : 6900             [ 2] 	adc #0
f5db : 85cb             [ 3] 	sta df_symtab+1
f5dd : 80e2             [ 3] 	bra df_rt_asm_skip_to_sym_next
                             	
AS65 Assembler for R6502 [1.42].                                     Page  202
-------------------------------- bank\bank1.s --------------------------------

f5df :                       df_rt_asm_skip_to_sym_done
f5df : 60               [ 6] 	rts
                             
f5e0 :                       mod_sz_rtasm_e
                             
                             
                             	include "dflat\asmsymtab.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  ASMSYMTAB.S
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
                             	;* Length of each addressing mode
                             	;* ORDER significant!
f5e0 :                       df_asm_length
f5e0 : 00030303020202..      	db	0,3,3,3,2,2,2,2,2,2,3,3,2,1,1,2,0
                             
                             	; Always try for lowest addressing mode, but
                             	; this table maps to alternative
f5f1 :                       df_asm_altaddrmode
f5f1 : 00                    	db AM_NONE		;AM_NONE	= 0
f5f2 : 00                    	db AM_NONE		;AM_ABS	 	= 1
f5f3 : 00                    	db AM_NONE		;AM_ABSX	= 2
f5f4 : 00                    	db AM_NONE		;AM_ABSY	= 3
f5f5 : 01                    	db AM_ABS		;AM_ZP		= 4
f5f6 : 02                    	db AM_ABSX		;AM_ZPX		= 5
f5f7 : 03                    	db AM_ABSY		;AM_ZPY		= 6
f5f8 : 0a                    	db AM_ABSIND	;AM_ZPIND	= 7
f5f9 : 0b                    	db AM_ABSINDX	;AM_ZPINDX	= 8
f5fa : 09                    	db AM_ZPINDY	;AM_ZPINDY	= 9
f5fb : 00                    	db AM_NONE		;AM_ABSIND	= 10
f5fc : 00                    	db AM_NONE		;AM_ABSINDX	= 11
f5fd : 00                    	db AM_NONE		;AM_IMM		= 12
f5fe : 00                    	db AM_NONE		;AM_ACC		= 13
f5ff : 00                    	db AM_NONE		;AM_IMP		= AM_ACC
f600 : 0f                    	db AM_REL		;AM_REL		= 15
f601 : 00                    	db AM_NONE		;AM_DIR		= 16
                             
                             
                             	;*	Mnemonic/	How many addressing modes /
                             	;* 	Mode		Opcode for mode
f602 :                       df_asm_tokensyms
                             	;* Start with directives
f602 : 6f726702              	db	"org",		1*2
f606 : 1000                  	db	AM_DIR,		0x00
f608 : 6f707402              	db	"opt",		1*2
f60c : 1000                  	db	AM_DIR,		0x00
f60e : 646202                	db	"db",		1*2
f611 : 1000                  	db	AM_DIR,		0x00
f613 : 647702                	db	"dw",		1*2
f616 : 1000                  	db	AM_DIR,		0x00
f618 : 647302                	db	"ds",		1*2
AS65 Assembler for R6502 [1.42].                                     Page  203
-------------------------------- bank\bank1.s --------------------------------

f61b : 1000                  	db	AM_DIR,		0x00	
                             
f61d : 61646312              	db	"adc",		9*2
f621 : 0c69                  	db	AM_IMM,		0x69
f623 : 0465                  	db	AM_ZP,		0x65
f625 : 0575                  	db	AM_ZPX,		0x75
f627 : 016d                  	db	AM_ABS,		0x6d
f629 : 027d                  	db	AM_ABSX,	0x7d
f62b : 0379                  	db	AM_ABSY,	0x79
f62d : 0861                  	db	AM_ZPINDX,	0x61
f62f : 0971                  	db	AM_ZPINDY,	0x71
f631 : 0772                  	db	AM_ZPIND,	0x72
                             	
f633 : 616e6412              	db	"and",		9*2
f637 : 0c29                  	db	AM_IMM,		0x29
f639 : 0425                  	db	AM_ZP,		0x25
f63b : 0535                  	db	AM_ZPX,		0x35
f63d : 012d                  	db	AM_ABS,		0x2d
f63f : 023d                  	db	AM_ABSX,	0x3d
f641 : 0339                  	db	AM_ABSY,	0x39
f643 : 0821                  	db	AM_ZPINDX,	0x21
f645 : 0931                  	db	AM_ZPINDY,	0x31
f647 : 0732                  	db	AM_ZPIND,	0x32
                             
f649 : 636d7012              	db	"cmp",		9*2
f64d : 0cc9                  	db	AM_IMM,		0xc9
f64f : 04c5                  	db	AM_ZP,		0xc5
f651 : 05d5                  	db	AM_ZPX,		0xd5
f653 : 01cd                  	db	AM_ABS,		0xcd
f655 : 02dd                  	db	AM_ABSX,	0xdd
f657 : 03d9                  	db	AM_ABSY,	0xd9
f659 : 08c1                  	db	AM_ZPINDX,	0xc1
f65b : 09d1                  	db	AM_ZPINDY,	0xd1
f65d : 07d2                  	db	AM_ZPIND,	0xd2
                             
f65f : 656f7212              	db	"eor",		9*2
f663 : 0c49                  	db	AM_IMM,		0x49
f665 : 0445                  	db	AM_ZP,		0x45
f667 : 0555                  	db	AM_ZPX,		0x55
f669 : 014d                  	db	AM_ABS,		0x4d
f66b : 025d                  	db	AM_ABSX,	0x5d
f66d : 0359                  	db	AM_ABSY,	0x59
f66f : 0841                  	db	AM_ZPINDX,	0x41
f671 : 0951                  	db	AM_ZPINDY,	0x51
f673 : 0752                  	db	AM_ZPIND,	0x52
                             
f675 : 6c646112              	db	"lda",		9*2
f679 : 0ca9                  	db	AM_IMM,		0xa9
f67b : 04a5                  	db	AM_ZP,		0xa5
f67d : 05b5                  	db	AM_ZPX,		0xb5
f67f : 01ad                  	db	AM_ABS,		0xad
f681 : 02bd                  	db	AM_ABSX,	0xbd
f683 : 03b9                  	db	AM_ABSY,	0xb9
f685 : 08a1                  	db	AM_ZPINDX,	0xa1
f687 : 09b1                  	db	AM_ZPINDY,	0xb1
f689 : 07b2                  	db	AM_ZPIND,	0xb2
                             
f68b : 6f726112              	db	"ora",		9*2
f68f : 0c09                  	db	AM_IMM,		0x09
f691 : 0405                  	db	AM_ZP,		0x05
f693 : 0515                  	db	AM_ZPX,		0x15
f695 : 010d                  	db	AM_ABS,		0x0d
AS65 Assembler for R6502 [1.42].                                     Page  204
-------------------------------- bank\bank1.s --------------------------------

f697 : 021d                  	db	AM_ABSX,	0x1d
f699 : 0319                  	db	AM_ABSY,	0x19
f69b : 0801                  	db	AM_ZPINDX,	0x01
f69d : 0911                  	db	AM_ZPINDY,	0x11
f69f : 0712                  	db	AM_ZPIND,	0x12
                             
f6a1 : 73626312              	db	"sbc",		9*2
f6a5 : 0ce9                  	db	AM_IMM,		0xe9
f6a7 : 04e5                  	db	AM_ZP,		0xe5
f6a9 : 05f5                  	db	AM_ZPX,		0xf5
f6ab : 01ed                  	db	AM_ABS,		0xed
f6ad : 02fd                  	db	AM_ABSX,	0xfd
f6af : 03f9                  	db	AM_ABSY,	0xf9
f6b1 : 08e1                  	db	AM_ZPINDX,	0xe1
f6b3 : 09f1                  	db	AM_ZPINDY,	0xf1
f6b5 : 07f2                  	db	AM_ZPIND,	0xf2
                             
f6b7 : 73746110              	db	"sta",		8*2
f6bb : 0485                  	db	AM_ZP,		0x85
f6bd : 0585                  	db	AM_ZPX,		0x85
f6bf : 018d                  	db	AM_ABS,		0x8d
f6c1 : 029d                  	db	AM_ABSX,	0x9d
f6c3 : 0399                  	db	AM_ABSY,	0x99
f6c5 : 0881                  	db	AM_ZPINDX,	0x81
f6c7 : 0991                  	db	AM_ZPINDY,	0x91
f6c9 : 0792                  	db	AM_ZPIND,	0x92
                             
f6cb : 61736c0a              	db	"asl",		5*2
f6cf : 0d0a                  	db	AM_IMP,		0x0a
f6d1 : 0406                  	db	AM_ZP,		0x06
f6d3 : 0516                  	db	AM_ZPX,		0x16
f6d5 : 010e                  	db	AM_ABS,		0x0e
f6d7 : 021e                  	db	AM_ABSX,	0x1e
f6d9 : 6465630a              	db	"dec",		5*2
f6dd : 0d3a                  	db	AM_IMP,		0x3a
f6df : 04c6                  	db	AM_ZP,		0xc6
f6e1 : 05d6                  	db	AM_ZPX,		0xd6
f6e3 : 01ce                  	db	AM_ABS,		0xce
f6e5 : 02de                  	db	AM_ABSX,	0xde
f6e7 : 696e630a              	db	"inc",		5*2
f6eb : 0d1a                  	db	AM_IMP,		0x1a
f6ed : 04e6                  	db	AM_ZP,		0xe6
f6ef : 05f6                  	db	AM_ZPX,		0xf6
f6f1 : 01ee                  	db	AM_ABS,		0xee
f6f3 : 02fe                  	db	AM_ABSX,	0xfe
f6f5 : 6c73720a              	db	"lsr",		5*2
f6f9 : 0d4a                  	db	AM_IMP,		0x4a
f6fb : 0446                  	db	AM_ZP,		0x46
f6fd : 0556                  	db	AM_ZPX,		0x56
f6ff : 014e                  	db	AM_ABS,		0x4e
f701 : 025e                  	db	AM_ABSX,	0x5e
f703 : 726f6c0a              	db	"rol",		5*2
f707 : 0d2a                  	db	AM_IMP,		0x2a
f709 : 0426                  	db	AM_ZP,		0x26
f70b : 0536                  	db	AM_ZPX,		0x36
f70d : 012e                  	db	AM_ABS,		0x2e
f70f : 023e                  	db	AM_ABSX,	0x3e
f711 : 726f720a              	db	"ror",		5*2
f715 : 0d6a                  	db	AM_IMP,		0x6a
f717 : 0466                  	db	AM_ZP,		0x66
f719 : 0576                  	db	AM_ZPX,		0x76
f71b : 016e                  	db	AM_ABS,		0x6e
AS65 Assembler for R6502 [1.42].                                     Page  205
-------------------------------- bank\bank1.s --------------------------------

f71d : 027e                  	db	AM_ABSX,	0x7e
                             
f71f : 6269740a              	db	"bit",		5*2
f723 : 0c89                  	db	AM_IMM,		0x89
f725 : 0424                  	db	AM_ZP,		0x24
f727 : 0534                  	db	AM_ZPX,		0x34
f729 : 012c                  	db	AM_ABS,		0x2c
f72b : 023c                  	db	AM_ABSX,	0x3c
                             	
f72d : 62726b02              	db	"brk",		1*2
f731 : 0d00                  	db	AM_IMP,		0x00
f733 : 73747002              	db	"stp",		1*2
f737 : 0ddb                  	db	AM_IMP,		0xdb
f739 : 77616902              	db	"wai",		1*2
f73d : 0dcb                  	db	AM_IMP,		0xcb
                             	
f73f : 636c6302              	db	"clc",		1*2
f743 : 0d18                  	db	AM_IMP,		0x18
f745 : 636c6402              	db	"cld",		1*2
f749 : 0dd8                  	db	AM_IMP,		0xd8
f74b : 636c6902              	db	"cli",		1*2
f74f : 0d58                  	db	AM_IMP,		0x58
f751 : 636c7602              	db	"clv",		1*2
f755 : 0db8                  	db	AM_IMP,		0xb8
f757 : 73656302              	db	"sec",		1*2
f75b : 0d38                  	db	AM_IMP,		0x38
f75d : 73656402              	db	"sed",		1*2
f761 : 0df8                  	db	AM_IMP,		0xf8
f763 : 73656902              	db	"sei",		1*2
f767 : 0d78                  	db	AM_IMP,		0x78
                             	
f769 : 63707806              	db	"cpx",		3*2
f76d : 0ce0                  	db	AM_IMM,		0xe0
f76f : 04e4                  	db	AM_ZP,		0xe4
f771 : 01ec                  	db	AM_ABS,		0xec
f773 : 63707906              	db	"cpy",		3*2
f777 : 0cc0                  	db	AM_IMM,		0xc0
f779 : 04c4                  	db	AM_ZP,		0xc4
f77b : 01cc                  	db	AM_ABS,		0xcc
f77d : 64657802              	db	"dex",		1*2
f781 : 0dca                  	db	AM_IMP,		0xca
f783 : 64657902              	db	"dey",		1*2
f787 : 0d88                  	db	AM_IMP,		0x88
f789 : 696e7802              	db	"inx",		1*2
f78d : 0de8                  	db	AM_IMP,		0xe8
f78f : 696e7902              	db	"iny",		1*2
f793 : 0dc8                  	db	AM_IMP,		0xc8
f795 : 6c64780a              	db	"ldx",		5*2
f799 : 0ca2                  	db	AM_IMM,		0xa2
f79b : 04a6                  	db	AM_ZP,		0xa6
f79d : 06b6                  	db	AM_ZPY,		0xb6
f79f : 01ae                  	db	AM_ABS,		0xae
f7a1 : 03be                  	db	AM_ABSY,	0xbe
f7a3 : 6c64790a              	db	"ldy",		5*2
f7a7 : 0ca0                  	db	AM_IMM,		0xa0
f7a9 : 04a4                  	db	AM_ZP,		0xa4
f7ab : 05b4                  	db	AM_ZPX,		0xb4
f7ad : 01ac                  	db	AM_ABS,		0xac
f7af : 02bc                  	db	AM_ABSX,	0xbc
f7b1 : 73747806              	db	"stx",		3*2
f7b5 : 0486                  	db	AM_ZP,		0x86
f7b7 : 0696                  	db	AM_ZPY,		0x96
AS65 Assembler for R6502 [1.42].                                     Page  206
-------------------------------- bank\bank1.s --------------------------------

f7b9 : 018e                  	db	AM_ABS,		0x8e
f7bb : 73747906              	db	"sty",		3*2
f7bf : 0484                  	db	AM_ZP,		0x84
f7c1 : 0594                  	db	AM_ZPX,		0x94
f7c3 : 018c                  	db	AM_ABS,		0x8c
f7c5 : 73747a08              	db	"stz",		4*2
f7c9 : 0464                  	db	AM_ZP,		0x64
f7cb : 0574                  	db	AM_ZPX,		0x74
f7cd : 019c                  	db	AM_ABS,		0x9c
f7cf : 029e                  	db	AM_ABSX,	0x9e
                             	
                             
f7d1 : 62636302              	db	"bcc",		1*2
f7d5 : 0f90                  	db	AM_REL,		0x90
f7d7 : 62637302              	db	"bcs",		1*2
f7db : 0fb0                  	db	AM_REL,		0xb0
f7dd : 62657102              	db	"beq",		1*2
f7e1 : 0ff0                  	db	AM_REL,		0xf0
f7e3 : 626d6902              	db	"bmi",		1*2
f7e7 : 0f30                  	db	AM_REL,		0x30
f7e9 : 626e6502              	db	"bne",		1*2
f7ed : 0fd0                  	db	AM_REL,		0xd0
f7ef : 62706c02              	db	"bpl",		1*2
f7f3 : 0f10                  	db	AM_REL,		0x10
f7f5 : 62726102              	db	"bra",		1*2
f7f9 : 0f80                  	db	AM_REL,		0x80
f7fb : 62766302              	db	"bvc",		1*2
f7ff : 0f50                  	db	AM_REL,		0x50
f801 : 62767302              	db	"bvs",		1*2
f805 : 0f70                  	db	AM_REL,		0x70
f807 : 6a6d7006              	db	"jmp",		3*2
f80b : 014c                  	db	AM_ABS,		0x4c
f80d : 0a6c                  	db	AM_ABSIND,	0x6c
f80f : 0b7c                  	db	AM_ABSINDX,	0x7c
f811 : 6a737202              	db	"jsr",		1*2
f815 : 0120                  	db	AM_ABS,		0x20
                             	
f817 : 6e6f7002              	db	"nop",		1*2
f81b : 0dea                  	db	AM_IMP,		0xea
f81d : 70686102              	db	"pha",		1*2
f821 : 0d48                  	db	AM_IMP,		0x48
f823 : 70687002              	db	"php",		1*2
f827 : 0d08                  	db	AM_IMP,		0x08
f829 : 70687802              	db	"phx",		1*2
f82d : 0dda                  	db	AM_IMP,		0xda
f82f : 70687902              	db	"phy",		1*2
f833 : 0d5a                  	db	AM_IMP,		0x5a
f835 : 706c6102              	db	"pla",		1*2
f839 : 0d68                  	db	AM_IMP,		0x68
f83b : 706c7002              	db	"plp",		1*2
f83f : 0d28                  	db	AM_IMP,		0x28
f841 : 706c7802              	db	"plx",		1*2
f845 : 0dfa                  	db	AM_IMP,		0xfa
f847 : 706c7902              	db	"ply",		1*2
f84b : 0d7a                  	db	AM_IMP,		0x7a
f84d : 72746902              	db	"rti",		1*2
f851 : 0d40                  	db	AM_IMP,		0x40
f853 : 72747302              	db	"rts",		1*2
f857 : 0d60                  	db	AM_IMP,		0x60
f859 : 74617802              	db	"tax",		1*2
f85d : 0daa                  	db	AM_IMP,		0xaa
f85f : 74617902              	db	"tay",		1*2
AS65 Assembler for R6502 [1.42].                                     Page  207
-------------------------------- bank\bank1.s --------------------------------

f863 : 0da8                  	db	AM_IMP,		0xa8
f865 : 74737802              	db	"tsx",		1*2
f869 : 0dba                  	db	AM_IMP,		0xba
f86b : 74786102              	db	"txa",		1*2
f86f : 0d8a                  	db	AM_IMP,		0x8a
f871 : 74787302              	db	"txs",		1*2
f875 : 0d9a                  	db	AM_IMP,		0x9a
f877 : 74796102              	db	"tya",		1*2
f87b : 0d98                  	db	AM_IMP,		0x98
                             	
f87d : 74726204              	db	"trb",		2*2
f881 : 0414                  	db	AM_ZP,		0x14
f883 : 011c                  	db	AM_ABS,		0x1c
f885 : 74736204              	db	"tsb",		2*2
f889 : 0404                  	db	AM_ZP,		0x04
f88b : 010c                  	db	AM_ABS,		0x0c
                             	
f88d : 6262723002            	db	"bbr0",		1*2
f892 : 0f0f                  	db	AM_REL,		0x0f
f894 : 6262723102            	db	"bbr1",		1*2
f899 : 0f1f                  	db	AM_REL,		0x1f
f89b : 6262723202            	db	"bbr2",		1*2
f8a0 : 0f2f                  	db	AM_REL,		0x2f
f8a2 : 6262723302            	db	"bbr3",		1*2
f8a7 : 0f3f                  	db	AM_REL,		0x3f
f8a9 : 6262723402            	db	"bbr4",		1*2
f8ae : 0f4f                  	db	AM_REL,		0x4f
f8b0 : 6262723502            	db	"bbr5",		1*2
f8b5 : 0f5f                  	db	AM_REL,		0x5f
f8b7 : 6262723602            	db	"bbr6",		1*2
f8bc : 0f6f                  	db	AM_REL,		0x6f
f8be : 6262723702            	db	"bbr7",		1*2
f8c3 : 0f7f                  	db	AM_REL,		0x7f
f8c5 : 6262733002            	db	"bbs0",		1*2
f8ca : 0f8f                  	db	AM_REL,		0x8f
f8cc : 6262733102            	db	"bbs1",		1*2
f8d1 : 0f9f                  	db	AM_REL,		0x9f
f8d3 : 6262733202            	db	"bbs2",		1*2
f8d8 : 0faf                  	db	AM_REL,		0xaf
f8da : 6262733302            	db	"bbs3",		1*2
f8df : 0fbf                  	db	AM_REL,		0xbf
f8e1 : 6262733402            	db	"bbs4",		1*2
f8e6 : 0fcf                  	db	AM_REL,		0xcf
f8e8 : 6262733502            	db	"bbs5",		1*2
f8ed : 0fdf                  	db	AM_REL,		0xdf
f8ef : 6262733602            	db	"bbs6",		1*2
f8f4 : 0fef                  	db	AM_REL,		0xef
f8f6 : 6262733702            	db	"bbs7",		1*2
f8fb : 0fff                  	db	AM_REL,		0xff
f8fd : 726d623002            	db	"rmb0",		1*2
f902 : 0f07                  	db	AM_REL,		0x07
f904 : 726d623102            	db	"rmb1",		1*2
f909 : 0f17                  	db	AM_REL,		0x17
f90b : 726d623202            	db	"rmb2",		1*2
f910 : 0f27                  	db	AM_REL,		0x27
f912 : 726d623302            	db	"rmb3",		1*2
f917 : 0f37                  	db	AM_REL,		0x37
f919 : 726d623402            	db	"rmb4",		1*2
f91e : 0f47                  	db	AM_REL,		0x47
f920 : 726d623502            	db	"rmb5",		1*2
f925 : 0f57                  	db	AM_REL,		0x57
f927 : 726d623602            	db	"rmb6",		1*2
AS65 Assembler for R6502 [1.42].                                     Page  208
-------------------------------- bank\bank1.s --------------------------------

f92c : 0f67                  	db	AM_REL,		0x67
f92e : 726d623702            	db	"rmb7",		1*2
f933 : 0f77                  	db	AM_REL,		0x77
f935 : 736d623002            	db	"smb0",		1*2
f93a : 0f87                  	db	AM_REL,		0x87
f93c : 736d623102            	db	"smb1",		1*2
f941 : 0f97                  	db	AM_REL,		0x97
f943 : 736d623202            	db	"smb2",		1*2
f948 : 0fa7                  	db	AM_REL,		0xa7
f94a : 736d623302            	db	"smb3",		1*2
f94f : 0fb7                  	db	AM_REL,		0xb7
f951 : 736d623402            	db	"smb4",		1*2
f956 : 0fc7                  	db	AM_REL,		0xc7
f958 : 736d623502            	db	"smb5",		1*2
f95d : 0fd7                  	db	AM_REL,		0xd7
f95f : 736d623602            	db	"smb6",		1*2
f964 : 0fe7                  	db	AM_REL,		0xe7
f966 : 736d623702            	db	"smb7",		1*2
f96b : 0ff7                  	db	AM_REL,		0xf7
                             	
                             	;* Terminates with a zero
f96d : 00                    	db	0
                             
                             	include	"dflat\asmjmptab.s"
                             ;************************************************
                             ;*
                             ;*	BBC-128 HOMEBREW COMPUTER
                             ;*	Hardware and software design by @6502Nerd (Dol
                             ;*	Copyright 2014-20
                             ;*  Free to use for any non-commercial purpose su
                             ;*  appropriate credit of my authorship please!
                             ;*
                             ;*  ASMJUMPTAB.S
                             ;*  Runtime token jump table for assembler.
                             ;*  dflat uses four key tables to tokenise and ru
                             ;*  - df_tokensyms    - table of token symbols
                             ;*  - df_tk_tokentype - table of token types
                             ;*  - df_tk_tokenjmp  - table of tokenising routi
                             ;*  - df_rt_tokenjmp  - table of runtime routines
                             ;*  The key is the token symbols.  When a line is
                             ;*  in to the raw (untokenised) buffer, df_tokens
                             ;*  used to identify tokens.  The position of the
                             ;*  token is used to then look up type and jump v
                             ;*  in the other tables.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
                             ; Tokeniser jump table
                             ; Only directives needed as all opcodes are handl
                             ; through a single routine
f96e :                       df_tk_asm_tokenjmp
f96e : 6ad5                  	dw	df_tk_asm_org
f970 : 6ad5                  	dw	df_tk_asm_opt
f972 : ced4                  	dw	df_tk_asm_db
f974 : ced4                  	dw	df_tk_asm_dw
f976 : 6ad5                  	dw	df_tk_asm_ds
                             
f978 :                       df_rt_asm_tokenjmp
f978 : 22f3                  	dw	df_rt_asm_org
AS65 Assembler for R6502 [1.42].                                     Page  209
-------------------------------- bank\bank1.s --------------------------------

f97a : 35f3                  	dw	df_rt_asm_opt
f97c : 3df3                  	dw	df_rt_asm_db
f97e : 43f3                  	dw	df_rt_asm_dw
f980 : b5f3                  	dw	df_rt_asm_ds
                             
                             
                             ;****************************************
                             ;* as_init
                             ;* Initialise assembler settings
                             ;****************************************
f982 :                       asm_init
                             	; Zero the PC
f982 : 64ec             [ 3] 	stz df_asmpc
f984 : 64ed             [ 3] 	stz df_asmpc+1
                             	; Zero the option
f986 : 64ee             [ 3] 	stz df_asmopt
f988 : 60               [ 6] 	rts
                             	
f989 :                       mod_sz_asm_e
                             
                             
                             	; End of Code
f989 :                       _code_end
                             
No errors in pass 2.
Wrote binary from address $c000 through $ffff.
Total size 16384 bytes.
